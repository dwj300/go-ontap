/*
 * ONTAP REST API
 *
 * ONTAP 9.6 adds support for an expansive RESTful API. The documentation below provides information about the types of API calls available to you, as well as details about using each API endpoint. You can learn more about the ONTAP REST API and ONTAP in the ONTAP 9 Documentation Center:  http://docs.netapp.com/ontap-9/topic/com.netapp.doc.dot-rest-api/home.html. NetApp welcomes your comments and suggestions about the ONTAP REST API and the documentation for its use.</br> **Using the ONTAP 9.6 REST API online documentation** Each API method includes usage examples, as well as a model that displays all the required and optional properties supported by the method. Click the _Model_ link, available with each API method, to see all the required and optional properties supported by each method. 
 *
 * API version: v1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package ontap

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// ClusterApiService ClusterApi service
type ClusterApiService service

// ChassisCollectionGetOpts Optional parameters for the method 'ChassisCollectionGet'
type ChassisCollectionGetOpts struct {
    Id optional.String
    ShelvesUid optional.String
    NodesUuid optional.String
    NodesName optional.String
    State optional.String
    FrusId optional.String
    FrusType optional.String
    FrusState optional.String
    Fields optional.Interface
    MaxRecords optional.Int32
    ReturnRecords optional.Bool
    ReturnTimeout optional.Int32
    OrderBy optional.Interface
}

/*
ChassisCollectionGet Method for ChassisCollectionGet
Retrieves a collection of chassis. ### Related ONTAP commands * &#x60;system chassis show&#x60; * &#x60;system chassis fru show&#x60; ### Learn more * [&#x60;DOC /cluster/chassis&#x60;](#docs-cluster-cluster_chassis) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ChassisCollectionGetOpts - Optional Parameters:
 * @param "Id" (optional.String) -  Filter by id
 * @param "ShelvesUid" (optional.String) -  Filter by shelves.uid
 * @param "NodesUuid" (optional.String) -  Filter by nodes.uuid
 * @param "NodesName" (optional.String) -  Filter by nodes.name
 * @param "State" (optional.String) -  Filter by state
 * @param "FrusId" (optional.String) -  Filter by frus.id
 * @param "FrusType" (optional.String) -  Filter by frus.type
 * @param "FrusState" (optional.String) -  Filter by frus.state
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return ChassisResponse
*/
func (a *ClusterApiService) ChassisCollectionGet(ctx _context.Context, localVarOptionals *ChassisCollectionGetOpts) (ChassisResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ChassisResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/chassis"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ShelvesUid.IsSet() {
		localVarQueryParams.Add("shelves.uid", parameterToString(localVarOptionals.ShelvesUid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NodesUuid.IsSet() {
		localVarQueryParams.Add("nodes.uuid", parameterToString(localVarOptionals.NodesUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NodesName.IsSet() {
		localVarQueryParams.Add("nodes.name", parameterToString(localVarOptionals.NodesName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FrusId.IsSet() {
		localVarQueryParams.Add("frus.id", parameterToString(localVarOptionals.FrusId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FrusType.IsSet() {
		localVarQueryParams.Add("frus.type", parameterToString(localVarOptionals.FrusType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FrusState.IsSet() {
		localVarQueryParams.Add("frus.state", parameterToString(localVarOptionals.FrusState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ChassisResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ChassisGetOpts Optional parameters for the method 'ChassisGet'
type ChassisGetOpts struct {
    Fields optional.Interface
}

/*
ChassisGet Method for ChassisGet
Retrieves a specific chassis. ### Related ONTAP commands * &#x60;system chassis show&#x60; * &#x60;system chassis fru show&#x60; ### Learn more * [&#x60;DOC /cluster/chassis&#x60;](#docs-cluster-cluster_chassis) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Chassis ID
 * @param optional nil or *ChassisGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return Chassis
*/
func (a *ClusterApiService) ChassisGet(ctx _context.Context, id string, localVarOptionals *ChassisGetOpts) (Chassis, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Chassis
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/chassis/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Chassis
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ClusterCollectionPerformanceMetricsGetOpts Optional parameters for the method 'ClusterCollectionPerformanceMetricsGet'
type ClusterCollectionPerformanceMetricsGetOpts struct {
    Timestamp optional.String
    IopsTotal optional.Int32
    IopsOther optional.Int32
    IopsWrite optional.Int32
    IopsRead optional.Int32
    Duration optional.String
    ThroughputTotal optional.Int32
    ThroughputOther optional.Int32
    ThroughputWrite optional.Int32
    ThroughputRead optional.Int32
    LatencyTotal optional.Int32
    LatencyOther optional.Int32
    LatencyWrite optional.Int32
    LatencyRead optional.Int32
    Status optional.String
    ReturnTimeout optional.Int32
    Fields optional.Interface
    MaxRecords optional.Int32
    OrderBy optional.Interface
    ReturnRecords optional.Bool
    Interval optional.String
}

/*
ClusterCollectionPerformanceMetricsGet Method for ClusterCollectionPerformanceMetricsGet
Retrieves historical performance metrics for the cluster. 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ClusterCollectionPerformanceMetricsGetOpts - Optional Parameters:
 * @param "Timestamp" (optional.String) -  Filter by timestamp
 * @param "IopsTotal" (optional.Int32) -  Filter by iops.total
 * @param "IopsOther" (optional.Int32) -  Filter by iops.other
 * @param "IopsWrite" (optional.Int32) -  Filter by iops.write
 * @param "IopsRead" (optional.Int32) -  Filter by iops.read
 * @param "Duration" (optional.String) -  Filter by duration
 * @param "ThroughputTotal" (optional.Int32) -  Filter by throughput.total
 * @param "ThroughputOther" (optional.Int32) -  Filter by throughput.other
 * @param "ThroughputWrite" (optional.Int32) -  Filter by throughput.write
 * @param "ThroughputRead" (optional.Int32) -  Filter by throughput.read
 * @param "LatencyTotal" (optional.Int32) -  Filter by latency.total
 * @param "LatencyOther" (optional.Int32) -  Filter by latency.other
 * @param "LatencyWrite" (optional.Int32) -  Filter by latency.write
 * @param "LatencyRead" (optional.Int32) -  Filter by latency.read
 * @param "Status" (optional.String) -  Filter by status
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "Interval" (optional.String) -  The time range for the data. Examples can be 1h, 1d, 1m, 1w, 1y. The period for each time range is specified as follows: * 1h: Metrics over the most recent hour sampled over 15 second. * 1d: Metrics over the most recent day sampled over 4 minutes. * 1w: Metrics over the most recent week sampled over 30 minutes. * 1m: Metrics over the most recent month sampled over 2 hours. * 1y: Metrics over the most recent year sampled over a day. 
@return ClusterMetricsResponse
*/
func (a *ClusterApiService) ClusterCollectionPerformanceMetricsGet(ctx _context.Context, localVarOptionals *ClusterCollectionPerformanceMetricsGetOpts) (ClusterMetricsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ClusterMetricsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/metrics"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Timestamp.IsSet() {
		localVarQueryParams.Add("timestamp", parameterToString(localVarOptionals.Timestamp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IopsTotal.IsSet() {
		localVarQueryParams.Add("iops.total", parameterToString(localVarOptionals.IopsTotal.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IopsOther.IsSet() {
		localVarQueryParams.Add("iops.other", parameterToString(localVarOptionals.IopsOther.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IopsWrite.IsSet() {
		localVarQueryParams.Add("iops.write", parameterToString(localVarOptionals.IopsWrite.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IopsRead.IsSet() {
		localVarQueryParams.Add("iops.read", parameterToString(localVarOptionals.IopsRead.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Duration.IsSet() {
		localVarQueryParams.Add("duration", parameterToString(localVarOptionals.Duration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ThroughputTotal.IsSet() {
		localVarQueryParams.Add("throughput.total", parameterToString(localVarOptionals.ThroughputTotal.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ThroughputOther.IsSet() {
		localVarQueryParams.Add("throughput.other", parameterToString(localVarOptionals.ThroughputOther.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ThroughputWrite.IsSet() {
		localVarQueryParams.Add("throughput.write", parameterToString(localVarOptionals.ThroughputWrite.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ThroughputRead.IsSet() {
		localVarQueryParams.Add("throughput.read", parameterToString(localVarOptionals.ThroughputRead.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LatencyTotal.IsSet() {
		localVarQueryParams.Add("latency.total", parameterToString(localVarOptionals.LatencyTotal.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LatencyOther.IsSet() {
		localVarQueryParams.Add("latency.other", parameterToString(localVarOptionals.LatencyOther.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LatencyWrite.IsSet() {
		localVarQueryParams.Add("latency.write", parameterToString(localVarOptionals.LatencyWrite.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LatencyRead.IsSet() {
		localVarQueryParams.Add("latency.read", parameterToString(localVarOptionals.LatencyRead.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Status.IsSet() {
		localVarQueryParams.Add("status", parameterToString(localVarOptionals.Status.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Interval.IsSet() {
		localVarQueryParams.Add("interval", parameterToString(localVarOptionals.Interval.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ClusterMetricsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ClusterCreateOpts Optional parameters for the method 'ClusterCreate'
type ClusterCreateOpts struct {
    SingleNodeCluster optional.Bool
}

/*
ClusterCreate Method for ClusterCreate
Sets up a cluster. ### Required properties * &#x60;name&#x60; * &#x60;password&#x60; ### Recommended optional properties * &#x60;location&#x60; * &#x60;contact&#x60; * &#x60;dns_domains&#x60; * &#x60;name_servers&#x60; * &#x60;ntp_servers&#x60; * &#x60;license&#x60; * &#x60;configuration_backup&#x60; * &#x60;management_interface&#x60; * &#x60;nodes&#x60; ### Learn more * [&#x60;DOC /cluster&#x60;](#docs-cluster-cluster) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info Cluster information
 * @param optional nil or *ClusterCreateOpts - Optional Parameters:
 * @param "SingleNodeCluster" (optional.Bool) -  Configures a single node cluster.  All cluster ports are reassigned to the default network.  The storage failover settings are configured to non-HA.  The node reboots during this operation.
@return JobLinkResponse
*/
func (a *ClusterApiService) ClusterCreate(ctx _context.Context, info Cluster, localVarOptionals *ClusterCreateOpts) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.SingleNodeCluster.IsSet() {
		localVarQueryParams.Add("single_node_cluster", parameterToString(localVarOptionals.SingleNodeCluster.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ClusterGetOpts Optional parameters for the method 'ClusterGet'
type ClusterGetOpts struct {
    Fields optional.Interface
}

/*
ClusterGet Method for ClusterGet
Retrieves the cluster configuration. ### Learn more * [&#x60;DOC /cluster&#x60;](#docs-cluster-cluster)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ClusterGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return Cluster
*/
func (a *ClusterApiService) ClusterGet(ctx _context.Context, localVarOptionals *ClusterGetOpts) (Cluster, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Cluster
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Cluster
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
ClusterModify Method for ClusterModify
Updates the cluster configuration once the cluster has been created. ### Learn more * [&#x60;DOC /cluster&#x60;](#docs-cluster-cluster)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info Cluster information
@return JobLinkResponse
*/
func (a *ClusterApiService) ClusterModify(ctx _context.Context, info Cluster) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ClusterPeerCreateOpts Optional parameters for the method 'ClusterPeerCreate'
type ClusterPeerCreateOpts struct {
    Info optional.Interface
}

/*
ClusterPeerCreate Method for ClusterPeerCreate
Creates a peering relationship and, optionally, the IP interfaces it will use. There are two ways to create a peering relationship. ### Provide remote IP Here the user provides the remote IP address. Creating a new cluster peer relationship with a specific remote cluster requires at least one remote intercluster IP address from that cluster. ### Required properties   * &#x60;remote.ip_addresses&#x60; - Addresses of the remote peers. The local peer must be able to reach and connect to these addresses for the request to succeed in creating a peer.   * Either set &#x60;generate_passphrase&#x60; to true or provide a passphrase in the body of the request; only one of them is required. ### Optional properties   The following fields are optional for a POST on /cluster/peer/. All fields must follow the structure in the cluster peer API definition.   * &#x60;name&#x60; - Name of the peering relationship.   * &#x60;passphrase&#x60; - User generated passphrase for use in authentication.   * &#x60;generate_passphrase&#x60; (true/false) - When this option is true, ONTAP automatically generates a passphrase to authenticate cluster peers.   * &#x60;ipspace&#x60; - IPspace of the local intercluster LIFs. Assumes Default IPspace if not provided.   * &#x60;initial_allowed_svms&#x60; - the local SVMs allowed to peer with the peer cluster&#39;s SVMs. This list can be modified until the remote cluster accepts this cluster peering relationship.   * &#x60;local_network&#x60; - fields to create a local intercluster LIF. See section on \&quot;Creating local intercluster lifs\&quot;.   * &#x60;expiry_time&#x60; - Duration in ISO 8601 format for which the user-supplied or auto-generated passphrase is valid. Expiration time must not be greater than seven days into the future. ISO 8601 duration format is \&quot;PnDTnHnMnS\&quot; or \&quot;PnW\&quot; where n is a positive integer. The nD, nH, nM and nS fields can be dropped if zero. \&quot;P\&quot; should always be present and \&quot;T\&quot; should be present if there are any hours, minutes or seconds fields.   * &#x60;encryption_proposed&#x60; (none/tls-psk) - Encryption mechanism of the communication channel between the two peers. ### Do not provide remote IP   This method is used when the remote IP address is not provided. This method is used when the filer is ready to accept peering request from foreign clusters. ### Required properties   * &#x60;generate_passphrase&#x60; (true) - This option must be set to  true. ONTAP automatically generates a passphrase to authenticate cluster peers. Either set generate_passphrase to true or provide a passphrase in the body of the request; only one of them is required. ### Optional properties   The following fields are optional for a POST on /cluster/peer/. All fields must follow the structure in the cluster peer API definition.   * &#x60;name&#x60; - Name of the remote peer.   * &#x60;ipspace&#x60; - IPspace of the local intercluster LIFs. Assumes Default IPspace if not provided.   * &#x60;initial_allowed_svms&#x60; - Local SVMs allowed to peer with the peer cluster&#39;s SVMs. This list can be modified until the remote cluster accepts this cluster peering relationship.   * &#x60;local_network&#x60; - Fields to create a local intercluster LIF. See section on \&quot;Creating local intercluster lifs\&quot;.   * &#x60;expiry_time&#x60; - Duration in ISO 8601 format for which the user-supplied or auto-generated passphrase is valid. Expiration time must not be greater than seven days into the future. ISO 8601 duration format is \&quot;PnDTnHnMnS\&quot; or \&quot;PnW\&quot; where n is a positive integer. The nD, nH, nM and nS fields can be dropped if zero. \&quot;P\&quot; should always be present and \&quot;T\&quot; should be present if there are any hours, minutes or seconds fields.   * &#x60;encryption_proposed&#x60; (none/tls-psk) - Encryption mechanism of the communication channel between the two peers. ## Additional information As with creating a cluster peer through the CLI, the combinations of options must be valid in order for the create operation to succeed. The following list shows the combinations that will succeed and those that will fail: * a passphrase only (fail) * a peer IP address (fail) * a passphrase with an expiration time &gt; 7 days into the future (fail) * peer IP address and a passphrase (OK) * generate_passphrase&#x3D;true (OK) * any proposed encryption protocol (OK) * an IPspace name or UUID (OK) * a passphrase, peer IP address, and any proposed encryption protocol (OK) * a non empty list initial allowed vserver peer names or UUIDs. (OK) ### Learn more * [&#x60;DOC /cluster/peers&#x60;](#docs-cluster-cluster_peers) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ClusterPeerCreateOpts - Optional Parameters:
 * @param "Info" (optional.Interface of ClusterPeer) -  Info specification
@return ClusterPeerSetupResponse
*/
func (a *ClusterApiService) ClusterPeerCreate(ctx _context.Context, localVarOptionals *ClusterPeerCreateOpts) (ClusterPeerSetupResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ClusterPeerSetupResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/peers"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(ClusterPeer)
		if !localVarOptionalInfook {
			return localVarReturnValue, nil, reportError("info should be ClusterPeer")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 201 {
			var v ClusterPeerSetupResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
ClusterPeerDelete Method for ClusterPeerDelete
Deletes a cluster peer. ### Learn more * [&#x60;DOC /cluster/peers&#x60;](#docs-cluster-cluster_peers)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Cluster peer relationship UUID
*/
func (a *ClusterApiService) ClusterPeerDelete(ctx _context.Context, uuid string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/peers/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// ClusterPeerGetOpts Optional parameters for the method 'ClusterPeerGet'
type ClusterPeerGetOpts struct {
    Fields optional.Interface
}

/*
ClusterPeerGet Method for ClusterPeerGet
Retrieves a specific cluster peer instance. ### Learn more * [&#x60;DOC /cluster/peers&#x60;](#docs-cluster-cluster_peers)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Cluster peer relationship UUID
 * @param optional nil or *ClusterPeerGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return ClusterPeer
*/
func (a *ClusterApiService) ClusterPeerGet(ctx _context.Context, uuid string, localVarOptionals *ClusterPeerGetOpts) (ClusterPeer, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ClusterPeer
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/peers/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ClusterPeer
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ClusterPeerModifyOpts Optional parameters for the method 'ClusterPeerModify'
type ClusterPeerModifyOpts struct {
    Info optional.Interface
}

/*
ClusterPeerModify Method for ClusterPeerModify
Updates a cluster peer instance. ### Learn more * [&#x60;DOC /cluster/peers&#x60;](#docs-cluster-cluster_peers)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Cluster peer relationship UUID
 * @param optional nil or *ClusterPeerModifyOpts - Optional Parameters:
 * @param "Info" (optional.Interface of ClusterPeer) -  Info specification
@return ClusterPeerSetupResponse
*/
func (a *ClusterApiService) ClusterPeerModify(ctx _context.Context, uuid string, localVarOptionals *ClusterPeerModifyOpts) (ClusterPeerSetupResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ClusterPeerSetupResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/peers/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(ClusterPeer)
		if !localVarOptionalInfook {
			return localVarReturnValue, nil, reportError("info should be ClusterPeer")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ClusterPeerSetupResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// JobCollectionGetOpts Optional parameters for the method 'JobCollectionGet'
type JobCollectionGetOpts struct {
    StartTime optional.String
    EndTime optional.String
    Uuid optional.String
    Code optional.Int32
    Description optional.String
    Message optional.String
    State optional.String
    Fields optional.Interface
    MaxRecords optional.Int32
    ReturnRecords optional.Bool
    ReturnTimeout optional.Int32
    OrderBy optional.Interface
}

/*
JobCollectionGet Method for JobCollectionGet
Retrieves a list of recently running asynchronous jobs. Once a job transitions to a failure or success state, it is deleted after a default time of 300 seconds. ### Learn more * [&#x60;DOC /cluster/jobs&#x60;](#docs-cluster-cluster_jobs)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *JobCollectionGetOpts - Optional Parameters:
 * @param "StartTime" (optional.String) -  Filter by start_time
 * @param "EndTime" (optional.String) -  Filter by end_time
 * @param "Uuid" (optional.String) -  Filter by uuid
 * @param "Code" (optional.Int32) -  Filter by code
 * @param "Description" (optional.String) -  Filter by description
 * @param "Message" (optional.String) -  Filter by message
 * @param "State" (optional.String) -  Filter by state
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return JobResponse
*/
func (a *ClusterApiService) JobCollectionGet(ctx _context.Context, localVarOptionals *JobCollectionGetOpts) (JobResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/jobs"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.StartTime.IsSet() {
		localVarQueryParams.Add("start_time", parameterToString(localVarOptionals.StartTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndTime.IsSet() {
		localVarQueryParams.Add("end_time", parameterToString(localVarOptionals.EndTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Code.IsSet() {
		localVarQueryParams.Add("code", parameterToString(localVarOptionals.Code.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Message.IsSet() {
		localVarQueryParams.Add("message", parameterToString(localVarOptionals.Message.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v JobResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// JobGetOpts Optional parameters for the method 'JobGet'
type JobGetOpts struct {
    Fields optional.Interface
}

/*
JobGet Method for JobGet
Retrieves the details of a specific asynchronous job. Once a job transitions to a failure or success state, it is deleted after a default time of 300 seconds. ### Learn more * [&#x60;DOC /cluster/jobs&#x60;](#docs-cluster-cluster_jobs)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Job UUID
 * @param optional nil or *JobGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return Job
*/
func (a *ClusterApiService) JobGet(ctx _context.Context, uuid string, localVarOptionals *JobGetOpts) (Job, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Job
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/jobs/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Job
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// JobModifyOpts Optional parameters for the method 'JobModify'
type JobModifyOpts struct {
    Action optional.String
}

/*
JobModify Method for JobModify
Updates the state of a specific asynchronous job. ### Learn more * [&#x60;DOC /cluster/jobs&#x60;](#docs-cluster-cluster_jobs)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Job UUID
 * @param optional nil or *JobModifyOpts - Optional Parameters:
 * @param "Action" (optional.String) -  Request a job to pause, resume, or cancel. Note: Not all jobs support these actions. A job can only be resumed if it is in paused state. Upon successfully requesting a job to be cancelled, the job state changes to either success or failure. 
*/
func (a *ClusterApiService) JobModify(ctx _context.Context, uuid string, localVarOptionals *JobModifyOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/jobs/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Action.IsSet() {
		localVarQueryParams.Add("action", parameterToString(localVarOptionals.Action.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// LicenseCreateOpts Optional parameters for the method 'LicenseCreate'
type LicenseCreateOpts struct {
    ReturnRecords optional.Bool
}

/*
LicenseCreate Method for LicenseCreate
Installs one or more feature licenses. ### Required properties * &#x60;keys&#x60; - Array containing a list of NLF or 26-character license keys. ### Related ONTAP commands * &#x60;system license add&#x60;  ### Learn more * [&#x60;DOC /cluster/licensing/licenses&#x60;](#docs-cluster-cluster_licensing_licenses)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info List of NLF or 26-character keys.
 * @param optional nil or *LicenseCreateOpts - Optional Parameters:
 * @param "ReturnRecords" (optional.Bool) -  The default is false.  If set to true, the records are returned.
@return LicensePackageResponse
*/
func (a *ClusterApiService) LicenseCreate(ctx _context.Context, info LicensePackage, localVarOptionals *LicenseCreateOpts) (LicensePackageResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LicensePackageResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/licensing/licenses"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 201 {
			var v LicensePackageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponses
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
LicenseDelete Method for LicenseDelete
Deletes a license. ### Related ONTAP commands * &#x60;system license delete&#x60;  ### Learn more * [&#x60;DOC /cluster/licensing/licenses/{name}&#x60;](#docs-cluster-cluster_licensing_licenses_{name})
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Name of the license package to delete.
 * @param serialNumber Serial number of the license to delete.
*/
func (a *ClusterApiService) LicenseDelete(ctx _context.Context, name string, serialNumber string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/licensing/licenses/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.QueryEscape(parameterToString(name, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("serial_number", parameterToString(serialNumber, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// LicenseGetOpts Optional parameters for the method 'LicenseGet'
type LicenseGetOpts struct {
    State optional.String
    Name2 optional.String
    LicensesCapacityMaximumSize optional.Int32
    LicensesCapacityUsedSize optional.Int32
    LicensesStartTime optional.String
    LicensesSerialNumber optional.String
    LicensesOwner optional.String
    LicensesEvaluation optional.Bool
    LicensesActive optional.Bool
    LicensesExpiryTime optional.String
    LicensesComplianceState optional.String
    Scope optional.String
    Fields optional.Interface
}

/*
LicenseGet Method for LicenseGet
Retrieves a specific license package. ### Related ONTAP commands * &#x60;system license show&#x60; * &#x60;system license show-status&#x60;  ### Learn more * [&#x60;DOC /cluster/licensing/licenses/{name}&#x60;](#docs-cluster-cluster_licensing_licenses_{name})
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Name of the license package.
 * @param optional nil or *LicenseGetOpts - Optional Parameters:
 * @param "State" (optional.String) -  Filter by state
 * @param "Name2" (optional.String) -  Filter by name
 * @param "LicensesCapacityMaximumSize" (optional.Int32) -  Filter by licenses.capacity.maximum_size
 * @param "LicensesCapacityUsedSize" (optional.Int32) -  Filter by licenses.capacity.used_size
 * @param "LicensesStartTime" (optional.String) -  Filter by licenses.start_time
 * @param "LicensesSerialNumber" (optional.String) -  Filter by licenses.serial_number
 * @param "LicensesOwner" (optional.String) -  Filter by licenses.owner
 * @param "LicensesEvaluation" (optional.Bool) -  Filter by licenses.evaluation
 * @param "LicensesActive" (optional.Bool) -  Filter by licenses.active
 * @param "LicensesExpiryTime" (optional.String) -  Filter by licenses.expiry_time
 * @param "LicensesComplianceState" (optional.String) -  Filter by licenses.compliance.state
 * @param "Scope" (optional.String) -  Filter by scope
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return LicensePackage
*/
func (a *ClusterApiService) LicenseGet(ctx _context.Context, name string, localVarOptionals *LicenseGetOpts) (LicensePackage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LicensePackage
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/licensing/licenses/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.QueryEscape(parameterToString(name, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name2.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name2.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LicensesCapacityMaximumSize.IsSet() {
		localVarQueryParams.Add("licenses.capacity.maximum_size", parameterToString(localVarOptionals.LicensesCapacityMaximumSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LicensesCapacityUsedSize.IsSet() {
		localVarQueryParams.Add("licenses.capacity.used_size", parameterToString(localVarOptionals.LicensesCapacityUsedSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LicensesStartTime.IsSet() {
		localVarQueryParams.Add("licenses.start_time", parameterToString(localVarOptionals.LicensesStartTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LicensesSerialNumber.IsSet() {
		localVarQueryParams.Add("licenses.serial_number", parameterToString(localVarOptionals.LicensesSerialNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LicensesOwner.IsSet() {
		localVarQueryParams.Add("licenses.owner", parameterToString(localVarOptionals.LicensesOwner.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LicensesEvaluation.IsSet() {
		localVarQueryParams.Add("licenses.evaluation", parameterToString(localVarOptionals.LicensesEvaluation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LicensesActive.IsSet() {
		localVarQueryParams.Add("licenses.active", parameterToString(localVarOptionals.LicensesActive.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LicensesExpiryTime.IsSet() {
		localVarQueryParams.Add("licenses.expiry_time", parameterToString(localVarOptionals.LicensesExpiryTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LicensesComplianceState.IsSet() {
		localVarQueryParams.Add("licenses.compliance.state", parameterToString(localVarOptionals.LicensesComplianceState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Scope.IsSet() {
		localVarQueryParams.Add("scope", parameterToString(localVarOptionals.Scope.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v LicensePackage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// LicensesGetOpts Optional parameters for the method 'LicensesGet'
type LicensesGetOpts struct {
    State optional.String
    Name optional.String
    LicensesCapacityMaximumSize optional.Int32
    LicensesCapacityUsedSize optional.Int32
    LicensesStartTime optional.String
    LicensesSerialNumber optional.String
    LicensesOwner optional.String
    LicensesEvaluation optional.Bool
    LicensesActive optional.Bool
    LicensesExpiryTime optional.String
    LicensesComplianceState optional.String
    Scope optional.String
    Fields optional.Interface
    MaxRecords optional.Int32
    ReturnRecords optional.Bool
    ReturnTimeout optional.Int32
    OrderBy optional.Interface
}

/*
LicensesGet Method for LicensesGet
Retrieves a collection of license packages. ### Related ONTAP commands * &#x60;system license show-status&#x60; * &#x60;system license show&#x60;  ### Learn more * [&#x60;DOC /cluster/licensing/licenses&#x60;](#docs-cluster-cluster_licensing_licenses)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *LicensesGetOpts - Optional Parameters:
 * @param "State" (optional.String) -  Filter by state
 * @param "Name" (optional.String) -  Filter by name
 * @param "LicensesCapacityMaximumSize" (optional.Int32) -  Filter by licenses.capacity.maximum_size
 * @param "LicensesCapacityUsedSize" (optional.Int32) -  Filter by licenses.capacity.used_size
 * @param "LicensesStartTime" (optional.String) -  Filter by licenses.start_time
 * @param "LicensesSerialNumber" (optional.String) -  Filter by licenses.serial_number
 * @param "LicensesOwner" (optional.String) -  Filter by licenses.owner
 * @param "LicensesEvaluation" (optional.Bool) -  Filter by licenses.evaluation
 * @param "LicensesActive" (optional.Bool) -  Filter by licenses.active
 * @param "LicensesExpiryTime" (optional.String) -  Filter by licenses.expiry_time
 * @param "LicensesComplianceState" (optional.String) -  Filter by licenses.compliance.state
 * @param "Scope" (optional.String) -  Filter by scope
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return LicensePackageResponse
*/
func (a *ClusterApiService) LicensesGet(ctx _context.Context, localVarOptionals *LicensesGetOpts) (LicensePackageResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LicensePackageResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/licensing/licenses"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LicensesCapacityMaximumSize.IsSet() {
		localVarQueryParams.Add("licenses.capacity.maximum_size", parameterToString(localVarOptionals.LicensesCapacityMaximumSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LicensesCapacityUsedSize.IsSet() {
		localVarQueryParams.Add("licenses.capacity.used_size", parameterToString(localVarOptionals.LicensesCapacityUsedSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LicensesStartTime.IsSet() {
		localVarQueryParams.Add("licenses.start_time", parameterToString(localVarOptionals.LicensesStartTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LicensesSerialNumber.IsSet() {
		localVarQueryParams.Add("licenses.serial_number", parameterToString(localVarOptionals.LicensesSerialNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LicensesOwner.IsSet() {
		localVarQueryParams.Add("licenses.owner", parameterToString(localVarOptionals.LicensesOwner.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LicensesEvaluation.IsSet() {
		localVarQueryParams.Add("licenses.evaluation", parameterToString(localVarOptionals.LicensesEvaluation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LicensesActive.IsSet() {
		localVarQueryParams.Add("licenses.active", parameterToString(localVarOptionals.LicensesActive.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LicensesExpiryTime.IsSet() {
		localVarQueryParams.Add("licenses.expiry_time", parameterToString(localVarOptionals.LicensesExpiryTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LicensesComplianceState.IsSet() {
		localVarQueryParams.Add("licenses.compliance.state", parameterToString(localVarOptionals.LicensesComplianceState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Scope.IsSet() {
		localVarQueryParams.Add("scope", parameterToString(localVarOptionals.Scope.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v LicensePackageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// NodeGetOpts Optional parameters for the method 'NodeGet'
type NodeGetOpts struct {
    Fields optional.Interface
}

/*
NodeGet Method for NodeGet
Retrieves information for the node. ### Learn more * [&#x60;DOC /cluster/nodes&#x60;](#docs-cluster-cluster_nodes)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid
 * @param optional nil or *NodeGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return Node
*/
func (a *ClusterApiService) NodeGet(ctx _context.Context, uuid string, localVarOptionals *NodeGetOpts) (Node, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Node
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/nodes/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Node
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// NodeModifyOpts Optional parameters for the method 'NodeModify'
type NodeModifyOpts struct {
    Action optional.String
    ShutdownRebootReason optional.String
    AllowDataOutage optional.Bool
    Info optional.Interface
}

/*
NodeModify Method for NodeModify
Updates the node information or performs shutdown/reboot actions on a node. ### Learn more * [&#x60;DOC /cluster/nodes&#x60;](#docs-cluster-cluster_nodes)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid
 * @param optional nil or *NodeModifyOpts - Optional Parameters:
 * @param "Action" (optional.String) -  The shutdown action shuts the node down and transfers storage control to its HA group if storage failover is enabled. The reboot action reboots the node and transfers storage control to its HA group if storage failover is enabled. 
 * @param "ShutdownRebootReason" (optional.String) -  Indicates the reason for the reboot or shutdown. This only applies when an action of reboot or shutdown is provided. 
 * @param "AllowDataOutage" (optional.Bool) -  This only applies when an action of reboot or shutdown is provided. It allows storage failover to be bypassed along with any failures related to mainintaing quorum in the cluster. 
 * @param "Info" (optional.Interface of Node) - 
@return JobLinkResponse
*/
func (a *ClusterApiService) NodeModify(ctx _context.Context, uuid string, localVarOptionals *NodeModifyOpts) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/nodes/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Action.IsSet() {
		localVarQueryParams.Add("action", parameterToString(localVarOptionals.Action.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ShutdownRebootReason.IsSet() {
		localVarQueryParams.Add("shutdown_reboot_reason", parameterToString(localVarOptionals.ShutdownRebootReason.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AllowDataOutage.IsSet() {
		localVarQueryParams.Add("allow_data_outage", parameterToString(localVarOptionals.AllowDataOutage.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(Node)
		if !localVarOptionalInfook {
			return localVarReturnValue, nil, reportError("info should be Node")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
NodesCreate Method for NodesCreate
Adds a node or nodes to the cluster ### Required properties * &#x60;cluster_interface.ip.address&#x60;  ### Learn more * [&#x60;DOC /cluster/nodes&#x60;](#docs-cluster-cluster_nodes)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info An object containing an array of nodes.
@return JobLinkResponse
*/
func (a *ClusterApiService) NodesCreate(ctx _context.Context, info Node) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/nodes"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// NodesGetOpts Optional parameters for the method 'NodesGet'
type NodesGetOpts struct {
    Membership optional.String
    Name optional.String
    Model optional.String
    VersionMajor optional.Int32
    VersionMinor optional.Int32
    VersionGeneration optional.Int32
    VersionFull optional.String
    Location optional.String
    ServiceProcessorIpv4InterfaceNetmask optional.String
    ServiceProcessorIpv4InterfaceAddress optional.String
    ServiceProcessorIpv4InterfaceGateway optional.String
    ServiceProcessorMacAddress optional.String
    ServiceProcessorState optional.String
    ServiceProcessorFirmwareVersion optional.String
    ServiceProcessorIpv6InterfaceNetmask optional.String
    ServiceProcessorIpv6InterfaceAddress optional.String
    ServiceProcessorIpv6InterfaceGateway optional.String
    ServiceProcessorLinkStatus optional.String
    ServiceProcessorDhcpEnabled optional.Bool
    Uptime optional.Int32
    ControllerOverTemperature optional.String
    ControllerFrusState optional.String
    ControllerFrusType optional.String
    ControllerFrusId optional.Int32
    ControllerFlashCacheState optional.String
    ControllerFlashCacheModel optional.String
    ControllerFlashCacheSerialNumber optional.String
    ControllerFlashCachePartNumber optional.String
    ControllerFlashCacheHardwareRevision optional.String
    ControllerFlashCacheSlot optional.String
    ControllerFlashCacheFirmwareVersion optional.String
    ControllerFlashCacheCapacity optional.Int32
    HaEnabled optional.Bool
    HaPartnersUuid optional.String
    HaPartnersName optional.String
    HaAutoGiveback optional.Bool
    Date optional.String
    Uuid optional.String
    SerialNumber optional.String
    ClusterInterfacesName optional.String
    ClusterInterfacesUuid optional.String
    ClusterInterfacesIpAddress optional.String
    ManagementInterfacesName optional.String
    ManagementInterfacesUuid optional.String
    ManagementInterfacesIpAddress optional.String
    Fields optional.Interface
    MaxRecords optional.Int32
    ReturnRecords optional.Bool
    ReturnTimeout optional.Int32
    OrderBy optional.Interface
}

/*
NodesGet Method for NodesGet
Retrieves the nodes in the cluster. ### Learn more * [&#x60;DOC /cluster/nodes&#x60;](#docs-cluster-cluster_nodes)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *NodesGetOpts - Optional Parameters:
 * @param "Membership" (optional.String) -  Filter by membership
 * @param "Name" (optional.String) -  Filter by name
 * @param "Model" (optional.String) -  Filter by model
 * @param "VersionMajor" (optional.Int32) -  Filter by version.major
 * @param "VersionMinor" (optional.Int32) -  Filter by version.minor
 * @param "VersionGeneration" (optional.Int32) -  Filter by version.generation
 * @param "VersionFull" (optional.String) -  Filter by version.full
 * @param "Location" (optional.String) -  Filter by location
 * @param "ServiceProcessorIpv4InterfaceNetmask" (optional.String) -  Filter by service_processor.ipv4_interface.netmask
 * @param "ServiceProcessorIpv4InterfaceAddress" (optional.String) -  Filter by service_processor.ipv4_interface.address
 * @param "ServiceProcessorIpv4InterfaceGateway" (optional.String) -  Filter by service_processor.ipv4_interface.gateway
 * @param "ServiceProcessorMacAddress" (optional.String) -  Filter by service_processor.mac_address
 * @param "ServiceProcessorState" (optional.String) -  Filter by service_processor.state
 * @param "ServiceProcessorFirmwareVersion" (optional.String) -  Filter by service_processor.firmware_version
 * @param "ServiceProcessorIpv6InterfaceNetmask" (optional.String) -  Filter by service_processor.ipv6_interface.netmask
 * @param "ServiceProcessorIpv6InterfaceAddress" (optional.String) -  Filter by service_processor.ipv6_interface.address
 * @param "ServiceProcessorIpv6InterfaceGateway" (optional.String) -  Filter by service_processor.ipv6_interface.gateway
 * @param "ServiceProcessorLinkStatus" (optional.String) -  Filter by service_processor.link_status
 * @param "ServiceProcessorDhcpEnabled" (optional.Bool) -  Filter by service_processor.dhcp_enabled
 * @param "Uptime" (optional.Int32) -  Filter by uptime
 * @param "ControllerOverTemperature" (optional.String) -  Filter by controller.over_temperature
 * @param "ControllerFrusState" (optional.String) -  Filter by controller.frus.state
 * @param "ControllerFrusType" (optional.String) -  Filter by controller.frus.type
 * @param "ControllerFrusId" (optional.Int32) -  Filter by controller.frus.id
 * @param "ControllerFlashCacheState" (optional.String) -  Filter by controller.flash_cache.state
 * @param "ControllerFlashCacheModel" (optional.String) -  Filter by controller.flash_cache.model
 * @param "ControllerFlashCacheSerialNumber" (optional.String) -  Filter by controller.flash_cache.serial_number
 * @param "ControllerFlashCachePartNumber" (optional.String) -  Filter by controller.flash_cache.part_number
 * @param "ControllerFlashCacheHardwareRevision" (optional.String) -  Filter by controller.flash_cache.hardware_revision
 * @param "ControllerFlashCacheSlot" (optional.String) -  Filter by controller.flash_cache.slot
 * @param "ControllerFlashCacheFirmwareVersion" (optional.String) -  Filter by controller.flash_cache.firmware_version
 * @param "ControllerFlashCacheCapacity" (optional.Int32) -  Filter by controller.flash_cache.capacity
 * @param "HaEnabled" (optional.Bool) -  Filter by ha.enabled
 * @param "HaPartnersUuid" (optional.String) -  Filter by ha.partners.uuid
 * @param "HaPartnersName" (optional.String) -  Filter by ha.partners.name
 * @param "HaAutoGiveback" (optional.Bool) -  Filter by ha.auto_giveback
 * @param "Date" (optional.String) -  Filter by date
 * @param "Uuid" (optional.String) -  Filter by uuid
 * @param "SerialNumber" (optional.String) -  Filter by serial_number
 * @param "ClusterInterfacesName" (optional.String) -  Filter by cluster_interfaces.name
 * @param "ClusterInterfacesUuid" (optional.String) -  Filter by cluster_interfaces.uuid
 * @param "ClusterInterfacesIpAddress" (optional.String) -  Filter by cluster_interfaces.ip.address
 * @param "ManagementInterfacesName" (optional.String) -  Filter by management_interfaces.name
 * @param "ManagementInterfacesUuid" (optional.String) -  Filter by management_interfaces.uuid
 * @param "ManagementInterfacesIpAddress" (optional.String) -  Filter by management_interfaces.ip.address
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return NodeResponse
*/
func (a *ClusterApiService) NodesGet(ctx _context.Context, localVarOptionals *NodesGetOpts) (NodeResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NodeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/nodes"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Membership.IsSet() {
		localVarQueryParams.Add("membership", parameterToString(localVarOptionals.Membership.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Model.IsSet() {
		localVarQueryParams.Add("model", parameterToString(localVarOptionals.Model.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VersionMajor.IsSet() {
		localVarQueryParams.Add("version.major", parameterToString(localVarOptionals.VersionMajor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VersionMinor.IsSet() {
		localVarQueryParams.Add("version.minor", parameterToString(localVarOptionals.VersionMinor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VersionGeneration.IsSet() {
		localVarQueryParams.Add("version.generation", parameterToString(localVarOptionals.VersionGeneration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VersionFull.IsSet() {
		localVarQueryParams.Add("version.full", parameterToString(localVarOptionals.VersionFull.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarQueryParams.Add("location", parameterToString(localVarOptionals.Location.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceProcessorIpv4InterfaceNetmask.IsSet() {
		localVarQueryParams.Add("service_processor.ipv4_interface.netmask", parameterToString(localVarOptionals.ServiceProcessorIpv4InterfaceNetmask.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceProcessorIpv4InterfaceAddress.IsSet() {
		localVarQueryParams.Add("service_processor.ipv4_interface.address", parameterToString(localVarOptionals.ServiceProcessorIpv4InterfaceAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceProcessorIpv4InterfaceGateway.IsSet() {
		localVarQueryParams.Add("service_processor.ipv4_interface.gateway", parameterToString(localVarOptionals.ServiceProcessorIpv4InterfaceGateway.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceProcessorMacAddress.IsSet() {
		localVarQueryParams.Add("service_processor.mac_address", parameterToString(localVarOptionals.ServiceProcessorMacAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceProcessorState.IsSet() {
		localVarQueryParams.Add("service_processor.state", parameterToString(localVarOptionals.ServiceProcessorState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceProcessorFirmwareVersion.IsSet() {
		localVarQueryParams.Add("service_processor.firmware_version", parameterToString(localVarOptionals.ServiceProcessorFirmwareVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceProcessorIpv6InterfaceNetmask.IsSet() {
		localVarQueryParams.Add("service_processor.ipv6_interface.netmask", parameterToString(localVarOptionals.ServiceProcessorIpv6InterfaceNetmask.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceProcessorIpv6InterfaceAddress.IsSet() {
		localVarQueryParams.Add("service_processor.ipv6_interface.address", parameterToString(localVarOptionals.ServiceProcessorIpv6InterfaceAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceProcessorIpv6InterfaceGateway.IsSet() {
		localVarQueryParams.Add("service_processor.ipv6_interface.gateway", parameterToString(localVarOptionals.ServiceProcessorIpv6InterfaceGateway.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceProcessorLinkStatus.IsSet() {
		localVarQueryParams.Add("service_processor.link_status", parameterToString(localVarOptionals.ServiceProcessorLinkStatus.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceProcessorDhcpEnabled.IsSet() {
		localVarQueryParams.Add("service_processor.dhcp_enabled", parameterToString(localVarOptionals.ServiceProcessorDhcpEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uptime.IsSet() {
		localVarQueryParams.Add("uptime", parameterToString(localVarOptionals.Uptime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ControllerOverTemperature.IsSet() {
		localVarQueryParams.Add("controller.over_temperature", parameterToString(localVarOptionals.ControllerOverTemperature.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ControllerFrusState.IsSet() {
		localVarQueryParams.Add("controller.frus.state", parameterToString(localVarOptionals.ControllerFrusState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ControllerFrusType.IsSet() {
		localVarQueryParams.Add("controller.frus.type", parameterToString(localVarOptionals.ControllerFrusType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ControllerFrusId.IsSet() {
		localVarQueryParams.Add("controller.frus.id", parameterToString(localVarOptionals.ControllerFrusId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ControllerFlashCacheState.IsSet() {
		localVarQueryParams.Add("controller.flash_cache.state", parameterToString(localVarOptionals.ControllerFlashCacheState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ControllerFlashCacheModel.IsSet() {
		localVarQueryParams.Add("controller.flash_cache.model", parameterToString(localVarOptionals.ControllerFlashCacheModel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ControllerFlashCacheSerialNumber.IsSet() {
		localVarQueryParams.Add("controller.flash_cache.serial_number", parameterToString(localVarOptionals.ControllerFlashCacheSerialNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ControllerFlashCachePartNumber.IsSet() {
		localVarQueryParams.Add("controller.flash_cache.part_number", parameterToString(localVarOptionals.ControllerFlashCachePartNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ControllerFlashCacheHardwareRevision.IsSet() {
		localVarQueryParams.Add("controller.flash_cache.hardware_revision", parameterToString(localVarOptionals.ControllerFlashCacheHardwareRevision.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ControllerFlashCacheSlot.IsSet() {
		localVarQueryParams.Add("controller.flash_cache.slot", parameterToString(localVarOptionals.ControllerFlashCacheSlot.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ControllerFlashCacheFirmwareVersion.IsSet() {
		localVarQueryParams.Add("controller.flash_cache.firmware_version", parameterToString(localVarOptionals.ControllerFlashCacheFirmwareVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ControllerFlashCacheCapacity.IsSet() {
		localVarQueryParams.Add("controller.flash_cache.capacity", parameterToString(localVarOptionals.ControllerFlashCacheCapacity.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HaEnabled.IsSet() {
		localVarQueryParams.Add("ha.enabled", parameterToString(localVarOptionals.HaEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HaPartnersUuid.IsSet() {
		localVarQueryParams.Add("ha.partners.uuid", parameterToString(localVarOptionals.HaPartnersUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HaPartnersName.IsSet() {
		localVarQueryParams.Add("ha.partners.name", parameterToString(localVarOptionals.HaPartnersName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HaAutoGiveback.IsSet() {
		localVarQueryParams.Add("ha.auto_giveback", parameterToString(localVarOptionals.HaAutoGiveback.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Date.IsSet() {
		localVarQueryParams.Add("date", parameterToString(localVarOptionals.Date.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SerialNumber.IsSet() {
		localVarQueryParams.Add("serial_number", parameterToString(localVarOptionals.SerialNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClusterInterfacesName.IsSet() {
		localVarQueryParams.Add("cluster_interfaces.name", parameterToString(localVarOptionals.ClusterInterfacesName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClusterInterfacesUuid.IsSet() {
		localVarQueryParams.Add("cluster_interfaces.uuid", parameterToString(localVarOptionals.ClusterInterfacesUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClusterInterfacesIpAddress.IsSet() {
		localVarQueryParams.Add("cluster_interfaces.ip.address", parameterToString(localVarOptionals.ClusterInterfacesIpAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ManagementInterfacesName.IsSet() {
		localVarQueryParams.Add("management_interfaces.name", parameterToString(localVarOptionals.ManagementInterfacesName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ManagementInterfacesUuid.IsSet() {
		localVarQueryParams.Add("management_interfaces.uuid", parameterToString(localVarOptionals.ManagementInterfacesUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ManagementInterfacesIpAddress.IsSet() {
		localVarQueryParams.Add("management_interfaces.ip.address", parameterToString(localVarOptionals.ManagementInterfacesIpAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v NodeResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// PeersCollectionGetOpts Optional parameters for the method 'PeersCollectionGet'
type PeersCollectionGetOpts struct {
    Fields optional.Interface
    MaxRecords optional.Int32
    ReturnRecords optional.Bool
    ReturnTimeout optional.Int32
    OrderBy optional.Interface
}

/*
PeersCollectionGet Method for PeersCollectionGet
Retrieve the collection of cluster peers. ### Learn more * [&#x60;DOC /cluster/peers&#x60;](#docs-cluster-cluster_peers)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *PeersCollectionGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return ClusterPeerResponse
*/
func (a *ClusterApiService) PeersCollectionGet(ctx _context.Context, localVarOptionals *PeersCollectionGetOpts) (ClusterPeerResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ClusterPeerResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/peers"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ClusterPeerResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ScheduleCollectionGetOpts Optional parameters for the method 'ScheduleCollectionGet'
type ScheduleCollectionGetOpts struct {
    Uuid optional.String
    CronDays optional.Int32
    CronHours optional.Int32
    CronMonths optional.Int32
    CronMinutes optional.Int32
    CronWeekdays optional.Int32
    ClusterName optional.String
    ClusterUuid optional.String
    Interval optional.String
    Type_ optional.String
    Name optional.String
    Fields optional.Interface
    MaxRecords optional.Int32
    ReturnRecords optional.Bool
    ReturnTimeout optional.Int32
    OrderBy optional.Interface
}

/*
ScheduleCollectionGet Method for ScheduleCollectionGet
Retrieves a schedule. ### Learn more * [&#x60;DOC /cluster/schedules&#x60;](#docs-cluster-cluster_schedules)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ScheduleCollectionGetOpts - Optional Parameters:
 * @param "Uuid" (optional.String) -  Filter by uuid
 * @param "CronDays" (optional.Int32) -  Filter by cron.days
 * @param "CronHours" (optional.Int32) -  Filter by cron.hours
 * @param "CronMonths" (optional.Int32) -  Filter by cron.months
 * @param "CronMinutes" (optional.Int32) -  Filter by cron.minutes
 * @param "CronWeekdays" (optional.Int32) -  Filter by cron.weekdays
 * @param "ClusterName" (optional.String) -  Filter by cluster.name
 * @param "ClusterUuid" (optional.String) -  Filter by cluster.uuid
 * @param "Interval" (optional.String) -  Filter by interval
 * @param "Type_" (optional.String) -  Filter by type
 * @param "Name" (optional.String) -  Filter by name
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return ScheduleResponse
*/
func (a *ClusterApiService) ScheduleCollectionGet(ctx _context.Context, localVarOptionals *ScheduleCollectionGetOpts) (ScheduleResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ScheduleResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/schedules"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CronDays.IsSet() {
		localVarQueryParams.Add("cron.days", parameterToString(localVarOptionals.CronDays.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CronHours.IsSet() {
		localVarQueryParams.Add("cron.hours", parameterToString(localVarOptionals.CronHours.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CronMonths.IsSet() {
		localVarQueryParams.Add("cron.months", parameterToString(localVarOptionals.CronMonths.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CronMinutes.IsSet() {
		localVarQueryParams.Add("cron.minutes", parameterToString(localVarOptionals.CronMinutes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CronWeekdays.IsSet() {
		localVarQueryParams.Add("cron.weekdays", parameterToString(localVarOptionals.CronWeekdays.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClusterName.IsSet() {
		localVarQueryParams.Add("cluster.name", parameterToString(localVarOptionals.ClusterName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClusterUuid.IsSet() {
		localVarQueryParams.Add("cluster.uuid", parameterToString(localVarOptionals.ClusterUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Interval.IsSet() {
		localVarQueryParams.Add("interval", parameterToString(localVarOptionals.Interval.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ScheduleResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ScheduleCreateOpts Optional parameters for the method 'ScheduleCreate'
type ScheduleCreateOpts struct {
    Info optional.Interface
}

/*
ScheduleCreate Method for ScheduleCreate
Create a schedule. ### Required Fields * name - Name of the job schedule It is required to provide a minutes field for a cron schedule. An interval field is required for an interval schedule. You must not provide both a cron field and an interval field.  ### Learn more * [&#x60;DOC /cluster/schedules&#x60;](#docs-cluster-cluster_schedules)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ScheduleCreateOpts - Optional Parameters:
 * @param "Info" (optional.Interface of Schedule) -  Info specification
*/
func (a *ClusterApiService) ScheduleCreate(ctx _context.Context, localVarOptionals *ScheduleCreateOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/schedules"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(Schedule)
		if !localVarOptionalInfook {
			return nil, reportError("info should be Schedule")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
ScheduleDelete Method for ScheduleDelete
Deletes a schedule. ### Learn more * [&#x60;DOC /cluster/schedules&#x60;](#docs-cluster-cluster_schedules)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Schedule UUID
*/
func (a *ClusterApiService) ScheduleDelete(ctx _context.Context, uuid string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/schedules/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// ScheduleGetOpts Optional parameters for the method 'ScheduleGet'
type ScheduleGetOpts struct {
    Fields optional.Interface
}

/*
ScheduleGet Method for ScheduleGet
Retrieves a schedule. ### Learn more * [&#x60;DOC /cluster/schedules&#x60;](#docs-cluster-cluster_schedules)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Schedule UUID
 * @param optional nil or *ScheduleGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return Schedule
*/
func (a *ClusterApiService) ScheduleGet(ctx _context.Context, uuid string, localVarOptionals *ScheduleGetOpts) (Schedule, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Schedule
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/schedules/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Schedule
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ScheduleModifyOpts Optional parameters for the method 'ScheduleModify'
type ScheduleModifyOpts struct {
    Info optional.Interface
}

/*
ScheduleModify Method for ScheduleModify
Updates a schedule. Note that you cannot modify a cron field of an interval schedule, or the interval field of a cron schedule. ### Learn more * [&#x60;DOC /cluster/schedules&#x60;](#docs-cluster-cluster_schedules)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Schedule UUID
 * @param optional nil or *ScheduleModifyOpts - Optional Parameters:
 * @param "Info" (optional.Interface of Schedule) -  Info specification
*/
func (a *ClusterApiService) ScheduleModify(ctx _context.Context, uuid string, localVarOptionals *ScheduleModifyOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/schedules/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(Schedule)
		if !localVarOptionalInfook {
			return nil, reportError("info should be Schedule")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// SoftwareGetOpts Optional parameters for the method 'SoftwareGet'
type SoftwareGetOpts struct {
    Fields optional.Interface
    ReturnTimeout optional.Int32
}

/*
SoftwareGet Method for SoftwareGet
Retrieves the software profile of a cluster. ### Related ONTAP commands * &#x60;cluster image show&#x60; * &#x60;cluster image show-update-progress&#x60; ### Learn more * [&#x60;DOC /cluster/software&#x60;](#docs-cluster-cluster_software) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *SoftwareGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
@return SoftwareReference
*/
func (a *ClusterApiService) SoftwareGet(ctx _context.Context, localVarOptionals *SoftwareGetOpts) (SoftwareReference, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwareReference
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/software"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v SoftwareReference
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// SoftwareHistoryCollectionGetOpts Optional parameters for the method 'SoftwareHistoryCollectionGet'
type SoftwareHistoryCollectionGetOpts struct {
    Fields optional.Interface
    MaxRecords optional.Int32
    ReturnRecords optional.Bool
    ReturnTimeout optional.Int32
    OrderBy optional.Interface
}

/*
SoftwareHistoryCollectionGet Method for SoftwareHistoryCollectionGet
Retrieves the history details for software installation requests. ### Related ONTAP commands * &#x60;cluster image show-update-history&#x60; ### Learn more * [&#x60;DOC /cluster/software&#x60;](#docs-cluster-cluster_software) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *SoftwareHistoryCollectionGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return SoftwareHistoryResponse
*/
func (a *ClusterApiService) SoftwareHistoryCollectionGet(ctx _context.Context, localVarOptionals *SoftwareHistoryCollectionGetOpts) (SoftwareHistoryResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwareHistoryResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/software/history"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v SoftwareHistoryResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// SoftwareModifyOpts Optional parameters for the method 'SoftwareModify'
type SoftwareModifyOpts struct {
    ValidateOnly optional.Bool
    SkipWarnings optional.Bool
    Action optional.String
    Info optional.Interface
}

/*
SoftwareModify Method for SoftwareModify
Upgrades the cluster software version. Setting &#x60;version&#x60;  triggers the installation of the package to start. To validate the package for installation but not perform the installation, use the &#x60;validate_only&#x60; field on request. Important note:   * Setting &#39;version&#39; triggers the package installation.   * To validate the package for installation but not perform the installation, use the validate_only field on the request. ### Required properties * &#x60;version&#x60; - Software version to be installed on the cluster ### Recommended optional parameters * &#x60;validate_only&#x60; - Required to validate a software package before an upgrade * &#x60;skip_warnings&#x60; - Used to skip validation warnings when starting a software upgrade * &#x60;action&#x60; - Used to pause, resume, or cancel an ongoing software upgrade ### Related ONTAP commands * &#x60;cluster image validate&#x60; * &#x60;cluster image update&#x60; * &#x60;cluster image pause-update&#x60; * &#x60;cluster image resume-update&#x60; * &#x60;cluster image cancel-update&#x60; ### Learn more * [&#x60;DOC /cluster/software&#x60;](#docs-cluster-cluster_software) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *SoftwareModifyOpts - Optional Parameters:
 * @param "ValidateOnly" (optional.Bool) -  Validate the operation and its parameters, without actually performing the operation.
 * @param "SkipWarnings" (optional.Bool) -  Ignore warnings and proceed with the install.
 * @param "Action" (optional.String) -  Requests an upgrade to pause, resume, or cancel. Note that not all upgrades support these actions. An upgrade can only be resumed if it is in the paused state. When a request to cancel an upgrade is successful, the upgrade state changes to either success or failure. 
 * @param "Info" (optional.Interface of SoftwareReference) - 
@return JobLinkResponse
*/
func (a *ClusterApiService) SoftwareModify(ctx _context.Context, localVarOptionals *SoftwareModifyOpts) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/software"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.ValidateOnly.IsSet() {
		localVarQueryParams.Add("validate_only", parameterToString(localVarOptionals.ValidateOnly.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SkipWarnings.IsSet() {
		localVarQueryParams.Add("skip_warnings", parameterToString(localVarOptionals.SkipWarnings.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Action.IsSet() {
		localVarQueryParams.Add("action", parameterToString(localVarOptionals.Action.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(SoftwareReference)
		if !localVarOptionalInfook {
			return localVarReturnValue, nil, reportError("info should be SoftwareReference")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// SoftwarePackageCreateOpts Optional parameters for the method 'SoftwarePackageCreate'
type SoftwarePackageCreateOpts struct {
    ReturnTimeout optional.Int32
    Info optional.Interface
}

/*
SoftwarePackageCreate Method for SoftwarePackageCreate
Downloads a software package from the server. ### Required properties * &#x60;url&#x60; - URL location of the software package ### Recommended optional parameters * &#x60;username&#x60; - Username of HTTPS/FTP server * &#x60;password&#x60; - Password of HTTPS/FTP server ### Related ONTAP commands * &#x60;cluster image package get&#x60; ### Learn more * [&#x60;DOC /cluster/software&#x60;](#docs-cluster-cluster_software) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *SoftwarePackageCreateOpts - Optional Parameters:
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning. When doing a POST, PATCH, or DELETE operation on a single record, the default is 0 seconds.  This means that if an asynchronous operation is started, the server immediately returns HTTP code 202 (Accepted) along with a link to the job.  If a non-zero value is specified for POST, PATCH, or DELETE operations, ONTAP waits that length of time to see if the job completes so it can return something other than 202.
 * @param "Info" (optional.Interface of SoftwarePackageDownload) -  Info specification
@return JobLinkResponse
*/
func (a *ClusterApiService) SoftwarePackageCreate(ctx _context.Context, localVarOptionals *SoftwarePackageCreateOpts) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/software/download"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(SoftwarePackageDownload)
		if !localVarOptionalInfook {
			return localVarReturnValue, nil, reportError("info should be SoftwarePackageDownload")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
SoftwarePackageDelete Method for SoftwarePackageDelete
Deletes a software package from the cluster. The delete operation fails if the package is currently installed. ### Related ONTAP commands * &#x60;cluster image package delete&#x60; ### Learn more * [&#x60;DOC /cluster/software&#x60;](#docs-cluster-cluster_software) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param version
*/
func (a *ClusterApiService) SoftwarePackageDelete(ctx _context.Context, version string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/software/packages/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", _neturl.QueryEscape(parameterToString(version, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// SoftwarePackageGetOpts Optional parameters for the method 'SoftwarePackageGet'
type SoftwarePackageGetOpts struct {
    Fields optional.Interface
}

/*
SoftwarePackageGet Method for SoftwarePackageGet
Retrieves the software package information. ### Related ONTAP commands * &#x60;cluster image package show-repository&#x60; ### Learn more * [&#x60;DOC /cluster/software&#x60;](#docs-cluster-cluster_software) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param version
 * @param optional nil or *SoftwarePackageGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return SoftwarePackage
*/
func (a *ClusterApiService) SoftwarePackageGet(ctx _context.Context, version string, localVarOptionals *SoftwarePackageGetOpts) (SoftwarePackage, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarePackage
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/software/packages/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", _neturl.QueryEscape(parameterToString(version, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v SoftwarePackage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// SoftwarePackagesCollectionGetOpts Optional parameters for the method 'SoftwarePackagesCollectionGet'
type SoftwarePackagesCollectionGetOpts struct {
    Fields optional.Interface
    MaxRecords optional.Int32
    ReturnRecords optional.Bool
    ReturnTimeout optional.Int32
    OrderBy optional.Interface
}

/*
SoftwarePackagesCollectionGet Method for SoftwarePackagesCollectionGet
Retrieves the software packages for a cluster. ### Related ONTAP commands * &#x60;cluster image package show-repository&#x60; ### Learn more * [&#x60;DOC /cluster/software&#x60;](#docs-cluster-cluster_software) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *SoftwarePackagesCollectionGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return SoftwarePackageResponse
*/
func (a *ClusterApiService) SoftwarePackagesCollectionGet(ctx _context.Context, localVarOptionals *SoftwarePackagesCollectionGetOpts) (SoftwarePackageResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SoftwarePackageResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cluster/software/packages"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v SoftwarePackageResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
