/*
 * ONTAP REST API
 *
 * ONTAP 9.6 adds support for an expansive RESTful API. The documentation below provides information about the types of API calls available to you, as well as details about using each API endpoint. You can learn more about the ONTAP REST API and ONTAP in the ONTAP 9 Documentation Center:  http://docs.netapp.com/ontap-9/topic/com.netapp.doc.dot-rest-api/home.html. NetApp welcomes your comments and suggestions about the ONTAP REST API and the documentation for its use.</br> **Using the ONTAP 9.6 REST API online documentation** Each API method includes usage examples, as well as a model that displays all the required and optional properties supported by the method. Click the _Model_ link, available with each API method, to see all the required and optional properties supported by each method. 
 *
 * API version: v1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package ontap

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// SvmApiService SvmApi service
type SvmApiService service

// SvmCollectionGetOpts Optional parameters for the method 'SvmCollectionGet'
type SvmCollectionGetOpts struct {
    NisEnabled optional.Bool
    NisServers optional.String
    NisDomain optional.String
    NvmeEnabled optional.Bool
    Language optional.String
    NfsEnabled optional.Bool
    Comment optional.String
    AggregatesName optional.String
    AggregatesUuid optional.String
    Subtype optional.String
    DnsServers optional.String
    DnsDomains optional.String
    FcpEnabled optional.Bool
    IscsiEnabled optional.Bool
    Name optional.String
    IpspaceUuid optional.String
    IpspaceName optional.String
    LdapBaseDn optional.String
    LdapServers optional.String
    LdapEnabled optional.Bool
    LdapBindDn optional.String
    LdapAdDomain optional.String
    Uuid optional.String
    CifsName optional.String
    CifsAdDomainFqdn optional.String
    CifsAdDomainOrganizationalUnit optional.String
    CifsEnabled optional.Bool
    NsswitchNetgroup optional.String
    NsswitchGroup optional.String
    NsswitchHosts optional.String
    NsswitchNamemap optional.String
    NsswitchPasswd optional.String
    IpInterfacesIpAddress optional.String
    IpInterfacesName optional.String
    IpInterfacesUuid optional.String
    SnapshotPolicyUuid optional.String
    SnapshotPolicyName optional.String
    State optional.String
    Fields optional.Interface
    MaxRecords optional.Int32
    ReturnRecords optional.Bool
    ReturnTimeout optional.Int32
    OrderBy optional.Interface
}

/*
SvmCollectionGet Method for SvmCollectionGet
Retrieves a list of SVMs and individual SVM properties. This includes protocol configurations such as CIFS and NFS, export policies, name service configurations, and network services. ### Important notes * The SVM object includes a large set of fields and can be expensive to retrieve. Use this API to list the collection of SVMs, and to retrieve only the full details of individual SVMs as needed. * It is not recommended to create or delete more than five SVMs in parallel. * REST APIs only expose a data SVM as an SVM. ### Related ONTAP commands * &#x60;vserver show&#x60; ### Examples 1. Retrieves a list of SVMs in the cluster sorted by name     &lt;br/&gt;     &#x60;&#x60;&#x60;     GET \&quot;/api/svm/svms?order_by&#x3D;name\&quot;     &#x60;&#x60;&#x60;     &lt;br/&gt; 2. Retrieves a list of SVMs in the cluster that have the NFS protocol enabled     &lt;br/&gt;     &#x60;&#x60;&#x60;     GET \&quot;/api/svm/svms?nfs.enabled&#x3D;true\&quot;     &#x60;&#x60;&#x60;     &lt;br/&gt; 3. Retrieves a list of SVMs in the cluster that have the CIFS protocol enabled     &lt;br/&gt;     &#x60;&#x60;&#x60;     GET \&quot;/api/svm/svms?cifs.enabled&#x3D;true\&quot;     &#x60;&#x60;&#x60;     &lt;br/&gt; ### Learn more * [&#x60;DOC /svm/svms&#x60;](#docs-svm-svm_svms) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *SvmCollectionGetOpts - Optional Parameters:
 * @param "NisEnabled" (optional.Bool) -  Filter by nis.enabled
 * @param "NisServers" (optional.String) -  Filter by nis.servers
 * @param "NisDomain" (optional.String) -  Filter by nis.domain
 * @param "NvmeEnabled" (optional.Bool) -  Filter by nvme.enabled
 * @param "Language" (optional.String) -  Filter by language
 * @param "NfsEnabled" (optional.Bool) -  Filter by nfs.enabled
 * @param "Comment" (optional.String) -  Filter by comment
 * @param "AggregatesName" (optional.String) -  Filter by aggregates.name
 * @param "AggregatesUuid" (optional.String) -  Filter by aggregates.uuid
 * @param "Subtype" (optional.String) -  Filter by subtype
 * @param "DnsServers" (optional.String) -  Filter by dns.servers
 * @param "DnsDomains" (optional.String) -  Filter by dns.domains
 * @param "FcpEnabled" (optional.Bool) -  Filter by fcp.enabled
 * @param "IscsiEnabled" (optional.Bool) -  Filter by iscsi.enabled
 * @param "Name" (optional.String) -  Filter by name
 * @param "IpspaceUuid" (optional.String) -  Filter by ipspace.uuid
 * @param "IpspaceName" (optional.String) -  Filter by ipspace.name
 * @param "LdapBaseDn" (optional.String) -  Filter by ldap.base_dn
 * @param "LdapServers" (optional.String) -  Filter by ldap.servers
 * @param "LdapEnabled" (optional.Bool) -  Filter by ldap.enabled
 * @param "LdapBindDn" (optional.String) -  Filter by ldap.bind_dn
 * @param "LdapAdDomain" (optional.String) -  Filter by ldap.ad_domain
 * @param "Uuid" (optional.String) -  Filter by uuid
 * @param "CifsName" (optional.String) -  Filter by cifs.name
 * @param "CifsAdDomainFqdn" (optional.String) -  Filter by cifs.ad_domain.fqdn
 * @param "CifsAdDomainOrganizationalUnit" (optional.String) -  Filter by cifs.ad_domain.organizational_unit
 * @param "CifsEnabled" (optional.Bool) -  Filter by cifs.enabled
 * @param "NsswitchNetgroup" (optional.String) -  Filter by nsswitch.netgroup
 * @param "NsswitchGroup" (optional.String) -  Filter by nsswitch.group
 * @param "NsswitchHosts" (optional.String) -  Filter by nsswitch.hosts
 * @param "NsswitchNamemap" (optional.String) -  Filter by nsswitch.namemap
 * @param "NsswitchPasswd" (optional.String) -  Filter by nsswitch.passwd
 * @param "IpInterfacesIpAddress" (optional.String) -  Filter by ip_interfaces.ip.address
 * @param "IpInterfacesName" (optional.String) -  Filter by ip_interfaces.name
 * @param "IpInterfacesUuid" (optional.String) -  Filter by ip_interfaces.uuid
 * @param "SnapshotPolicyUuid" (optional.String) -  Filter by snapshot_policy.uuid
 * @param "SnapshotPolicyName" (optional.String) -  Filter by snapshot_policy.name
 * @param "State" (optional.String) -  Filter by state
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return SvmResponse
*/
func (a *SvmApiService) SvmCollectionGet(ctx _context.Context, localVarOptionals *SvmCollectionGetOpts) (SvmResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SvmResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/svm/svms"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.NisEnabled.IsSet() {
		localVarQueryParams.Add("nis.enabled", parameterToString(localVarOptionals.NisEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NisServers.IsSet() {
		localVarQueryParams.Add("nis.servers", parameterToString(localVarOptionals.NisServers.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NisDomain.IsSet() {
		localVarQueryParams.Add("nis.domain", parameterToString(localVarOptionals.NisDomain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NvmeEnabled.IsSet() {
		localVarQueryParams.Add("nvme.enabled", parameterToString(localVarOptionals.NvmeEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Language.IsSet() {
		localVarQueryParams.Add("language", parameterToString(localVarOptionals.Language.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NfsEnabled.IsSet() {
		localVarQueryParams.Add("nfs.enabled", parameterToString(localVarOptionals.NfsEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Comment.IsSet() {
		localVarQueryParams.Add("comment", parameterToString(localVarOptionals.Comment.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AggregatesName.IsSet() {
		localVarQueryParams.Add("aggregates.name", parameterToString(localVarOptionals.AggregatesName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AggregatesUuid.IsSet() {
		localVarQueryParams.Add("aggregates.uuid", parameterToString(localVarOptionals.AggregatesUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Subtype.IsSet() {
		localVarQueryParams.Add("subtype", parameterToString(localVarOptionals.Subtype.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DnsServers.IsSet() {
		localVarQueryParams.Add("dns.servers", parameterToString(localVarOptionals.DnsServers.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DnsDomains.IsSet() {
		localVarQueryParams.Add("dns.domains", parameterToString(localVarOptionals.DnsDomains.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FcpEnabled.IsSet() {
		localVarQueryParams.Add("fcp.enabled", parameterToString(localVarOptionals.FcpEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IscsiEnabled.IsSet() {
		localVarQueryParams.Add("iscsi.enabled", parameterToString(localVarOptionals.IscsiEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IpspaceUuid.IsSet() {
		localVarQueryParams.Add("ipspace.uuid", parameterToString(localVarOptionals.IpspaceUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IpspaceName.IsSet() {
		localVarQueryParams.Add("ipspace.name", parameterToString(localVarOptionals.IpspaceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LdapBaseDn.IsSet() {
		localVarQueryParams.Add("ldap.base_dn", parameterToString(localVarOptionals.LdapBaseDn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LdapServers.IsSet() {
		localVarQueryParams.Add("ldap.servers", parameterToString(localVarOptionals.LdapServers.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LdapEnabled.IsSet() {
		localVarQueryParams.Add("ldap.enabled", parameterToString(localVarOptionals.LdapEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LdapBindDn.IsSet() {
		localVarQueryParams.Add("ldap.bind_dn", parameterToString(localVarOptionals.LdapBindDn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LdapAdDomain.IsSet() {
		localVarQueryParams.Add("ldap.ad_domain", parameterToString(localVarOptionals.LdapAdDomain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CifsName.IsSet() {
		localVarQueryParams.Add("cifs.name", parameterToString(localVarOptionals.CifsName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CifsAdDomainFqdn.IsSet() {
		localVarQueryParams.Add("cifs.ad_domain.fqdn", parameterToString(localVarOptionals.CifsAdDomainFqdn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CifsAdDomainOrganizationalUnit.IsSet() {
		localVarQueryParams.Add("cifs.ad_domain.organizational_unit", parameterToString(localVarOptionals.CifsAdDomainOrganizationalUnit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CifsEnabled.IsSet() {
		localVarQueryParams.Add("cifs.enabled", parameterToString(localVarOptionals.CifsEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NsswitchNetgroup.IsSet() {
		localVarQueryParams.Add("nsswitch.netgroup", parameterToString(localVarOptionals.NsswitchNetgroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NsswitchGroup.IsSet() {
		localVarQueryParams.Add("nsswitch.group", parameterToString(localVarOptionals.NsswitchGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NsswitchHosts.IsSet() {
		localVarQueryParams.Add("nsswitch.hosts", parameterToString(localVarOptionals.NsswitchHosts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NsswitchNamemap.IsSet() {
		localVarQueryParams.Add("nsswitch.namemap", parameterToString(localVarOptionals.NsswitchNamemap.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NsswitchPasswd.IsSet() {
		localVarQueryParams.Add("nsswitch.passwd", parameterToString(localVarOptionals.NsswitchPasswd.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IpInterfacesIpAddress.IsSet() {
		localVarQueryParams.Add("ip_interfaces.ip.address", parameterToString(localVarOptionals.IpInterfacesIpAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IpInterfacesName.IsSet() {
		localVarQueryParams.Add("ip_interfaces.name", parameterToString(localVarOptionals.IpInterfacesName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IpInterfacesUuid.IsSet() {
		localVarQueryParams.Add("ip_interfaces.uuid", parameterToString(localVarOptionals.IpInterfacesUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnapshotPolicyUuid.IsSet() {
		localVarQueryParams.Add("snapshot_policy.uuid", parameterToString(localVarOptionals.SnapshotPolicyUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnapshotPolicyName.IsSet() {
		localVarQueryParams.Add("snapshot_policy.name", parameterToString(localVarOptionals.SnapshotPolicyName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v SvmResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// SvmCreateOpts Optional parameters for the method 'SvmCreate'
type SvmCreateOpts struct {
    ReturnTimeout optional.Int32
    Info optional.Interface
}

/*
SvmCreate Method for SvmCreate
Creates and provisions an SVM. If no IPspace is provided, then the SVM is created on the &#x60;Default&#x60; IPspace. The number of parallel SVMs that can be created should not be greater than 5. When the sixth SVM POST request is issued, the error message \&quot;Maximum allowed SVM jobs exceeded. Wait for the existing SVM jobs to complete and try again.\&quot; will be returned. ### Required properties * &#x60;name&#x60; - Name of the SVM to be created. ### Recommended optional properties * &#x60;ipspace.name&#x60; or &#x60;ipspace.uuid&#x60; - IPspace of the SVM   * &#x60;ip_interfaces&#x60; - If provided, the following fields are required:   * &#x60;ip_interfaces.name&#x60; - Name of the interface   * &#x60;ip_interfaces.ip.address&#x60; - IP address   * &#x60;ip_interfaces.ip.netmask&#x60; - Netmask length or IP address   * &#x60;ip_interfaces.location.broadcast_domain.uuid&#x60; or &#x60;ip_interfaces.location.broadcast_domain.name&#x60; - Broadcast domain name or UUID belonging to the same IPspace of the SVM. * &#x60;routes&#x60; - If provided, the following field is required:   * &#x60;routes.gateway&#x60; - Gateway IP address * &#x60;cifs&#x60; - If provided, interfaces, routes and DNS must be provided. The following fields are also required:   * &#x60;cifs.name&#x60; - Name of the CIFS server to be created for the SVM.   * &#x60;cifs.ad_domain.fqdn&#x60; - Fully qualified domain name   * &#x60;cifs.ad_domain.user&#x60; - Administrator username   * &#x60;cifs.ad_domain.password&#x60; - User password * &#x60;ldap&#x60; - If provided, the following fields are required:   * &#x60;ldap.servers&#x60; or &#x60;ldap.ad_domain&#x60; - LDAP server list or Active directory domain   * &#x60;ldap.bind_dn&#x60; - Bind DN   * &#x60;ldap.base_dn&#x60; - Base DN * &#x60;nis&#x60; - If provided, the following fields are required:   * &#x60;nis.servers&#x60; - NIS servers   * &#x60;nis.domain&#x60; - NIS domain * &#x60;dns&#x60; - If provided, the following fields are required:   * &#x60;dns.servers&#x60; - Name servers   * &#x60;dns.domains&#x60; - Domains ### Default property values If not specified in POST, the following default property values are assigned: * &#x60;language&#x60; - _C.UTF-8_ * &#x60;ipspace.name&#x60; - _Default_ * &#x60;snapshot_policy.name&#x60; - _Default_ * &#x60;subtype&#x60; - _Default_ ( _sync-source_ if MetroCluster configuration ) ### Related ONTAP commands * &#x60;vserver create&#x60; * &#x60;vserver add-aggregates&#x60; * &#x60;network interface create&#x60; * &#x60;network route create&#x60; * &#x60;vserver services name-service dns create&#x60; * &#x60;vserver nfs create&#x60; * &#x60;vserver services name-service ldap client create&#x60; * &#x60;vserver cifs create&#x60; * &#x60;vserver services name-service nis-domain create&#x60; * &#x60;vserver iscsi create&#x60; * &#x60;vserver nvme create&#x60; * &#x60;vserver fcp create&#x60; * &#x60;vserver services name-service ns-switch create&#x60; ### Examples 1. Creates an SVM with default \&quot;snapshot_policy\&quot;     &lt;br/&gt;     &#x60;&#x60;&#x60;     POST \&quot;/api/svm/svms\&quot; &#39;{\&quot;name\&quot;:\&quot;testVs\&quot;, \&quot;snapshot_policy\&quot;:{\&quot;name\&quot;:\&quot;default\&quot;}}&#39;     &#x60;&#x60;&#x60;     &lt;br/&gt; 2. Creates an SVM and configures NFS, ISCSI and FCP     &lt;br/&gt;     &#x60;&#x60;&#x60;     POST \&quot;/api/svm/svms\&quot; &#39;{\&quot;name\&quot;:\&quot;testVs\&quot;, \&quot;nfs\&quot;:{\&quot;enabled\&quot;:\&quot;true\&quot;}, \&quot;fcp\&quot;:{\&quot;enabled\&quot;:\&quot;true\&quot;}, \&quot;iscsi\&quot;:{\&quot;enabled\&quot;:\&quot;true\&quot;}}&#39;     &#x60;&#x60;&#x60;     &lt;br/&gt; 3. Creates an SVM and configures NVMe     &lt;br/&gt;     &#x60;&#x60;&#x60;     POST \&quot;/api/svm/svms\&quot; &#39;{\&quot;name\&quot;:\&quot;testVs\&quot;, \&quot;nvme\&quot;:{\&quot;enabled\&quot;:\&quot;true\&quot;}}&#39;     &#x60;&#x60;&#x60;     &lt;br/&gt; 4. Creates an SVM and configures LDAP     &lt;br/&gt;     &#x60;&#x60;&#x60;     POST \&quot;/api/svm/svms\&quot; &#39;{\&quot;name\&quot;:\&quot;testVs\&quot;, \&quot;snapshot_policy\&quot;:{\&quot;name\&quot;:\&quot;default\&quot;}, \&quot;ldap\&quot;:{\&quot;servers\&quot;:[\&quot;10.140.101.1\&quot;,\&quot;10.140.101.2\&quot;], \&quot;ad_domain\&quot;:\&quot;abc.com\&quot;, \&quot;base_dn\&quot;:\&quot;dc&#x3D;netapp,dc&#x3D;com\&quot;, \&quot;bind_dn\&quot;:\&quot;dc&#x3D;netapp,dc&#x3D;com\&quot;}}&#39;     &#x60;&#x60;&#x60;     &lt;br/&gt; 5. Creates an SVM and configures NIS     &lt;br/&gt;     &#x60;&#x60;&#x60;     POST \&quot;/api/svm/svms\&quot; &#39;{\&quot;name\&quot;:\&quot;testVs\&quot;, \&quot;snapshot_policy\&quot;:{\&quot;name\&quot;:\&quot;default\&quot;}, \&quot;nis\&quot;:{\&quot;enabled\&quot;:\&quot;true\&quot;, \&quot;domain\&quot;:\&quot;def.com\&quot;,\&quot;servers\&quot;:[\&quot;10.224.223.130\&quot;, \&quot;10.224.223.131\&quot;]}}&#39;     &#x60;&#x60;&#x60;     &lt;br/&gt; 6. Creates an SVM and configures DNS     &lt;br/&gt;     &#x60;&#x60;&#x60;     POST \&quot;/api/svm/svms\&quot; &#39;{\&quot;name\&quot;:\&quot;testVs\&quot;, \&quot;snapshot_policy\&quot;:{\&quot;name\&quot;:\&quot;default\&quot;}, \&quot;dns\&quot;:{\&quot;domains\&quot;:[\&quot;abc.com\&quot;,\&quot;def.com\&quot;], \&quot;servers\&quot;:[\&quot;10.224.223.130\&quot;, \&quot;10.224.223.131\&quot;]}}&#39;     &#x60;&#x60;&#x60;     &lt;br/&gt; 7. Creates an SVM and configures a LIF     &lt;br/&gt;     &#x60;&#x60;&#x60;     POST \&quot;/api/svm/svms\&quot; &#39;{\&quot;name\&quot;:\&quot;testVs\&quot;, \&quot;ip_interfaces\&quot;: [{\&quot;name\&quot;:\&quot;lif1\&quot;, \&quot;ip\&quot;:{\&quot;address\&quot;:\&quot;10.10.10.7\&quot;, \&quot;netmask\&quot;: \&quot;255.255.255.0\&quot;}, \&quot;location\&quot;:{\&quot;broadcast_domain\&quot;:{\&quot;name\&quot;:\&quot;bd1\&quot;}, \&quot;home_node\&quot;:{\&quot;name\&quot;:\&quot;node1\&quot;}}, \&quot;service_policy\&quot;: \&quot;default-management\&quot;}]}&#39;     &#x60;&#x60;&#x60;     &lt;br/&gt; 8. Creates an SVM and configures a LIF with IPV6 address     &lt;br/&gt;     &#x60;&#x60;&#x60;     POST \&quot;/api/svm/svms\&quot; &#39;{\&quot;name\&quot;:\&quot;testVs\&quot;, \&quot;ip_interfaces\&quot;: [{\&quot;name\&quot;:\&quot;lif2\&quot;, \&quot;ip\&quot;:{\&quot;address\&quot;:\&quot;fd22:8b1e:b255:202:2a0:98ff:fe01:7d5b\&quot;, \&quot;netmask\&quot;:\&quot;24\&quot;}, \&quot;location\&quot;:{\&quot;broadcast_domain\&quot;:{\&quot;name\&quot;:\&quot;bd1\&quot;}, \&quot;home_node\&quot;:{\&quot;name\&quot;:\&quot;node1\&quot;}}, \&quot;service_policy\&quot;: \&quot;default-management\&quot;}]}&#39;     &#x60;&#x60;&#x60;     &lt;br/&gt; 9. Creates an SVM and configures CIFS     &lt;br/&gt;     &#x60;&#x60;&#x60;     POST \&quot;/api/svm/svms\&quot; &#39;{\&quot;name\&quot;:\&quot;testVs\&quot;, \&quot;cifs\&quot;:{\&quot;name\&quot;:\&quot;CIFDOC\&quot;, \&quot;ad_domain\&quot;:{\&quot;fqdn\&quot;:\&quot;abc.def.com\&quot;, \&quot;organizational_unit\&quot;:\&quot;CN&#x3D;Computers\&quot;, \&quot;user\&quot;:\&quot;cif_admin\&quot;, \&quot;password\&quot;:\&quot;abc123\&quot;}}, \&quot;ip_interfaces\&quot;:[{\&quot;name\&quot;:\&quot;lif1\&quot;, \&quot;ip\&quot;:{\&quot;address\&quot;:\&quot;10.10.10.7\&quot;, \&quot;netmask\&quot;: \&quot;255.255.255.0\&quot;}, \&quot;location\&quot;:{\&quot;broadcast_domain\&quot;:{\&quot;name\&quot;:\&quot;bd1\&quot;}, \&quot;home_node\&quot;:{\&quot;name\&quot;:\&quot;node1\&quot;}}, \&quot;service_policy\&quot;: \&quot;default-management\&quot;}],\&quot;routes\&quot;: [{\&quot;destination\&quot;: {\&quot;address\&quot;: \&quot;0.0.0.0\&quot;, \&quot;netmask\&quot;: \&quot;0\&quot;}, \&quot;gateway\&quot;: \&quot;10.10.10.7\&quot;}], \&quot;dns\&quot;:{\&quot;domains\&quot;:[\&quot;abc.def.com\&quot;, \&quot;def.com\&quot;], \&quot;servers\&quot;:[\&quot;10.224.223.130\&quot;, \&quot;10.224.223.131\&quot;]}}&#39;     &#x60;&#x60;&#x60;     &lt;br/&gt; ### Learn more * [&#x60;DOC /svm/svms&#x60;](#docs-svm-svm_svms) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *SvmCreateOpts - Optional Parameters:
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning. When doing a POST, PATCH, or DELETE operation on a single record, the default is 0 seconds.  This means that if an asynchronous operation is started, the server immediately returns HTTP code 202 (Accepted) along with a link to the job.  If a non-zero value is specified for POST, PATCH, or DELETE operations, ONTAP waits that length of time to see if the job completes so it can return something other than 202.
 * @param "Info" (optional.Interface of Svm) -  Info specification
@return JobLinkResponse
*/
func (a *SvmApiService) SvmCreate(ctx _context.Context, localVarOptionals *SvmCreateOpts) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/svm/svms"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(Svm)
		if !localVarOptionalInfook {
			return localVarReturnValue, nil, reportError("info should be Svm")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// SvmDeleteOpts Optional parameters for the method 'SvmDelete'
type SvmDeleteOpts struct {
    ReturnTimeout optional.Int32
}

/*
SvmDelete Method for SvmDelete
Deletes an SVM. As a prerequisite, SVM objects must be deleted first. SnapMirror relations must be deleted and data volumes must be offline and deleted. The number of parallel SVMs that can be deleted should not be greater than 5. When the sixth SVM DELETE request is issued, the error message \&quot;Maximum allowed SVM jobs exceeded. Wait for the existing SVM jobs to complete and try again.\&quot; will be returned. ### Related ONTAP commands * &#x60;vserver delete&#x60; ### Example Deletes an individual SVM in the cluster.   &lt;br/&gt;   &#x60;&#x60;&#x60;   DELETE \&quot;/api/svm/svms/f16f0935-5281-11e8-b94d-005056b46485\&quot;   &#x60;&#x60;&#x60;   &lt;br/&gt; ### Learn more * [&#x60;DOC /svm/svms&#x60;](#docs-svm-svm_svms) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Filter by UUID
 * @param optional nil or *SvmDeleteOpts - Optional Parameters:
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning. When doing a POST, PATCH, or DELETE operation on a single record, the default is 0 seconds.  This means that if an asynchronous operation is started, the server immediately returns HTTP code 202 (Accepted) along with a link to the job.  If a non-zero value is specified for POST, PATCH, or DELETE operations, ONTAP waits that length of time to see if the job completes so it can return something other than 202.
@return JobLinkResponse
*/
func (a *SvmApiService) SvmDelete(ctx _context.Context, uuid string, localVarOptionals *SvmDeleteOpts) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/svm/svms/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// SvmGetOpts Optional parameters for the method 'SvmGet'
type SvmGetOpts struct {
    Fields optional.Interface
}

/*
SvmGet Method for SvmGet
Retrieves the properties for an individual SVM. This includes protocol configurations such as CIFS and NFS, export policies, name service configurations, and network services. ### Important note * The SVM object includes a large set of fields and can be expensive to retrieve. * REST APIs only expose a data SVM as an SVM. ### Example     Retrieves an individual SVM in the cluster     &lt;br/&gt;     &#x60;&#x60;&#x60;     GET \&quot;/api/svm/svms/f16f0935-5281-11e8-b94d-005056b46485\&quot;     &#x60;&#x60;&#x60;     &lt;br/&gt;  ### Learn more * [&#x60;DOC /svm/svms&#x60;](#docs-svm-svm_svms)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Filter by UUID
 * @param optional nil or *SvmGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return Svm
*/
func (a *SvmApiService) SvmGet(ctx _context.Context, uuid string, localVarOptionals *SvmGetOpts) (Svm, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Svm
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/svm/svms/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Svm
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// SvmPatchModifyOpts Optional parameters for the method 'SvmPatchModify'
type SvmPatchModifyOpts struct {
    ReturnTimeout optional.Int32
    Info optional.Interface
}

/*
SvmPatchModify Method for SvmPatchModify
Updates one or more of the following properties of an individual SVM: SVM name, SVM default volume language code, SVM comment, and SVM state. ### Related ONTAP commands * &#x60;vserver modify&#x60; * &#x60;vserver rename&#x60; * &#x60;vserver start&#x60; * &#x60;vserver stop&#x60; ### Examples 1.  Stops an SVM and updates the \&quot;comment\&quot; field for an individual SVM     &lt;br/&gt;     &#x60;&#x60;&#x60;     PATCH \&quot;/api/svm/svms/f16f0935-5281-11e8-b94d-005056b46485\&quot; &#39;{\&quot;state\&quot;:\&quot;stopped\&quot;, \&quot;comment\&quot;:\&quot;This SVM is stopped.\&quot;}&#39;     &#x60;&#x60;&#x60;     &lt;br/&gt; 2.  Starts an SVM and updates the \&quot;comment\&quot; field for an individual SVM     &lt;br/&gt;     &#x60;&#x60;&#x60;     PATCH \&quot;/api/svm/svms/f16f0935-5281-11e8-b94d-005056b46485\&quot; &#39;{\&quot;state\&quot;:\&quot;running\&quot;, \&quot;comment\&quot;:\&quot;This SVM is running.\&quot;}&#39;     &#x60;&#x60;&#x60;     &lt;br/&gt; 3.  Updates the \&quot;language\&quot; field for an individual SVM     &lt;br/&gt;     &#x60;&#x60;&#x60;     PATCH \&quot;/api/svm/svms/f16f0935-5281-11e8-b94d-005056b46485\&quot; &#39;{\&quot;language\&quot;:\&quot;en.UTF-8\&quot;}&#39;     &#x60;&#x60;&#x60;     &lt;br/&gt; 4.  Updates the \&quot;name\&quot; field for an SVM or renames the SVM     &lt;br/&gt;     &#x60;&#x60;&#x60;     PATCH \&quot;/api/svm/svms/f16f0935-5281-11e8-b94d-005056b46485\&quot; &#39;{\&quot;name\&quot;:\&quot;svm_new\&quot;}&#39;     &#x60;&#x60;&#x60;     &lt;br/&gt; 5.  Updates the aggregates for an individual SVM     &lt;br/&gt;     &#x60;&#x60;&#x60;     PATCH \&quot;/api/svm/svms/f16f0935-5281-11e8-b94d-005056b46485\&quot; &#39;{\&quot;aggregates\&quot;:{\&quot;name\&quot;:[\&quot;aggr1\&quot;,\&quot;aggr2\&quot;,\&quot;aggr3\&quot;]}}&#39;     &#x60;&#x60;&#x60;     &lt;br/&gt; 6.  Updates the Snapshot copy policy for an individual SVM     &lt;br/&gt;     &#x60;&#x60;&#x60;     PATCH \&quot;/api/svm/svms/f16f0935-5281-11e8-b94d-005056b46485\&quot; &#39;{\&quot;snapshot_policy\&quot;:{\&quot;name\&quot;:\&quot;custom1\&quot;}}&#39;     &#x60;&#x60;&#x60;     &lt;br/&gt; ### Learn more * [&#x60;DOC /svm/svms&#x60;](#docs-svm-svm_svms) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Filter by UUID
 * @param optional nil or *SvmPatchModifyOpts - Optional Parameters:
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning. When doing a POST, PATCH, or DELETE operation on a single record, the default is 0 seconds.  This means that if an asynchronous operation is started, the server immediately returns HTTP code 202 (Accepted) along with a link to the job.  If a non-zero value is specified for POST, PATCH, or DELETE operations, ONTAP waits that length of time to see if the job completes so it can return something other than 202.
 * @param "Info" (optional.Interface of Svm) -  Info specification
@return JobLinkResponse
*/
func (a *SvmApiService) SvmPatchModify(ctx _context.Context, uuid string, localVarOptionals *SvmPatchModifyOpts) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/svm/svms/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(Svm)
		if !localVarOptionalInfook {
			return localVarReturnValue, nil, reportError("info should be Svm")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// SvmPeerCollectionGetOpts Optional parameters for the method 'SvmPeerCollectionGet'
type SvmPeerCollectionGetOpts struct {
    Uuid optional.String
    PeerClusterUuid optional.String
    PeerClusterName optional.String
    PeerSvmUuid optional.String
    PeerSvmName optional.String
    State optional.String
    Applications optional.String
    Name optional.String
    SvmUuid optional.String
    SvmName optional.String
    Fields optional.Interface
    MaxRecords optional.Int32
    ReturnRecords optional.Bool
    ReturnTimeout optional.Int32
    OrderBy optional.Interface
}

/*
SvmPeerCollectionGet Method for SvmPeerCollectionGet
Retrieves the list of SVM peer relationships. ### Related ONTAP commands * &#x60;vserver peer show&#x60; ### Examples The following examples show how to retrieve a collection of SVM peer relationships based on a query. 1. Retrieves a list of SVM peers of a specific local SVM    &lt;br/&gt;    &#x60;&#x60;&#x60;    GET \&quot;/api/svm/peers/?svm.name&#x3D;VS1\&quot;    &#x60;&#x60;&#x60;    &lt;br/&gt; 2. Retrieves a list of SVM peers of a specific cluster peer    &lt;br/&gt;    &#x60;&#x60;&#x60;    GET \&quot;/api/svm/peers/?peer.cluster.name&#x3D;cluster2\&quot;    &#x60;&#x60;&#x60;    &lt;br/&gt; ### Learn more * [&#x60;DOC /svm/peers&#x60;](#docs-svm-svm_peers) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *SvmPeerCollectionGetOpts - Optional Parameters:
 * @param "Uuid" (optional.String) -  Filter by uuid
 * @param "PeerClusterUuid" (optional.String) -  Filter by peer.cluster.uuid
 * @param "PeerClusterName" (optional.String) -  Filter by peer.cluster.name
 * @param "PeerSvmUuid" (optional.String) -  Filter by peer.svm.uuid
 * @param "PeerSvmName" (optional.String) -  Filter by peer.svm.name
 * @param "State" (optional.String) -  Filter by state
 * @param "Applications" (optional.String) -  Filter by applications
 * @param "Name" (optional.String) -  Filter by name
 * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
 * @param "SvmName" (optional.String) -  Filter by svm.name
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return SvmPeerResponse
*/
func (a *SvmApiService) SvmPeerCollectionGet(ctx _context.Context, localVarOptionals *SvmPeerCollectionGetOpts) (SvmPeerResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SvmPeerResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/svm/peers"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PeerClusterUuid.IsSet() {
		localVarQueryParams.Add("peer.cluster.uuid", parameterToString(localVarOptionals.PeerClusterUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PeerClusterName.IsSet() {
		localVarQueryParams.Add("peer.cluster.name", parameterToString(localVarOptionals.PeerClusterName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PeerSvmUuid.IsSet() {
		localVarQueryParams.Add("peer.svm.uuid", parameterToString(localVarOptionals.PeerSvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PeerSvmName.IsSet() {
		localVarQueryParams.Add("peer.svm.name", parameterToString(localVarOptionals.PeerSvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Applications.IsSet() {
		localVarQueryParams.Add("applications", parameterToString(localVarOptionals.Applications.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v SvmPeerResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// SvmPeerCreateOpts Optional parameters for the method 'SvmPeerCreate'
type SvmPeerCreateOpts struct {
    Info optional.Interface
}

/*
SvmPeerCreate Method for SvmPeerCreate
Creates a new SVM peer relationship. ### Important notes   * The create request accepts peer SVM name as input instead of peer SVM UUID as the local cluster cannot validate peer SVM based on UUID.   * The input parameter &#x60;name&#x60; refers to the local name of the peer SVM. The &#x60;peer cluster name&#x60; parameter is optional for creating intracluster SVM peer relationships. ### Required properties * &#x60;svm.name&#x60; or &#x60;svm.uuid&#x60; - SVM name or SVM UUID * &#x60;peer.svm.name&#x60; or &#x60;peer.svm.uuid&#x60; - Peer SVM name or Peer SVM UUID * &#x60;peer.cluster.name&#x60; or &#x60;peer.cluster.uuid&#x60; - Peer cluster name or peer cluster UUID * &#x60;applications&#x60; - Peering applications ### Related ONTAP commands * &#x60;vserver peer create&#x60; ### Example Creates a new SVM peer relationship. &lt;br/&gt; &#x60;&#x60;&#x60; POST \&quot;/api/svm/peers\&quot; &#39;{\&quot;svm\&quot;:{\&quot;name\&quot;:\&quot;vs1\&quot;, \&quot;peer.cluster.name\&quot;:\&quot;cluster2\&quot;, \&quot;peer.svm.name\&quot;:\&quot;VS1\&quot;, \&quot;applications\&quot;:[\&quot;snapmirror\&quot;]}&#39; &#x60;&#x60;&#x60; &lt;br/&gt; ### Learn more * [&#x60;DOC /svm/peers&#x60;](#docs-svm-svm_peers) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *SvmPeerCreateOpts - Optional Parameters:
 * @param "Info" (optional.Interface of SvmPeer) -  Info specification
@return SvmPeer
*/
func (a *SvmApiService) SvmPeerCreate(ctx _context.Context, localVarOptionals *SvmPeerCreateOpts) (SvmPeer, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SvmPeer
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/svm/peers"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(SvmPeer)
		if !localVarOptionalInfook {
			return localVarReturnValue, nil, reportError("info should be SvmPeer")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v SvmPeer
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
SvmPeerDelete Method for SvmPeerDelete
Deletes the SVM peer relationship. ### Related ONTAP commands * &#x60;vserver peer delete&#x60; ### Example Deletes an SVM peer relationship. &lt;br/&gt; &#x60;&#x60;&#x60; DELETE \&quot;/api/svm/peers/d3268a74-ee76-11e8-a9bb-005056ac6dc9\&quot; &#x60;&#x60;&#x60; &lt;br/&gt; ### Learn more * [&#x60;DOC /svm/peers&#x60;](#docs-svm-svm_peers) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param peerUuid SVM peer relationship UUID
*/
func (a *SvmApiService) SvmPeerDelete(ctx _context.Context, peerUuid string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/svm/peers/{peer.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"peer.uuid"+"}", _neturl.QueryEscape(parameterToString(peerUuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// SvmPeerInstanceGetOpts Optional parameters for the method 'SvmPeerInstanceGet'
type SvmPeerInstanceGetOpts struct {
    Fields optional.Interface
    ReturnTimeout optional.Int32
}

/*
SvmPeerInstanceGet Method for SvmPeerInstanceGet
Retrieves the SVM peer relationship instance. ### Related ONTAP commands * &#x60;vserver peer show&#x60; ### Example Retrieves the parameters of an SVM peer relationship. &lt;br/&gt; &#x60;&#x60;&#x60; GET \&quot;/api/svm/peers/d3268a74-ee76-11e8-a9bb-005056ac6dc9\&quot; &#x60;&#x60;&#x60; &lt;br/&gt; ### Learn more * [&#x60;DOC /svm/peers&#x60;](#docs-svm-svm_peers) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param peerUuid SVM peer relation UUID
 * @param optional nil or *SvmPeerInstanceGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
@return SvmPeer
*/
func (a *SvmApiService) SvmPeerInstanceGet(ctx _context.Context, peerUuid string, localVarOptionals *SvmPeerInstanceGetOpts) (SvmPeer, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SvmPeer
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/svm/peers/{peer.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"peer.uuid"+"}", _neturl.QueryEscape(parameterToString(peerUuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v SvmPeer
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// SvmPeerModifyOpts Optional parameters for the method 'SvmPeerModify'
type SvmPeerModifyOpts struct {
    Info optional.Interface
}

/*
SvmPeerModify Method for SvmPeerModify
Updates the SVM peer relationship. ### Related ONTAP commands * &#x60;vserver peer modify&#x60; ### Examples The following examples show how to update an SVM peer relationship. The input parameter &#39;name&#39; refers to the local name of the peer SVM. &lt;br/&gt; 1. Accepts an SVM peer relationship    &lt;br/&gt;    &#x60;&#x60;&#x60;    PATCH \&quot;/api/svm/peers/d3268a74-ee76-11e8-a9bb-005056ac6dc9\&quot; &#39;{\&quot;state\&quot;:\&quot;peered\&quot;}&#39;    &#x60;&#x60;&#x60;    &lt;br/&gt; 2. Updates the local name of an SVM peer relationship    &lt;br/&gt;    &#x60;&#x60;&#x60;    PATCH \&quot;/api/svm/peers/d3268a74-ee76-11e8-a9bb-005056ac6dc9\&quot; &#39;{\&quot;name\&quot;:\&quot;vs2\&quot;}&#39;    &#x60;&#x60;&#x60;    &lt;br/&gt; ### Learn more * [&#x60;DOC /svm/peers&#x60;](#docs-svm-svm_peers) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param peerUuid SVM peer relationship UUID
 * @param optional nil or *SvmPeerModifyOpts - Optional Parameters:
 * @param "Info" (optional.Interface of SvmPeer) -  Info specification
*/
func (a *SvmApiService) SvmPeerModify(ctx _context.Context, peerUuid string, localVarOptionals *SvmPeerModifyOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/svm/peers/{peer.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"peer.uuid"+"}", _neturl.QueryEscape(parameterToString(peerUuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(SvmPeer)
		if !localVarOptionalInfook {
			return nil, reportError("info should be SvmPeer")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// SvmPeerPermissionCollectionGetOpts Optional parameters for the method 'SvmPeerPermissionCollectionGet'
type SvmPeerPermissionCollectionGetOpts struct {
    SvmUuid optional.String
    SvmName optional.String
    Applications optional.String
    ClusterPeerUuid optional.String
    ClusterPeerName optional.String
    Fields optional.Interface
    MaxRecords optional.Int32
    ReturnRecords optional.Bool
    ReturnTimeout optional.Int32
    OrderBy optional.Interface
}

/*
SvmPeerPermissionCollectionGet Method for SvmPeerPermissionCollectionGet
Retrieves the list of SVM peer permissions. ### Related ONTAP commands * &#x60;vserver peer permission show&#x60; ### Examples The following examples show how to retrieve a collection of SVM peer permissions based on a query. &lt;br/&gt; 1. Retrieves a list of SVM peer permissions of a specific local SVM    &lt;br/&gt;    &#x60;&#x60;&#x60;    GET \&quot;/api/svm/peer-permissions/?svm.name&#x3D;VS1\&quot;    &#x60;&#x60;&#x60;    &lt;br/&gt; 2. Retrieves a list of SVM peer permissions of a specific cluster peer    &lt;br/&gt;    &#x60;&#x60;&#x60;    GET \&quot;/api/svm/peer-permissions/?cluster_peer.name&#x3D;cluster2\&quot;    &#x60;&#x60;&#x60;    &lt;br/&gt; ### Learn more * [&#x60;DOC /svm/peer-permissions&#x60;](#docs-svm-svm_peer-permissions) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *SvmPeerPermissionCollectionGetOpts - Optional Parameters:
 * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
 * @param "SvmName" (optional.String) -  Filter by svm.name
 * @param "Applications" (optional.String) -  Filter by applications
 * @param "ClusterPeerUuid" (optional.String) -  Filter by cluster_peer.uuid
 * @param "ClusterPeerName" (optional.String) -  Filter by cluster_peer.name
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return SvmPeerPermissionResponse
*/
func (a *SvmApiService) SvmPeerPermissionCollectionGet(ctx _context.Context, localVarOptionals *SvmPeerPermissionCollectionGetOpts) (SvmPeerPermissionResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SvmPeerPermissionResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/svm/peer-permissions"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Applications.IsSet() {
		localVarQueryParams.Add("applications", parameterToString(localVarOptionals.Applications.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClusterPeerUuid.IsSet() {
		localVarQueryParams.Add("cluster_peer.uuid", parameterToString(localVarOptionals.ClusterPeerUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClusterPeerName.IsSet() {
		localVarQueryParams.Add("cluster_peer.name", parameterToString(localVarOptionals.ClusterPeerName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v SvmPeerPermissionResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
SvmPeerPermissionDelete Method for SvmPeerPermissionDelete
Deletes the SVM peer permissions. ### Related ONTAP commands * &#x60;verver peer permission delete&#x60; ### Example Deletes an SVM peer permission. &lt;br/&gt; &#x60;&#x60;&#x60; DELETE \&quot;/api/svm/peer-permissions/d3268a74-ee76-11e8-a9bb-005056ac6dc9/8f467b93-f2f1-11e8-9027-005056ac81fc\&quot; &#x60;&#x60;&#x60; &lt;br/&gt; ### Learn more * [&#x60;DOC /svm/peer-permissions&#x60;](#docs-svm-svm_peer-permissions) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param clusterUuid Peer cluster UUID
 * @param svmUuid SVM UUID
*/
func (a *SvmApiService) SvmPeerPermissionDelete(ctx _context.Context, clusterUuid string, svmUuid string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/svm/peer-permissions/{cluster.uuid}/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster.uuid"+"}", _neturl.QueryEscape(parameterToString(clusterUuid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", _neturl.QueryEscape(parameterToString(svmUuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// SvmPeerPermissionInstanceGetOpts Optional parameters for the method 'SvmPeerPermissionInstanceGet'
type SvmPeerPermissionInstanceGetOpts struct {
    Fields optional.Interface
    ReturnTimeout optional.Int32
}

/*
SvmPeerPermissionInstanceGet Method for SvmPeerPermissionInstanceGet
Retrieves the SVM peer permission instance. ### Related ONTAP commands * &#x60;vserver peer permission show&#x60; ### Example The following example shows how to retrieve the parameters for an SVM peer permission. &lt;br/&gt; &#x60;&#x60;&#x60; GET \&quot;/api/svm/peer-permissions/d3268a74-ee76-11e8-a9bb-005056ac6dc9/8f467b93-f2f1-11e8-9027-005056ac81fc\&quot; &#x60;&#x60;&#x60; &lt;br/&gt; ### Learn more * [&#x60;DOC /svm/peer-permissions&#x60;](#docs-svm-svm_peer-permissions) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param clusterUuid Peer cluster UUID
 * @param svmUuid SVM UUID
 * @param optional nil or *SvmPeerPermissionInstanceGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
@return SvmPeerPermission
*/
func (a *SvmApiService) SvmPeerPermissionInstanceGet(ctx _context.Context, clusterUuid string, svmUuid string, localVarOptionals *SvmPeerPermissionInstanceGetOpts) (SvmPeerPermission, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SvmPeerPermission
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/svm/peer-permissions/{cluster.uuid}/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster.uuid"+"}", _neturl.QueryEscape(parameterToString(clusterUuid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", _neturl.QueryEscape(parameterToString(svmUuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v SvmPeerPermission
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// SvmPeerPermissionModifyOpts Optional parameters for the method 'SvmPeerPermissionModify'
type SvmPeerPermissionModifyOpts struct {
    Info optional.Interface
}

/*
SvmPeerPermissionModify Method for SvmPeerPermissionModify
Updates the SVM peer permissions. ### Related ONTAP commands * &#x60;vserver peer permission modify&#x60; ### Example Updates an SVM peer permission. &lt;br/&gt; &#x60;&#x60;&#x60; PATCH \&quot;/api/svm/peer-permissions/d3268a74-ee76-11e8-a9bb-005056ac6dc9/8f467b93-f2f1-11e8-9027-005056ac81fc\&quot; &#39;{\&quot;applications\&quot;:[\&quot;flexcache\&quot;]}&#39; &#x60;&#x60;&#x60; &lt;br/&gt; ### Learn more * [&#x60;DOC /svm/peer-permissions&#x60;](#docs-svm-svm_peer-permissions) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param clusterUuid Peer cluster UUID
 * @param svmUuid SVM UUID
 * @param optional nil or *SvmPeerPermissionModifyOpts - Optional Parameters:
 * @param "Info" (optional.Interface of SvmPeerPermission) -  Info specification
@return SvmPeerPermission
*/
func (a *SvmApiService) SvmPeerPermissionModify(ctx _context.Context, clusterUuid string, svmUuid string, localVarOptionals *SvmPeerPermissionModifyOpts) (SvmPeerPermission, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SvmPeerPermission
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/svm/peer-permissions/{cluster.uuid}/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster.uuid"+"}", _neturl.QueryEscape(parameterToString(clusterUuid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", _neturl.QueryEscape(parameterToString(svmUuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(SvmPeerPermission)
		if !localVarOptionalInfook {
			return localVarReturnValue, nil, reportError("info should be SvmPeerPermission")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v SvmPeerPermission
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// SvmPeerPermissionPostOpts Optional parameters for the method 'SvmPeerPermissionPost'
type SvmPeerPermissionPostOpts struct {
    Info optional.Interface
}

/*
SvmPeerPermissionPost Method for SvmPeerPermissionPost
Creates an SVM peer permission. ### Required properties * &#x60;svm.name&#x60; or &#x60;svm.uuid&#x60; - SVM name * &#x60;cluster_peer.uuid&#x60; or &#x60;cluster_peer.name&#x60; - Peer cluster name or peer cluster UUID * &#x60;applications&#x60; - Peering applications ### Related ONTAP commands * &#x60;vserver peer permission create&#x60; ### Examples The following examples show how to create SVM peer permissions. &lt;br/&gt; 1. Creates an SVM peer permission entry with the local SVM and cluster peer names    &lt;br/&gt;    &#x60;&#x60;&#x60;    POST \&quot;/api/svm/peer-permissions\&quot; &#39;{\&quot;cluster_peer\&quot;:{\&quot;name\&quot;:\&quot;cluster2\&quot;}, \&quot;svm\&quot;:{\&quot;name\&quot;:\&quot;VS1\&quot;}, \&quot;applications\&quot;:[\&quot;snapmirror\&quot;]}&#39;    &#x60;&#x60;&#x60;    &lt;br/&gt; 2. Creates an SVM peer permission entry with the local SVM and cluster peer UUID    &lt;br/&gt;    &#x60;&#x60;&#x60;    POST \&quot;/api/svm/peer-permissions\&quot; &#39;{\&quot;cluster_peer\&quot;:{\&quot;uuid\&quot;:\&quot;d3268a74-ee76-11e8-a9bb-005056ac6dc9\&quot;}, \&quot;svm\&quot;:{\&quot;uuid\&quot;:\&quot;8f467b93-f2f1-11e8-9027-005056ac81fc\&quot;}, \&quot;applications\&quot;:[\&quot;snapmirror\&quot;]}&#39;    &#x60;&#x60;&#x60;    &lt;br/&gt; 3. Creates an SVM peer permission entry with all SVMs and the cluster peer name    &lt;br/&gt;    &#x60;&#x60;&#x60;    POST \&quot;/api/svm/peer-permissions\&quot; &#39;{\&quot;cluster_peer\&quot;:{\&quot;name\&quot;:\&quot;cluster2\&quot;}, \&quot;svm\&quot;:{\&quot;name\&quot;:\&quot;*\&quot;}, \&quot;applications\&quot;:[\&quot;snapmirror\&quot;]}&#39;    &#x60;&#x60;&#x60;    &lt;br/&gt; ### Learn more * [&#x60;DOC /svm/peer-permissions&#x60;](#docs-svm-svm_peer-permissions) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *SvmPeerPermissionPostOpts - Optional Parameters:
 * @param "Info" (optional.Interface of SvmPeerPermission) -  Info specification
@return SvmPeerPermission
*/
func (a *SvmApiService) SvmPeerPermissionPost(ctx _context.Context, localVarOptionals *SvmPeerPermissionPostOpts) (SvmPeerPermission, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SvmPeerPermission
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/svm/peer-permissions"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(SvmPeerPermission)
		if !localVarOptionalInfook {
			return localVarReturnValue, nil, reportError("info should be SvmPeerPermission")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 201 {
			var v SvmPeerPermission
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
