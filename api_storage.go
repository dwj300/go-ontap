/*
 * ONTAP REST API
 *
 * ONTAP 9.6 adds support for an expansive RESTful API. The documentation below provides information about the types of API calls available to you, as well as details about using each API endpoint. You can learn more about the ONTAP REST API and ONTAP in the ONTAP 9 Documentation Center:  http://docs.netapp.com/ontap-9/topic/com.netapp.doc.dot-rest-api/home.html. NetApp welcomes your comments and suggestions about the ONTAP REST API and the documentation for its use.</br> **Using the ONTAP 9.6 REST API online documentation** Each API method includes usage examples, as well as a model that displays all the required and optional properties supported by the method. Click the _Model_ link, available with each API method, to see all the required and optional properties supported by each method.
 *
 * API version: v1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package ontap

import (
	_context "context"
	"github.com/antihax/optional"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// StorageApiService StorageApi service
type StorageApiService service

// AggregateCollectionGetOpts Optional parameters for the method 'AggregateCollectionGet'
type AggregateCollectionGetOpts struct {
	Recommend                                  optional.Bool
	ShowSpares                                 optional.Bool
	SnaplockType                               optional.String
	Name                                       optional.String
	HomeNodeUuid                               optional.String
	HomeNodeName                               optional.String
	Uuid                                       optional.String
	NodeUuid                                   optional.String
	NodeName                                   optional.String
	DrHomeNodeName                             optional.String
	DrHomeNodeUuid                             optional.String
	CreateTime                                 optional.String
	SpaceEfficiencyLogicalUsed                 optional.Int32
	SpaceEfficiencyRatio                       optional.Float32
	SpaceEfficiencySavings                     optional.Int32
	SpaceFootprint                             optional.Int32
	SpaceEfficiencyWithoutSnapshotsLogicalUsed optional.Int32
	SpaceEfficiencyWithoutSnapshotsRatio       optional.Float32
	SpaceEfficiencyWithoutSnapshotsSavings     optional.Int32
	SpaceBlockStorageFullThresholdPercent      optional.Int32
	SpaceBlockStorageUsed                      optional.Int32
	SpaceBlockStorageAvailable                 optional.Int32
	SpaceBlockStorageSize                      optional.Int32
	SpaceBlockStorageInactiveUserData          optional.Int32
	SpaceCloudStorageUsed                      optional.Int32
	BlockStoragePrimaryRaidSize                optional.Int32
	BlockStoragePrimaryRaidType                optional.String
	BlockStoragePrimaryChecksumStyle           optional.String
	BlockStoragePrimaryDiskClass               optional.String
	BlockStoragePrimaryDiskCount               optional.Int32
	BlockStoragePlexesName                     optional.String
	BlockStorageHybridCacheRaidType            optional.String
	BlockStorageHybridCacheUsed                optional.Int32
	BlockStorageHybridCacheEnabled             optional.Bool
	BlockStorageHybridCacheSize                optional.Int32
	BlockStorageHybridCacheDiskCount           optional.Int32
	BlockStorageMirrorState                    optional.String
	BlockStorageMirrorEnabled                  optional.Bool
	DataEncryptionSoftwareEncryptionEnabled    optional.Bool
	DataEncryptionDriveProtectionEnabled       optional.Bool
	State                                      optional.String
	Fields                                     optional.Interface
	MaxRecords                                 optional.Int32
	ReturnRecords                              optional.Bool
	ReturnTimeout                              optional.Int32
	OrderBy                                    optional.Interface
}

/*
AggregateCollectionGet Method for AggregateCollectionGet
Retrieves the collection of aggregates for the entire cluster. ### Expensive properties There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the &#x60;fields&#x60; query parameter. See [&#x60;DOC Requesting specific fields&#x60;](#docs-docs-Requesting-specific-fields) to learn more. * &#x60;space.block_storage.inactive_user_data&#x60; * &#x60;space.footprint&#x60; ### Related ONTAP commands * &#x60;storage aggregate show&#x60;  ### Learn more * [&#x60;DOC /storage/aggregates&#x60;](#docs-storage-storage_aggregates)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *AggregateCollectionGetOpts - Optional Parameters:
 * @param "Recommend" (optional.Bool) -  If set to 'true', it queries the system for the recommended optimal layout for creating new aggregates. The default setting is 'false'.
 * @param "ShowSpares" (optional.Bool) -  If set to 'true', the spares object is returned instead of records to show the spare groups in the cluster. The default setting is 'false'.
 * @param "SnaplockType" (optional.String) -  Filter by snaplock_type
 * @param "Name" (optional.String) -  Filter by name
 * @param "HomeNodeUuid" (optional.String) -  Filter by home_node.uuid
 * @param "HomeNodeName" (optional.String) -  Filter by home_node.name
 * @param "Uuid" (optional.String) -  Filter by uuid
 * @param "NodeUuid" (optional.String) -  Filter by node.uuid
 * @param "NodeName" (optional.String) -  Filter by node.name
 * @param "DrHomeNodeName" (optional.String) -  Filter by dr_home_node.name
 * @param "DrHomeNodeUuid" (optional.String) -  Filter by dr_home_node.uuid
 * @param "CreateTime" (optional.String) -  Filter by create_time
 * @param "SpaceEfficiencyLogicalUsed" (optional.Int32) -  Filter by space.efficiency.logical_used
 * @param "SpaceEfficiencyRatio" (optional.Float32) -  Filter by space.efficiency.ratio
 * @param "SpaceEfficiencySavings" (optional.Int32) -  Filter by space.efficiency.savings
 * @param "SpaceFootprint" (optional.Int32) -  Filter by space.footprint
 * @param "SpaceEfficiencyWithoutSnapshotsLogicalUsed" (optional.Int32) -  Filter by space.efficiency_without_snapshots.logical_used
 * @param "SpaceEfficiencyWithoutSnapshotsRatio" (optional.Float32) -  Filter by space.efficiency_without_snapshots.ratio
 * @param "SpaceEfficiencyWithoutSnapshotsSavings" (optional.Int32) -  Filter by space.efficiency_without_snapshots.savings
 * @param "SpaceBlockStorageFullThresholdPercent" (optional.Int32) -  Filter by space.block_storage.full_threshold_percent
 * @param "SpaceBlockStorageUsed" (optional.Int32) -  Filter by space.block_storage.used
 * @param "SpaceBlockStorageAvailable" (optional.Int32) -  Filter by space.block_storage.available
 * @param "SpaceBlockStorageSize" (optional.Int32) -  Filter by space.block_storage.size
 * @param "SpaceBlockStorageInactiveUserData" (optional.Int32) -  Filter by space.block_storage.inactive_user_data
 * @param "SpaceCloudStorageUsed" (optional.Int32) -  Filter by space.cloud_storage.used
 * @param "BlockStoragePrimaryRaidSize" (optional.Int32) -  Filter by block_storage.primary.raid_size
 * @param "BlockStoragePrimaryRaidType" (optional.String) -  Filter by block_storage.primary.raid_type
 * @param "BlockStoragePrimaryChecksumStyle" (optional.String) -  Filter by block_storage.primary.checksum_style
 * @param "BlockStoragePrimaryDiskClass" (optional.String) -  Filter by block_storage.primary.disk_class
 * @param "BlockStoragePrimaryDiskCount" (optional.Int32) -  Filter by block_storage.primary.disk_count
 * @param "BlockStoragePlexesName" (optional.String) -  Filter by block_storage.plexes.name
 * @param "BlockStorageHybridCacheRaidType" (optional.String) -  Filter by block_storage.hybrid_cache.raid_type
 * @param "BlockStorageHybridCacheUsed" (optional.Int32) -  Filter by block_storage.hybrid_cache.used
 * @param "BlockStorageHybridCacheEnabled" (optional.Bool) -  Filter by block_storage.hybrid_cache.enabled
 * @param "BlockStorageHybridCacheSize" (optional.Int32) -  Filter by block_storage.hybrid_cache.size
 * @param "BlockStorageHybridCacheDiskCount" (optional.Int32) -  Filter by block_storage.hybrid_cache.disk_count
 * @param "BlockStorageMirrorState" (optional.String) -  Filter by block_storage.mirror.state
 * @param "BlockStorageMirrorEnabled" (optional.Bool) -  Filter by block_storage.mirror.enabled
 * @param "DataEncryptionSoftwareEncryptionEnabled" (optional.Bool) -  Filter by data_encryption.software_encryption_enabled
 * @param "DataEncryptionDriveProtectionEnabled" (optional.Bool) -  Filter by data_encryption.drive_protection_enabled
 * @param "State" (optional.String) -  Filter by state
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return AggregateResponse
*/
func (a *StorageApiService) AggregateCollectionGet(ctx _context.Context, localVarOptionals *AggregateCollectionGetOpts) (AggregateResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AggregateResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/aggregates"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Recommend.IsSet() {
		localVarQueryParams.Add("recommend", parameterToString(localVarOptionals.Recommend.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ShowSpares.IsSet() {
		localVarQueryParams.Add("show_spares", parameterToString(localVarOptionals.ShowSpares.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnaplockType.IsSet() {
		localVarQueryParams.Add("snaplock_type", parameterToString(localVarOptionals.SnaplockType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HomeNodeUuid.IsSet() {
		localVarQueryParams.Add("home_node.uuid", parameterToString(localVarOptionals.HomeNodeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HomeNodeName.IsSet() {
		localVarQueryParams.Add("home_node.name", parameterToString(localVarOptionals.HomeNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NodeUuid.IsSet() {
		localVarQueryParams.Add("node.uuid", parameterToString(localVarOptionals.NodeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NodeName.IsSet() {
		localVarQueryParams.Add("node.name", parameterToString(localVarOptionals.NodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DrHomeNodeName.IsSet() {
		localVarQueryParams.Add("dr_home_node.name", parameterToString(localVarOptionals.DrHomeNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DrHomeNodeUuid.IsSet() {
		localVarQueryParams.Add("dr_home_node.uuid", parameterToString(localVarOptionals.DrHomeNodeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreateTime.IsSet() {
		localVarQueryParams.Add("create_time", parameterToString(localVarOptionals.CreateTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceEfficiencyLogicalUsed.IsSet() {
		localVarQueryParams.Add("space.efficiency.logical_used", parameterToString(localVarOptionals.SpaceEfficiencyLogicalUsed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceEfficiencyRatio.IsSet() {
		localVarQueryParams.Add("space.efficiency.ratio", parameterToString(localVarOptionals.SpaceEfficiencyRatio.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceEfficiencySavings.IsSet() {
		localVarQueryParams.Add("space.efficiency.savings", parameterToString(localVarOptionals.SpaceEfficiencySavings.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceFootprint.IsSet() {
		localVarQueryParams.Add("space.footprint", parameterToString(localVarOptionals.SpaceFootprint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceEfficiencyWithoutSnapshotsLogicalUsed.IsSet() {
		localVarQueryParams.Add("space.efficiency_without_snapshots.logical_used", parameterToString(localVarOptionals.SpaceEfficiencyWithoutSnapshotsLogicalUsed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceEfficiencyWithoutSnapshotsRatio.IsSet() {
		localVarQueryParams.Add("space.efficiency_without_snapshots.ratio", parameterToString(localVarOptionals.SpaceEfficiencyWithoutSnapshotsRatio.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceEfficiencyWithoutSnapshotsSavings.IsSet() {
		localVarQueryParams.Add("space.efficiency_without_snapshots.savings", parameterToString(localVarOptionals.SpaceEfficiencyWithoutSnapshotsSavings.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceBlockStorageFullThresholdPercent.IsSet() {
		localVarQueryParams.Add("space.block_storage.full_threshold_percent", parameterToString(localVarOptionals.SpaceBlockStorageFullThresholdPercent.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceBlockStorageUsed.IsSet() {
		localVarQueryParams.Add("space.block_storage.used", parameterToString(localVarOptionals.SpaceBlockStorageUsed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceBlockStorageAvailable.IsSet() {
		localVarQueryParams.Add("space.block_storage.available", parameterToString(localVarOptionals.SpaceBlockStorageAvailable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceBlockStorageSize.IsSet() {
		localVarQueryParams.Add("space.block_storage.size", parameterToString(localVarOptionals.SpaceBlockStorageSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceBlockStorageInactiveUserData.IsSet() {
		localVarQueryParams.Add("space.block_storage.inactive_user_data", parameterToString(localVarOptionals.SpaceBlockStorageInactiveUserData.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceCloudStorageUsed.IsSet() {
		localVarQueryParams.Add("space.cloud_storage.used", parameterToString(localVarOptionals.SpaceCloudStorageUsed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BlockStoragePrimaryRaidSize.IsSet() {
		localVarQueryParams.Add("block_storage.primary.raid_size", parameterToString(localVarOptionals.BlockStoragePrimaryRaidSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BlockStoragePrimaryRaidType.IsSet() {
		localVarQueryParams.Add("block_storage.primary.raid_type", parameterToString(localVarOptionals.BlockStoragePrimaryRaidType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BlockStoragePrimaryChecksumStyle.IsSet() {
		localVarQueryParams.Add("block_storage.primary.checksum_style", parameterToString(localVarOptionals.BlockStoragePrimaryChecksumStyle.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BlockStoragePrimaryDiskClass.IsSet() {
		localVarQueryParams.Add("block_storage.primary.disk_class", parameterToString(localVarOptionals.BlockStoragePrimaryDiskClass.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BlockStoragePrimaryDiskCount.IsSet() {
		localVarQueryParams.Add("block_storage.primary.disk_count", parameterToString(localVarOptionals.BlockStoragePrimaryDiskCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BlockStoragePlexesName.IsSet() {
		localVarQueryParams.Add("block_storage.plexes.name", parameterToString(localVarOptionals.BlockStoragePlexesName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BlockStorageHybridCacheRaidType.IsSet() {
		localVarQueryParams.Add("block_storage.hybrid_cache.raid_type", parameterToString(localVarOptionals.BlockStorageHybridCacheRaidType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BlockStorageHybridCacheUsed.IsSet() {
		localVarQueryParams.Add("block_storage.hybrid_cache.used", parameterToString(localVarOptionals.BlockStorageHybridCacheUsed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BlockStorageHybridCacheEnabled.IsSet() {
		localVarQueryParams.Add("block_storage.hybrid_cache.enabled", parameterToString(localVarOptionals.BlockStorageHybridCacheEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BlockStorageHybridCacheSize.IsSet() {
		localVarQueryParams.Add("block_storage.hybrid_cache.size", parameterToString(localVarOptionals.BlockStorageHybridCacheSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BlockStorageHybridCacheDiskCount.IsSet() {
		localVarQueryParams.Add("block_storage.hybrid_cache.disk_count", parameterToString(localVarOptionals.BlockStorageHybridCacheDiskCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BlockStorageMirrorState.IsSet() {
		localVarQueryParams.Add("block_storage.mirror.state", parameterToString(localVarOptionals.BlockStorageMirrorState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BlockStorageMirrorEnabled.IsSet() {
		localVarQueryParams.Add("block_storage.mirror.enabled", parameterToString(localVarOptionals.BlockStorageMirrorEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DataEncryptionSoftwareEncryptionEnabled.IsSet() {
		localVarQueryParams.Add("data_encryption.software_encryption_enabled", parameterToString(localVarOptionals.DataEncryptionSoftwareEncryptionEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DataEncryptionDriveProtectionEnabled.IsSet() {
		localVarQueryParams.Add("data_encryption.drive_protection_enabled", parameterToString(localVarOptionals.DataEncryptionDriveProtectionEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v AggregateResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// AggregateCreateOpts Optional parameters for the method 'AggregateCreate'
type AggregateCreateOpts struct {
	DiskSize optional.Int32
	Info     optional.Interface
}

/*
AggregateCreate Method for AggregateCreate
Automatically creates aggregates based on an optimal layout recommended by the system. Alternatively, properties can be provided to create an aggregate according to the requested specification. This request starts a job and returns a link to that job. ### Required properties Properties are not required for this API. The following properties are only required if you want to specify properties for aggregate creation: * &#x60;name&#x60; - Name of the aggregate. * &#x60;node.name&#x60; or &#x60;node.uuid&#x60; - Node on which the aggregate will be created. * &#x60;block_storage.primary.disk_count&#x60; - Number of disks to be used to create the aggregate. ### Default values If not specified in POST, the following default values are assigned. The remaining unspecified properties will receive system dependent default values. * &#x60;block_storage.mirror.enabled&#x60; - _false_ * &#x60;snaplock_type&#x60; - _non_snaplock_ ### Related ONTAP commands * &#x60;storage aggregate auto-provision&#x60; * &#x60;storage aggregate create&#x60; ### Example: &#x60;&#x60;&#x60; POST /api/storage/aggregates {\&quot;node\&quot;: {\&quot;name\&quot;: \&quot;node1\&quot;}, \&quot;name\&quot;: \&quot;test\&quot;, \&quot;block_storage\&quot;: {\&quot;primary\&quot;: {\&quot;disk_count\&quot;: \&quot;10\&quot;}}} &#x60;&#x60;&#x60;  ### Learn more * [&#x60;DOC /storage/aggregates&#x60;](#docs-storage-storage_aggregates)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *AggregateCreateOpts - Optional Parameters:
 * @param "DiskSize" (optional.Int32) -  If set, POST only selects disks of the specified size.
 * @param "Info" (optional.Interface of Aggregate) -  Info specification
@return JobLinkResponse
*/
func (a *StorageApiService) AggregateCreate(ctx _context.Context, localVarOptionals *AggregateCreateOpts) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/aggregates"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.DiskSize.IsSet() {
		localVarQueryParams.Add("disk_size", parameterToString(localVarOptionals.DiskSize.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(Aggregate)
		if !localVarOptionalInfook {
			return localVarReturnValue, nil, reportError("info should be Aggregate")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
AggregateDelete Method for AggregateDelete
Deletes the aggregate specified by the UUID. This request starts a job and returns a link to that job. ### Related ONTAP commands * &#x60;storage aggregate delete&#x60;  ### Learn more * [&#x60;DOC /storage/aggregates&#x60;](#docs-storage-storage_aggregates)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Aggregate UUID
@return JobLinkResponse
*/
func (a *StorageApiService) AggregateDelete(ctx _context.Context, uuid string) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/aggregates/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// AggregateGetOpts Optional parameters for the method 'AggregateGet'
type AggregateGetOpts struct {
	Fields optional.Interface
}

/*
AggregateGet Method for AggregateGet
Retrieves the aggregate specified by the UUID. The recommend query cannot be used for this operation. ### Expensive properties There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the &#x60;fields&#x60; query parameter. See [&#x60;DOC Requesting specific fields&#x60;](#docs-docs-Requesting-specific-fields) to learn more. * &#x60;space.block_storage.inactive_user_data&#x60; * &#x60;space.footprint&#x60; ### Related ONTAP commands * &#x60;storage aggregate show&#x60;  ### Learn more * [&#x60;DOC /storage/aggregates&#x60;](#docs-storage-storage_aggregates)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Aggregate UUID
 * @param optional nil or *AggregateGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return Aggregate
*/
func (a *StorageApiService) AggregateGet(ctx _context.Context, uuid string, localVarOptionals *AggregateGetOpts) (Aggregate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Aggregate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/aggregates/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Aggregate
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// AggregateModifyOpts Optional parameters for the method 'AggregateModify'
type AggregateModifyOpts struct {
	DiskSize optional.Int32
	Info     optional.Interface
}

/*
AggregateModify Method for AggregateModify
Updates the aggregate specified by the UUID with the properties in the body. This request starts a job and returns a link to that job. ### Related ONTAP commands * &#x60;storage aggregate add-disks&#x60; * &#x60;storage aggregate mirror&#x60; * &#x60;storage aggregate modify&#x60; * &#x60;storage aggregate relocation start&#x60; * &#x60;storage aggregate rename&#x60;  ### Learn more * [&#x60;DOC /storage/aggregates&#x60;](#docs-storage-storage_aggregates)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Aggregate UUID
 * @param optional nil or *AggregateModifyOpts - Optional Parameters:
 * @param "DiskSize" (optional.Int32) -  If set, PATCH only selects disks of the specified size.
 * @param "Info" (optional.Interface of Aggregate) -  Info specification
@return JobLinkResponse
*/
func (a *StorageApiService) AggregateModify(ctx _context.Context, uuid string, localVarOptionals *AggregateModifyOpts) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/aggregates/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.DiskSize.IsSet() {
		localVarQueryParams.Add("disk_size", parameterToString(localVarOptionals.DiskSize.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(Aggregate)
		if !localVarOptionalInfook {
			return localVarReturnValue, nil, reportError("info should be Aggregate")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// CloudStoreCollectionGetOpts Optional parameters for the method 'CloudStoreCollectionGet'
type CloudStoreCollectionGetOpts struct {
	MirrorDegraded            optional.Bool
	TargetName                optional.String
	TargetUuid                optional.String
	Used                      optional.Int32
	Availability              optional.String
	UnreclaimedSpaceThreshold optional.Int32
	Primary                   optional.Bool
	Fields                    optional.Interface
	MaxRecords                optional.Int32
	ReturnRecords             optional.Bool
	ReturnTimeout             optional.Int32
	OrderBy                   optional.Interface
}

/*
CloudStoreCollectionGet Method for CloudStoreCollectionGet
Retrieves the collection of cloud stores used by an aggregate. ### Related ONTAP commands * &#x60;storage aggregate object-store show&#x60;
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param aggregateUuid Aggregate UUID
 * @param optional nil or *CloudStoreCollectionGetOpts - Optional Parameters:
 * @param "MirrorDegraded" (optional.Bool) -  Filter by mirror_degraded
 * @param "TargetName" (optional.String) -  Filter by target.name
 * @param "TargetUuid" (optional.String) -  Filter by target.uuid
 * @param "Used" (optional.Int32) -  Filter by used
 * @param "Availability" (optional.String) -  Filter by availability
 * @param "UnreclaimedSpaceThreshold" (optional.Int32) -  Filter by unreclaimed_space_threshold
 * @param "Primary" (optional.Bool) -  Filter by primary
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return CloudStoreResponse
*/
func (a *StorageApiService) CloudStoreCollectionGet(ctx _context.Context, aggregateUuid string, localVarOptionals *CloudStoreCollectionGetOpts) (CloudStoreResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CloudStoreResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/aggregates/{aggregate.uuid}/cloud-stores"
	localVarPath = strings.Replace(localVarPath, "{"+"aggregate.uuid"+"}", _neturl.QueryEscape(parameterToString(aggregateUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.MirrorDegraded.IsSet() {
		localVarQueryParams.Add("mirror_degraded", parameterToString(localVarOptionals.MirrorDegraded.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TargetName.IsSet() {
		localVarQueryParams.Add("target.name", parameterToString(localVarOptionals.TargetName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TargetUuid.IsSet() {
		localVarQueryParams.Add("target.uuid", parameterToString(localVarOptionals.TargetUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Used.IsSet() {
		localVarQueryParams.Add("used", parameterToString(localVarOptionals.Used.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Availability.IsSet() {
		localVarQueryParams.Add("availability", parameterToString(localVarOptionals.Availability.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UnreclaimedSpaceThreshold.IsSet() {
		localVarQueryParams.Add("unreclaimed_space_threshold", parameterToString(localVarOptionals.UnreclaimedSpaceThreshold.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Primary.IsSet() {
		localVarQueryParams.Add("primary", parameterToString(localVarOptionals.Primary.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v CloudStoreResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// CloudStoreCreateOpts Optional parameters for the method 'CloudStoreCreate'
type CloudStoreCreateOpts struct {
	AllowFlexgroups optional.Bool
	CheckOnly       optional.Bool
	Info            optional.Interface
}

/*
CloudStoreCreate Method for CloudStoreCreate
Attaches an object store to an aggregate, or adds a second object store as a mirror. ### Required properties * &#x60;target.uuid&#x60; or &#x60;target.name&#x60; - UUID or name of the cloud target. ### Recommended optional properties * &#x60;primary&#x60; - _true_ if the object store is primary or _false_ if it is a mirror. * &#x60;allow_flexgroups&#x60; - Allow attaching object store to an aggregate containing FlexGroup constituents. * &#x60;check_only&#x60; - Validate only and do not add the cloud store. ### Default property values * &#x60;primary&#x60; - _true_ * &#x60;allow_flexgroups&#x60; - _false_ * &#x60;check_only&#x60; - _false_ ### Related ONTAP commands * &#x60;storage aggregate object-store attach&#x60; * &#x60;storage aggregate object-store mirror&#x60;
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param aggregateUuid Aggregate UUID
 * @param optional nil or *CloudStoreCreateOpts - Optional Parameters:
 * @param "AllowFlexgroups" (optional.Bool) -  This optional parameter allows attaching object store to an aggregate containing FlexGroup constituents. The default value is false. Mixing FabricPools and non-FabricPools within a FlexGroup is not recommended. All aggregates hosting constituents of a FlexGroup should be attached to the object store.
 * @param "CheckOnly" (optional.Bool) -  Validate only and do not add the cloud store.
 * @param "Info" (optional.Interface of CloudStore) -  Info specification
@return JobLinkResponse
*/
func (a *StorageApiService) CloudStoreCreate(ctx _context.Context, aggregateUuid string, localVarOptionals *CloudStoreCreateOpts) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/aggregates/{aggregate.uuid}/cloud-stores"
	localVarPath = strings.Replace(localVarPath, "{"+"aggregate.uuid"+"}", _neturl.QueryEscape(parameterToString(aggregateUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.AllowFlexgroups.IsSet() {
		localVarQueryParams.Add("allow_flexgroups", parameterToString(localVarOptionals.AllowFlexgroups.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CheckOnly.IsSet() {
		localVarQueryParams.Add("check_only", parameterToString(localVarOptionals.CheckOnly.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(CloudStore)
		if !localVarOptionalInfook {
			return localVarReturnValue, nil, reportError("info should be CloudStore")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
CloudStoreDelete Method for CloudStoreDelete
Removes the specified cloud target from the aggregate. Only removal of a mirror is allowed. The primary cannot be removed. This request starts a job and returns a link to that job. ### Related ONTAP commands * &#x60;storage aggregate object-store unmirror&#x60;
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param aggregateUuid Aggregate UUID
 * @param targetUuid Cloud target UUID
@return JobLinkResponse
*/
func (a *StorageApiService) CloudStoreDelete(ctx _context.Context, aggregateUuid string, targetUuid string) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/aggregates/{aggregate.uuid}/cloud-stores/{target.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"aggregate.uuid"+"}", _neturl.QueryEscape(parameterToString(aggregateUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"target.uuid"+"}", _neturl.QueryEscape(parameterToString(targetUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// CloudStoreGetOpts Optional parameters for the method 'CloudStoreGet'
type CloudStoreGetOpts struct {
	Fields optional.Interface
}

/*
CloudStoreGet Method for CloudStoreGet
Retrieves the cloud store for the aggregate using the specified cloud target UUID. ### Related ONTAP commands * &#x60;storage aggregate object-store show&#x60;
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param aggregateUuid Aggregate UUID
 * @param targetUuid Cloud target UUID
 * @param optional nil or *CloudStoreGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return CloudStoreResponse
*/
func (a *StorageApiService) CloudStoreGet(ctx _context.Context, aggregateUuid string, targetUuid string, localVarOptionals *CloudStoreGetOpts) (CloudStoreResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CloudStoreResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/aggregates/{aggregate.uuid}/cloud-stores/{target.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"aggregate.uuid"+"}", _neturl.QueryEscape(parameterToString(aggregateUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"target.uuid"+"}", _neturl.QueryEscape(parameterToString(targetUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v CloudStoreResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// CloudStoreModifyOpts Optional parameters for the method 'CloudStoreModify'
type CloudStoreModifyOpts struct {
	Info optional.Interface
}

/*
CloudStoreModify Method for CloudStoreModify
Updates the cloud store specified by the UUID with the fields in the body. This request starts a job and returns a link to that job. ### Related ONTAP commands * &#x60;storage aggregate object-store modify&#x60;
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param aggregateUuid Aggregate UUID
 * @param targetUuid Cloud target UUID
 * @param optional nil or *CloudStoreModifyOpts - Optional Parameters:
 * @param "Info" (optional.Interface of CloudStore) -  Info specification
@return JobLinkResponse
*/
func (a *StorageApiService) CloudStoreModify(ctx _context.Context, aggregateUuid string, targetUuid string, localVarOptionals *CloudStoreModifyOpts) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/aggregates/{aggregate.uuid}/cloud-stores/{target.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"aggregate.uuid"+"}", _neturl.QueryEscape(parameterToString(aggregateUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"target.uuid"+"}", _neturl.QueryEscape(parameterToString(targetUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(CloudStore)
		if !localVarOptionalInfook {
			return localVarReturnValue, nil, reportError("info should be CloudStore")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// DiskCollectionGetOpts Optional parameters for the method 'DiskCollectionGet'
type DiskCollectionGetOpts struct {
	Rpm                  optional.Int32
	SerialNumber         optional.String
	ContainerType        optional.String
	Uid                  optional.String
	Vendor               optional.String
	FirmwareVersion      optional.String
	ShelfUid             optional.String
	Pool                 optional.String
	State                optional.String
	Class                optional.String
	AggregatesUuid       optional.String
	AggregatesName       optional.String
	Bay                  optional.String
	DrawerId             optional.Int32
	DrawerSlot           optional.Int32
	UsableSize           optional.Int32
	Model                optional.String
	Type_                optional.String
	NodeUuid             optional.String
	NodeName             optional.String
	HomeNodeUuid         optional.String
	HomeNodeName         optional.String
	DrNodeName           optional.String
	DrNodeUuid           optional.String
	Name                 optional.String
	RatedLifeUsedPercent optional.Int32
	Fields               optional.Interface
	MaxRecords           optional.Int32
	ReturnRecords        optional.Bool
	ReturnTimeout        optional.Int32
	OrderBy              optional.Interface
}

/*
DiskCollectionGet Method for DiskCollectionGet
Retrieves a collection of disks. ### Related ONTAP commands * &#x60;storage disk show&#x60; ### Learn more * [&#x60;DOC /storage/disks&#x60;](#docs-storage-storage_disks)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DiskCollectionGetOpts - Optional Parameters:
 * @param "Rpm" (optional.Int32) -  Filter by rpm
 * @param "SerialNumber" (optional.String) -  Filter by serial_number
 * @param "ContainerType" (optional.String) -  Filter by container_type
 * @param "Uid" (optional.String) -  Filter by uid
 * @param "Vendor" (optional.String) -  Filter by vendor
 * @param "FirmwareVersion" (optional.String) -  Filter by firmware_version
 * @param "ShelfUid" (optional.String) -  Filter by shelf.uid
 * @param "Pool" (optional.String) -  Filter by pool
 * @param "State" (optional.String) -  Filter by state
 * @param "Class" (optional.String) -  Filter by class
 * @param "AggregatesUuid" (optional.String) -  Filter by aggregates.uuid
 * @param "AggregatesName" (optional.String) -  Filter by aggregates.name
 * @param "Bay" (optional.String) -  Filter by bay
 * @param "DrawerId" (optional.Int32) -  Filter by drawer.id
 * @param "DrawerSlot" (optional.Int32) -  Filter by drawer.slot
 * @param "UsableSize" (optional.Int32) -  Filter by usable_size
 * @param "Model" (optional.String) -  Filter by model
 * @param "Type_" (optional.String) -  Filter by type
 * @param "NodeUuid" (optional.String) -  Filter by node.uuid
 * @param "NodeName" (optional.String) -  Filter by node.name
 * @param "HomeNodeUuid" (optional.String) -  Filter by home_node.uuid
 * @param "HomeNodeName" (optional.String) -  Filter by home_node.name
 * @param "DrNodeName" (optional.String) -  Filter by dr_node.name
 * @param "DrNodeUuid" (optional.String) -  Filter by dr_node.uuid
 * @param "Name" (optional.String) -  Filter by name
 * @param "RatedLifeUsedPercent" (optional.Int32) -  Filter by rated_life_used_percent
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return DiskResponse
*/
func (a *StorageApiService) DiskCollectionGet(ctx _context.Context, localVarOptionals *DiskCollectionGetOpts) (DiskResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DiskResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/disks"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Rpm.IsSet() {
		localVarQueryParams.Add("rpm", parameterToString(localVarOptionals.Rpm.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SerialNumber.IsSet() {
		localVarQueryParams.Add("serial_number", parameterToString(localVarOptionals.SerialNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContainerType.IsSet() {
		localVarQueryParams.Add("container_type", parameterToString(localVarOptionals.ContainerType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uid.IsSet() {
		localVarQueryParams.Add("uid", parameterToString(localVarOptionals.Uid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Vendor.IsSet() {
		localVarQueryParams.Add("vendor", parameterToString(localVarOptionals.Vendor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FirmwareVersion.IsSet() {
		localVarQueryParams.Add("firmware_version", parameterToString(localVarOptionals.FirmwareVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ShelfUid.IsSet() {
		localVarQueryParams.Add("shelf.uid", parameterToString(localVarOptionals.ShelfUid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Pool.IsSet() {
		localVarQueryParams.Add("pool", parameterToString(localVarOptionals.Pool.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Class.IsSet() {
		localVarQueryParams.Add("class", parameterToString(localVarOptionals.Class.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AggregatesUuid.IsSet() {
		localVarQueryParams.Add("aggregates.uuid", parameterToString(localVarOptionals.AggregatesUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AggregatesName.IsSet() {
		localVarQueryParams.Add("aggregates.name", parameterToString(localVarOptionals.AggregatesName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Bay.IsSet() {
		localVarQueryParams.Add("bay", parameterToString(localVarOptionals.Bay.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DrawerId.IsSet() {
		localVarQueryParams.Add("drawer.id", parameterToString(localVarOptionals.DrawerId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DrawerSlot.IsSet() {
		localVarQueryParams.Add("drawer.slot", parameterToString(localVarOptionals.DrawerSlot.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UsableSize.IsSet() {
		localVarQueryParams.Add("usable_size", parameterToString(localVarOptionals.UsableSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Model.IsSet() {
		localVarQueryParams.Add("model", parameterToString(localVarOptionals.Model.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NodeUuid.IsSet() {
		localVarQueryParams.Add("node.uuid", parameterToString(localVarOptionals.NodeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NodeName.IsSet() {
		localVarQueryParams.Add("node.name", parameterToString(localVarOptionals.NodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HomeNodeUuid.IsSet() {
		localVarQueryParams.Add("home_node.uuid", parameterToString(localVarOptionals.HomeNodeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HomeNodeName.IsSet() {
		localVarQueryParams.Add("home_node.name", parameterToString(localVarOptionals.HomeNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DrNodeName.IsSet() {
		localVarQueryParams.Add("dr_node.name", parameterToString(localVarOptionals.DrNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DrNodeUuid.IsSet() {
		localVarQueryParams.Add("dr_node.uuid", parameterToString(localVarOptionals.DrNodeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RatedLifeUsedPercent.IsSet() {
		localVarQueryParams.Add("rated_life_used_percent", parameterToString(localVarOptionals.RatedLifeUsedPercent.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v DiskResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// DiskGetOpts Optional parameters for the method 'DiskGet'
type DiskGetOpts struct {
	Fields optional.Interface
}

/*
DiskGet Method for DiskGet
Retrieves a specific disk. ### Related ONTAP commands * &#x60;storage disk show&#x60; ### Learn more * [&#x60;DOC /storage/disks&#x60;](#docs-storage-storage_disks)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Disk name
 * @param optional nil or *DiskGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return Disk
*/
func (a *StorageApiService) DiskGet(ctx _context.Context, name string, localVarOptionals *DiskGetOpts) (Disk, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Disk
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/disks/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.QueryEscape(parameterToString(name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Disk
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// FileCloneCreateOpts Optional parameters for the method 'FileCloneCreate'
type FileCloneCreateOpts struct {
	Info optional.Interface
}

/*
FileCloneCreate Method for FileCloneCreate
Creates a clone of the file.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *FileCloneCreateOpts - Optional Parameters:
 * @param "Info" (optional.Interface of FileClone) -  Info specification
@return JobLinkResponse
*/
func (a *StorageApiService) FileCloneCreate(ctx _context.Context, localVarOptionals *FileCloneCreateOpts) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/file/clone"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(FileClone)
		if !localVarOptionalInfook {
			return localVarReturnValue, nil, reportError("info should be FileClone")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// FlexcacheCollectionGetOpts Optional parameters for the method 'FlexcacheCollectionGet'
type FlexcacheCollectionGetOpts struct {
	SvmUuid                  optional.String
	SvmName                  optional.String
	Name                     optional.String
	Size                     optional.Int32
	Path                     optional.String
	Uuid                     optional.String
	ConstituentsPerAggregate optional.Int32
	AggregatesUuid           optional.String
	AggregatesName           optional.String
	OriginsIpAddress         optional.String
	OriginsCreateTime        optional.String
	OriginsSvmUuid           optional.String
	OriginsSvmName           optional.String
	OriginsClusterUuid       optional.String
	OriginsClusterName       optional.String
	OriginsVolumeName        optional.String
	OriginsVolumeUuid        optional.String
	OriginsState             optional.String
	OriginsSize              optional.Int32
	ReturnTimeout            optional.Int32
	Fields                   optional.Interface
	MaxRecords               optional.Int32
	OrderBy                  optional.Interface
	ReturnRecords            optional.Bool
}

/*
FlexcacheCollectionGet Method for FlexcacheCollectionGet
Retrieves FlexCaches in the cluster. ### Expensive properties There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the &#x60;fields&#x60; query parameter. See [&#x60;DOC Requesting specific fields&#x60;](#docs-docs-Requesting-specific-fields) to learn more. * &#x60;origins.ip_address&#x60; - IP address of origin. * &#x60;origins.size&#x60; - Physical size of origin. * &#x60;origins.state&#x60; - State of origin. * &#x60;size&#x60; - Physical size of FlexCache. * &#x60;aggregates.name&#x60; or &#x60;aggregates.uuid&#x60; - Name or UUID of aggregrate of FlexCache volume. * &#x60;path&#x60; - Fully-qualified path of the owning SVM&#39;s namespace where the FlexCache is mounted. ### Related ONTAP commands * &#x60;volume flexcache show&#x60; ### Learn more * [&#x60;DOC /storage/flexcache/flexcaches&#x60;](#docs-storage-storage_flexcache_flexcaches)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *FlexcacheCollectionGetOpts - Optional Parameters:
 * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
 * @param "SvmName" (optional.String) -  Filter by svm.name
 * @param "Name" (optional.String) -  Filter by name
 * @param "Size" (optional.Int32) -  Filter by size
 * @param "Path" (optional.String) -  Filter by path
 * @param "Uuid" (optional.String) -  Filter by uuid
 * @param "ConstituentsPerAggregate" (optional.Int32) -  Filter by constituents_per_aggregate
 * @param "AggregatesUuid" (optional.String) -  Filter by aggregates.uuid
 * @param "AggregatesName" (optional.String) -  Filter by aggregates.name
 * @param "OriginsIpAddress" (optional.String) -  Filter by origins.ip_address
 * @param "OriginsCreateTime" (optional.String) -  Filter by origins.create_time
 * @param "OriginsSvmUuid" (optional.String) -  Filter by origins.svm.uuid
 * @param "OriginsSvmName" (optional.String) -  Filter by origins.svm.name
 * @param "OriginsClusterUuid" (optional.String) -  Filter by origins.cluster.uuid
 * @param "OriginsClusterName" (optional.String) -  Filter by origins.cluster.name
 * @param "OriginsVolumeName" (optional.String) -  Filter by origins.volume.name
 * @param "OriginsVolumeUuid" (optional.String) -  Filter by origins.volume.uuid
 * @param "OriginsState" (optional.String) -  Filter by origins.state
 * @param "OriginsSize" (optional.Int32) -  Filter by origins.size
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
@return FlexcacheResponse
*/
func (a *StorageApiService) FlexcacheCollectionGet(ctx _context.Context, localVarOptionals *FlexcacheCollectionGetOpts) (FlexcacheResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FlexcacheResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/flexcache/flexcaches"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Path.IsSet() {
		localVarQueryParams.Add("path", parameterToString(localVarOptionals.Path.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ConstituentsPerAggregate.IsSet() {
		localVarQueryParams.Add("constituents_per_aggregate", parameterToString(localVarOptionals.ConstituentsPerAggregate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AggregatesUuid.IsSet() {
		localVarQueryParams.Add("aggregates.uuid", parameterToString(localVarOptionals.AggregatesUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AggregatesName.IsSet() {
		localVarQueryParams.Add("aggregates.name", parameterToString(localVarOptionals.AggregatesName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OriginsIpAddress.IsSet() {
		localVarQueryParams.Add("origins.ip_address", parameterToString(localVarOptionals.OriginsIpAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OriginsCreateTime.IsSet() {
		localVarQueryParams.Add("origins.create_time", parameterToString(localVarOptionals.OriginsCreateTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OriginsSvmUuid.IsSet() {
		localVarQueryParams.Add("origins.svm.uuid", parameterToString(localVarOptionals.OriginsSvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OriginsSvmName.IsSet() {
		localVarQueryParams.Add("origins.svm.name", parameterToString(localVarOptionals.OriginsSvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OriginsClusterUuid.IsSet() {
		localVarQueryParams.Add("origins.cluster.uuid", parameterToString(localVarOptionals.OriginsClusterUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OriginsClusterName.IsSet() {
		localVarQueryParams.Add("origins.cluster.name", parameterToString(localVarOptionals.OriginsClusterName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OriginsVolumeName.IsSet() {
		localVarQueryParams.Add("origins.volume.name", parameterToString(localVarOptionals.OriginsVolumeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OriginsVolumeUuid.IsSet() {
		localVarQueryParams.Add("origins.volume.uuid", parameterToString(localVarOptionals.OriginsVolumeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OriginsState.IsSet() {
		localVarQueryParams.Add("origins.state", parameterToString(localVarOptionals.OriginsState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OriginsSize.IsSet() {
		localVarQueryParams.Add("origins.size", parameterToString(localVarOptionals.OriginsSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v FlexcacheResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
FlexcacheCreate Method for FlexcacheCreate
Creates a FlexCache in the cluster. ### Required properties * &#x60;name&#x60; - Name of FlexCache volume. * &#x60;origins.volume.name&#x60; or &#x60;origins.volume.uuid&#x60; - Name or UUID of origin volume. * &#x60;origins.svm.name&#x60; - Name of origin Vserver. * &#x60;svm.name&#x60; or &#x60;svm.uuid&#x60; - Name or UUID of Vserver where FlexCache will be created. ### Recommended optional properties * &#x60;path&#x60; - Path to mount the FlexCache volume ### Default property values If not specified in POST, the following default property values are assigned: * &#x60;size&#x60; - 10% of origin volume size or 1GB per constituent, whichever is greater. * &#x60;constituents_per_aggregate&#x60; - 4 if aggregates.name or aggregates.uuid is used. ### Related ONTAP commands * &#x60;volume flexcache create&#x60; ### Learn more * [&#x60;DOC /storage/flexcache/flexcaches&#x60;](#docs-storage-storage_flexcache_flexcaches)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info Info specification
@return JobLinkResponse
*/
func (a *StorageApiService) FlexcacheCreate(ctx _context.Context, info Flexcache) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/flexcache/flexcaches"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
FlexcacheDelete Method for FlexcacheDelete
Deletes a FlexCache. If a FlexCache volume is online, it is offlined before deletion. ### Related ONTAP commands * &#x60;volume flexcache delete&#x60; ### Learn more * [&#x60;DOC /storage/flexcache/flexcaches&#x60;](#docs-storage-storage_flexcache_flexcaches)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Unique identifier of the FlexCache.
@return JobLinkResponse
*/
func (a *StorageApiService) FlexcacheDelete(ctx _context.Context, uuid string) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/flexcache/flexcaches/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// FlexcacheGetOpts Optional parameters for the method 'FlexcacheGet'
type FlexcacheGetOpts struct {
	Fields optional.Interface
}

/*
FlexcacheGet Method for FlexcacheGet
Retrieves attributes of the FlexCache in the cluster. ### Expensive properties There is an added cost to retrieving values for these properties. They are included by default in GET. The recommended method to use this API is to use filter and retrieve only the required fields. See [&#x60;DOC Requesting specific fields&#x60;](#docs-docs-Requesting-specific-fields) to learn more. * &#x60;origins.ip_address&#x60; - IP address of origin. * &#x60;origins.size&#x60; - Physical size of origin. * &#x60;origins.state&#x60; - State of origin. * &#x60;size&#x60; - Physical size of FlexCache. * &#x60;aggregates.name&#x60; or &#x60;aggregates.uuid&#x60; - Name or UUID of aggregrate of FlexCache volume. * &#x60;path&#x60; - Fully-qualified path of the owning SVM&#39;s namespace where the FlexCache is mounted. ### Related ONTAP commands * &#x60;volume flexcache show&#x60; ### Learn more * [&#x60;DOC /storage/flexcache/flexcaches&#x60;](#docs-storage-storage_flexcache_flexcaches)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Unique identifier of FlexCache.
 * @param optional nil or *FlexcacheGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return Flexcache
*/
func (a *StorageApiService) FlexcacheGet(ctx _context.Context, uuid string, localVarOptionals *FlexcacheGetOpts) (Flexcache, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Flexcache
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/flexcache/flexcaches/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Flexcache
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// FlexcacheOriginCollectionGetOpts Optional parameters for the method 'FlexcacheOriginCollectionGet'
type FlexcacheOriginCollectionGetOpts struct {
	SvmUuid               optional.String
	SvmName               optional.String
	Name                  optional.String
	Uuid                  optional.String
	FlexcachesIpAddress   optional.String
	FlexcachesCreateTime  optional.String
	FlexcachesSvmUuid     optional.String
	FlexcachesSvmName     optional.String
	FlexcachesClusterUuid optional.String
	FlexcachesClusterName optional.String
	FlexcachesVolumeName  optional.String
	FlexcachesVolumeUuid  optional.String
	FlexcachesState       optional.String
	FlexcachesSize        optional.Int32
	ReturnTimeout         optional.Int32
	Fields                optional.Interface
	MaxRecords            optional.Int32
	OrderBy               optional.Interface
	ReturnRecords         optional.Bool
}

/*
FlexcacheOriginCollectionGet Method for FlexcacheOriginCollectionGet
Retrieves origin of FlexCaches in the cluster. ### Expensive properties There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the &#x60;fields&#x60; query parameter. See [&#x60;DOC Requesting specific fields&#x60;](#docs-docs-Requesting-specific-fields) to learn more. * &#x60;flexcaches.ip_address&#x60; - IP address of FlexCache. * &#x60;flexcaches.size&#x60; - Physical size of FlexCache. * &#x60;flexcaches.state&#x60; - State of FlexCache. ### Related ONTAP commands * &#x60;volume flexcache origin show-caches&#x60; ### Learn more * [&#x60;DOC /storage/flexcache/origins&#x60;](#docs-storage-storage_flexcache_origins)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *FlexcacheOriginCollectionGetOpts - Optional Parameters:
 * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
 * @param "SvmName" (optional.String) -  Filter by svm.name
 * @param "Name" (optional.String) -  Filter by name
 * @param "Uuid" (optional.String) -  Filter by uuid
 * @param "FlexcachesIpAddress" (optional.String) -  Filter by flexcaches.ip_address
 * @param "FlexcachesCreateTime" (optional.String) -  Filter by flexcaches.create_time
 * @param "FlexcachesSvmUuid" (optional.String) -  Filter by flexcaches.svm.uuid
 * @param "FlexcachesSvmName" (optional.String) -  Filter by flexcaches.svm.name
 * @param "FlexcachesClusterUuid" (optional.String) -  Filter by flexcaches.cluster.uuid
 * @param "FlexcachesClusterName" (optional.String) -  Filter by flexcaches.cluster.name
 * @param "FlexcachesVolumeName" (optional.String) -  Filter by flexcaches.volume.name
 * @param "FlexcachesVolumeUuid" (optional.String) -  Filter by flexcaches.volume.uuid
 * @param "FlexcachesState" (optional.String) -  Filter by flexcaches.state
 * @param "FlexcachesSize" (optional.Int32) -  Filter by flexcaches.size
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
@return FlexcacheOriginResponse
*/
func (a *StorageApiService) FlexcacheOriginCollectionGet(ctx _context.Context, localVarOptionals *FlexcacheOriginCollectionGetOpts) (FlexcacheOriginResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FlexcacheOriginResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/flexcache/origins"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FlexcachesIpAddress.IsSet() {
		localVarQueryParams.Add("flexcaches.ip_address", parameterToString(localVarOptionals.FlexcachesIpAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FlexcachesCreateTime.IsSet() {
		localVarQueryParams.Add("flexcaches.create_time", parameterToString(localVarOptionals.FlexcachesCreateTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FlexcachesSvmUuid.IsSet() {
		localVarQueryParams.Add("flexcaches.svm.uuid", parameterToString(localVarOptionals.FlexcachesSvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FlexcachesSvmName.IsSet() {
		localVarQueryParams.Add("flexcaches.svm.name", parameterToString(localVarOptionals.FlexcachesSvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FlexcachesClusterUuid.IsSet() {
		localVarQueryParams.Add("flexcaches.cluster.uuid", parameterToString(localVarOptionals.FlexcachesClusterUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FlexcachesClusterName.IsSet() {
		localVarQueryParams.Add("flexcaches.cluster.name", parameterToString(localVarOptionals.FlexcachesClusterName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FlexcachesVolumeName.IsSet() {
		localVarQueryParams.Add("flexcaches.volume.name", parameterToString(localVarOptionals.FlexcachesVolumeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FlexcachesVolumeUuid.IsSet() {
		localVarQueryParams.Add("flexcaches.volume.uuid", parameterToString(localVarOptionals.FlexcachesVolumeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FlexcachesState.IsSet() {
		localVarQueryParams.Add("flexcaches.state", parameterToString(localVarOptionals.FlexcachesState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FlexcachesSize.IsSet() {
		localVarQueryParams.Add("flexcaches.size", parameterToString(localVarOptionals.FlexcachesSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v FlexcacheOriginResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// FlexcacheOriginGetOpts Optional parameters for the method 'FlexcacheOriginGet'
type FlexcacheOriginGetOpts struct {
	Fields optional.Interface
}

/*
FlexcacheOriginGet Method for FlexcacheOriginGet
Retrieves attributes of the origin of a FlexCache in the cluster. ### Expensive properties There is an added cost to retrieving values for these properties. They are included by default in GET results. The recommended method to use this API is to use filter and retrieve only the required fields. See [&#x60;DOC Requesting specific fields&#x60;](#docs-docs-Requesting-specific-fields) to learn more. * &#x60;flexcaches.ip_address&#x60; - IP address of FlexCache. * &#x60;flexcaches.size&#x60; - Physical size of FlexCache. * &#x60;flexcaches.state&#x60; - State of FlexCache. ### Related ONTAP commands * &#x60;volume flexcache origin show-caches&#x60; ### Learn more * [&#x60;DOC /storage/flexcache/origins&#x60;](#docs-storage-storage_flexcache_origins)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Unique identifier of origin of FlexCache.
 * @param optional nil or *FlexcacheOriginGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return FlexcacheOrigin
*/
func (a *StorageApiService) FlexcacheOriginGet(ctx _context.Context, uuid string, localVarOptionals *FlexcacheOriginGetOpts) (FlexcacheOrigin, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FlexcacheOrigin
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/flexcache/origins/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v FlexcacheOrigin
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// PlexCollectionGetOpts Optional parameters for the method 'PlexCollectionGet'
type PlexCollectionGetOpts struct {
	AggregateUuid2 optional.String
	AggregateName  optional.String
	ResyncPercent  optional.Int32
	ResyncLevel    optional.String
	ResyncActive   optional.Bool
	Online         optional.Bool
	State          optional.String
	Pool           optional.String
	Fields         optional.Interface
	MaxRecords     optional.Int32
	ReturnRecords  optional.Bool
	ReturnTimeout  optional.Int32
	OrderBy        optional.Interface
}

/*
PlexCollectionGet Method for PlexCollectionGet
Retrieves the collection of plexes for the specified aggregate. ### Related ONTAP commands * &#x60;storage aggregate plex show&#x60;  ### Learn more * [&#x60;DOC /storage/aggregates/{aggregate.uuid}/plexes&#x60;](#docs-storage-storage_aggregates_{aggregate.uuid}_plexes)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param aggregateUuid Aggregate UUID
 * @param name Filter by name
 * @param optional nil or *PlexCollectionGetOpts - Optional Parameters:
 * @param "AggregateUuid2" (optional.String) -  Filter by aggregate.uuid
 * @param "AggregateName" (optional.String) -  Filter by aggregate.name
 * @param "ResyncPercent" (optional.Int32) -  Filter by resync.percent
 * @param "ResyncLevel" (optional.String) -  Filter by resync.level
 * @param "ResyncActive" (optional.Bool) -  Filter by resync.active
 * @param "Online" (optional.Bool) -  Filter by online
 * @param "State" (optional.String) -  Filter by state
 * @param "Pool" (optional.String) -  Filter by pool
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return PlexResponse
*/
func (a *StorageApiService) PlexCollectionGet(ctx _context.Context, aggregateUuid string, name string, localVarOptionals *PlexCollectionGetOpts) (PlexResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PlexResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/aggregates/{aggregate.uuid}/plexes"
	localVarPath = strings.Replace(localVarPath, "{"+"aggregate.uuid"+"}", _neturl.QueryEscape(parameterToString(aggregateUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.QueryEscape(parameterToString(name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.AggregateUuid2.IsSet() {
		localVarQueryParams.Add("aggregate.uuid", parameterToString(localVarOptionals.AggregateUuid2.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AggregateName.IsSet() {
		localVarQueryParams.Add("aggregate.name", parameterToString(localVarOptionals.AggregateName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ResyncPercent.IsSet() {
		localVarQueryParams.Add("resync.percent", parameterToString(localVarOptionals.ResyncPercent.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ResyncLevel.IsSet() {
		localVarQueryParams.Add("resync.level", parameterToString(localVarOptionals.ResyncLevel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ResyncActive.IsSet() {
		localVarQueryParams.Add("resync.active", parameterToString(localVarOptionals.ResyncActive.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Online.IsSet() {
		localVarQueryParams.Add("online", parameterToString(localVarOptionals.Online.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Pool.IsSet() {
		localVarQueryParams.Add("pool", parameterToString(localVarOptionals.Pool.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v PlexResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// PlexGetOpts Optional parameters for the method 'PlexGet'
type PlexGetOpts struct {
	Fields optional.Interface
}

/*
PlexGet Method for PlexGet
Retrieves the plex specified by the aggregate UUID and plex name. ### Related ONTAP commands * &#x60;storage aggregate plex show&#x60;  ### Learn more * [&#x60;DOC /storage/aggregates/{aggregate.uuid}/plexes&#x60;](#docs-storage-storage_aggregates_{aggregate.uuid}_plexes)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param aggregateUuid Aggregate UUID
 * @param name Plex name
 * @param optional nil or *PlexGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return Plex
*/
func (a *StorageApiService) PlexGet(ctx _context.Context, aggregateUuid string, name string, localVarOptionals *PlexGetOpts) (Plex, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Plex
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/aggregates/{aggregate.uuid}/plexes/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"aggregate.uuid"+"}", _neturl.QueryEscape(parameterToString(aggregateUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.QueryEscape(parameterToString(name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Plex
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// PortCollectionGetOpts Optional parameters for the method 'PortCollectionGet'
type PortCollectionGetOpts struct {
	Description           optional.String
	MacAddress            optional.String
	PartNumber            optional.String
	SerialNumber          optional.String
	NodeUuid              optional.String
	NodeName              optional.String
	ErrorMessage          optional.String
	ErrorCorrectiveAction optional.String
	BoardName             optional.String
	CableSerialNumber     optional.String
	CablePartNumber       optional.String
	CableLength           optional.String
	CableIdentifier       optional.String
	Name                  optional.String
	State                 optional.String
	Speed                 optional.Float32
	Wwn                   optional.String
	Fields                optional.Interface
	MaxRecords            optional.Int32
	ReturnRecords         optional.Bool
	ReturnTimeout         optional.Int32
	OrderBy               optional.Interface
}

/*
PortCollectionGet Method for PortCollectionGet
Retrieves a collection of storage ports. ### Related ONTAP commands * &#x60;storage port show&#x60; ### Learn more * [&#x60;DOC /storage/ports&#x60;](#docs-storage-storage_ports)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *PortCollectionGetOpts - Optional Parameters:
 * @param "Description" (optional.String) -  Filter by description
 * @param "MacAddress" (optional.String) -  Filter by mac_address
 * @param "PartNumber" (optional.String) -  Filter by part_number
 * @param "SerialNumber" (optional.String) -  Filter by serial_number
 * @param "NodeUuid" (optional.String) -  Filter by node.uuid
 * @param "NodeName" (optional.String) -  Filter by node.name
 * @param "ErrorMessage" (optional.String) -  Filter by error.message
 * @param "ErrorCorrectiveAction" (optional.String) -  Filter by error.corrective_action
 * @param "BoardName" (optional.String) -  Filter by board_name
 * @param "CableSerialNumber" (optional.String) -  Filter by cable.serial_number
 * @param "CablePartNumber" (optional.String) -  Filter by cable.part_number
 * @param "CableLength" (optional.String) -  Filter by cable.length
 * @param "CableIdentifier" (optional.String) -  Filter by cable.identifier
 * @param "Name" (optional.String) -  Filter by name
 * @param "State" (optional.String) -  Filter by state
 * @param "Speed" (optional.Float32) -  Filter by speed
 * @param "Wwn" (optional.String) -  Filter by wwn
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return StoragePortResponse
*/
func (a *StorageApiService) PortCollectionGet(ctx _context.Context, localVarOptionals *PortCollectionGetOpts) (StoragePortResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  StoragePortResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/ports"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddress.IsSet() {
		localVarQueryParams.Add("mac_address", parameterToString(localVarOptionals.MacAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PartNumber.IsSet() {
		localVarQueryParams.Add("part_number", parameterToString(localVarOptionals.PartNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SerialNumber.IsSet() {
		localVarQueryParams.Add("serial_number", parameterToString(localVarOptionals.SerialNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NodeUuid.IsSet() {
		localVarQueryParams.Add("node.uuid", parameterToString(localVarOptionals.NodeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NodeName.IsSet() {
		localVarQueryParams.Add("node.name", parameterToString(localVarOptionals.NodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ErrorMessage.IsSet() {
		localVarQueryParams.Add("error.message", parameterToString(localVarOptionals.ErrorMessage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ErrorCorrectiveAction.IsSet() {
		localVarQueryParams.Add("error.corrective_action", parameterToString(localVarOptionals.ErrorCorrectiveAction.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BoardName.IsSet() {
		localVarQueryParams.Add("board_name", parameterToString(localVarOptionals.BoardName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CableSerialNumber.IsSet() {
		localVarQueryParams.Add("cable.serial_number", parameterToString(localVarOptionals.CableSerialNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CablePartNumber.IsSet() {
		localVarQueryParams.Add("cable.part_number", parameterToString(localVarOptionals.CablePartNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CableLength.IsSet() {
		localVarQueryParams.Add("cable.length", parameterToString(localVarOptionals.CableLength.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CableIdentifier.IsSet() {
		localVarQueryParams.Add("cable.identifier", parameterToString(localVarOptionals.CableIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Speed.IsSet() {
		localVarQueryParams.Add("speed", parameterToString(localVarOptionals.Speed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Wwn.IsSet() {
		localVarQueryParams.Add("wwn", parameterToString(localVarOptionals.Wwn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v StoragePortResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// PortGetOpts Optional parameters for the method 'PortGet'
type PortGetOpts struct {
	Fields optional.Interface
}

/*
PortGet Method for PortGet
Retrieves a specific storage port. ### Related ONTAP commands * &#x60;storage port show&#x60; ### Learn more * [&#x60;DOC /storage/ports&#x60;](#docs-storage-storage_ports)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param nodeUuid Node UUID
 * @param name Port name
 * @param optional nil or *PortGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return StoragePort
*/
func (a *StorageApiService) PortGet(ctx _context.Context, nodeUuid string, name string, localVarOptionals *PortGetOpts) (StoragePort, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  StoragePort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/ports/{node.uuid}/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"node.uuid"+"}", _neturl.QueryEscape(parameterToString(nodeUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.QueryEscape(parameterToString(name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v StoragePort
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// QosPolicyCollectionGetOpts Optional parameters for the method 'QosPolicyCollectionGet'
type QosPolicyCollectionGetOpts struct {
	ObjectCount             optional.Int32
	AdaptiveExpectedIops    optional.Int32
	AdaptiveAbsoluteMinIops optional.Int32
	AdaptivePeakIops        optional.Int32
	Name                    optional.String
	FixedMaxThroughputIops  optional.Int32
	FixedCapacityShared     optional.Bool
	FixedMaxThroughputMbps  optional.Int32
	FixedMinThroughputIops  optional.Int32
	SvmUuid                 optional.String
	SvmName                 optional.String
	Uuid                    optional.String
	Fields                  optional.Interface
	MaxRecords              optional.Int32
	ReturnRecords           optional.Bool
	ReturnTimeout           optional.Int32
	OrderBy                 optional.Interface
}

/*
QosPolicyCollectionGet Method for QosPolicyCollectionGet
Retrieves a collection of QoS policies. ### Learn more * [&#x60;DOC /storage/qos/policies&#x60;](#docs-storage-storage_qos_policies)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *QosPolicyCollectionGetOpts - Optional Parameters:
 * @param "ObjectCount" (optional.Int32) -  Filter by object_count
 * @param "AdaptiveExpectedIops" (optional.Int32) -  Filter by adaptive.expected_iops
 * @param "AdaptiveAbsoluteMinIops" (optional.Int32) -  Filter by adaptive.absolute_min_iops
 * @param "AdaptivePeakIops" (optional.Int32) -  Filter by adaptive.peak_iops
 * @param "Name" (optional.String) -  Filter by name
 * @param "FixedMaxThroughputIops" (optional.Int32) -  Filter by fixed.max_throughput_iops
 * @param "FixedCapacityShared" (optional.Bool) -  Filter by fixed.capacity_shared
 * @param "FixedMaxThroughputMbps" (optional.Int32) -  Filter by fixed.max_throughput_mbps
 * @param "FixedMinThroughputIops" (optional.Int32) -  Filter by fixed.min_throughput_iops
 * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
 * @param "SvmName" (optional.String) -  Filter by svm.name
 * @param "Uuid" (optional.String) -  Filter by uuid
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return QosPolicyResponse
*/
func (a *StorageApiService) QosPolicyCollectionGet(ctx _context.Context, localVarOptionals *QosPolicyCollectionGetOpts) (QosPolicyResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  QosPolicyResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/qos/policies"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.ObjectCount.IsSet() {
		localVarQueryParams.Add("object_count", parameterToString(localVarOptionals.ObjectCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AdaptiveExpectedIops.IsSet() {
		localVarQueryParams.Add("adaptive.expected_iops", parameterToString(localVarOptionals.AdaptiveExpectedIops.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AdaptiveAbsoluteMinIops.IsSet() {
		localVarQueryParams.Add("adaptive.absolute_min_iops", parameterToString(localVarOptionals.AdaptiveAbsoluteMinIops.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AdaptivePeakIops.IsSet() {
		localVarQueryParams.Add("adaptive.peak_iops", parameterToString(localVarOptionals.AdaptivePeakIops.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FixedMaxThroughputIops.IsSet() {
		localVarQueryParams.Add("fixed.max_throughput_iops", parameterToString(localVarOptionals.FixedMaxThroughputIops.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FixedCapacityShared.IsSet() {
		localVarQueryParams.Add("fixed.capacity_shared", parameterToString(localVarOptionals.FixedCapacityShared.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FixedMaxThroughputMbps.IsSet() {
		localVarQueryParams.Add("fixed.max_throughput_mbps", parameterToString(localVarOptionals.FixedMaxThroughputMbps.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FixedMinThroughputIops.IsSet() {
		localVarQueryParams.Add("fixed.min_throughput_iops", parameterToString(localVarOptionals.FixedMinThroughputIops.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v QosPolicyResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// QosPolicyCreateOpts Optional parameters for the method 'QosPolicyCreate'
type QosPolicyCreateOpts struct {
	ReturnTimeout optional.Int32
	Info          optional.Interface
}

/*
QosPolicyCreate Method for QosPolicyCreate
Creates a QoS policy. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - The existing SVM owning the QoS policy. * &#x60;name&#x60; - The name of the QoS policy. * &#x60;fixed.*&#x60; or &#x60;adaptive.*&#x60; - Either of the fixed or adaptive parameters. ### Default property values * If &#x60;fixed.*&#x60; parameters are specified, then capacity.shared is set to false by default. ### Related ONTAP commands * &#x60;qos policy-group create&#x60; * &#x60;qos adaptive-policy-group create&#x60;  ### Learn more * [&#x60;DOC /storage/qos/policies&#x60;](#docs-storage-storage_qos_policies)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *QosPolicyCreateOpts - Optional Parameters:
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning. When doing a POST, PATCH, or DELETE operation on a single record, the default is 0 seconds.  This means that if an asynchronous operation is started, the server immediately returns HTTP code 202 (Accepted) along with a link to the job.  If a non-zero value is specified for POST, PATCH, or DELETE operations, ONTAP waits that length of time to see if the job completes so it can return something other than 202.
 * @param "Info" (optional.Interface of QosPolicy) -  Info specification
@return JobLinkResponse
*/
func (a *StorageApiService) QosPolicyCreate(ctx _context.Context, localVarOptionals *QosPolicyCreateOpts) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/qos/policies"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(QosPolicy)
		if !localVarOptionalInfook {
			return localVarReturnValue, nil, reportError("info should be QosPolicy")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// QosPolicyDeleteOpts Optional parameters for the method 'QosPolicyDelete'
type QosPolicyDeleteOpts struct {
	ReturnTimeout optional.Int32
}

/*
QosPolicyDelete Method for QosPolicyDelete
Deletes a QoS policy. All QoS workloads associated with the policy are removed. ### Related ONTAP commands * &#x60;qos policy-group delete&#x60; * &#x60;qos adaptive-policy-group delete&#x60;  ### Learn more * [&#x60;DOC /storage/qos/policies&#x60;](#docs-storage-storage_qos_policies)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyUuid
 * @param optional nil or *QosPolicyDeleteOpts - Optional Parameters:
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning. When doing a POST, PATCH, or DELETE operation on a single record, the default is 0 seconds.  This means that if an asynchronous operation is started, the server immediately returns HTTP code 202 (Accepted) along with a link to the job.  If a non-zero value is specified for POST, PATCH, or DELETE operations, ONTAP waits that length of time to see if the job completes so it can return something other than 202.
@return JobLinkResponse
*/
func (a *StorageApiService) QosPolicyDelete(ctx _context.Context, policyUuid string, localVarOptionals *QosPolicyDeleteOpts) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/qos/policies/{policy.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"policy.uuid"+"}", _neturl.QueryEscape(parameterToString(policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// QosPolicyGetOpts Optional parameters for the method 'QosPolicyGet'
type QosPolicyGetOpts struct {
	Fields optional.Interface
}

/*
QosPolicyGet Method for QosPolicyGet
Retrieves a specific QoS policy. ### Related ONTAP commands * &#x60;qos policy-group show&#x60; * &#x60;qos adaptive-policy-group show&#x60;  ### Learn more * [&#x60;DOC /storage/qos/policies&#x60;](#docs-storage-storage_qos_policies)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyUuid
 * @param optional nil or *QosPolicyGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return QosPolicy
*/
func (a *StorageApiService) QosPolicyGet(ctx _context.Context, policyUuid string, localVarOptionals *QosPolicyGetOpts) (QosPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  QosPolicy
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/qos/policies/{policy.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"policy.uuid"+"}", _neturl.QueryEscape(parameterToString(policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v QosPolicy
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// QosPolicyModifyOpts Optional parameters for the method 'QosPolicyModify'
type QosPolicyModifyOpts struct {
	ReturnTimeout optional.Int32
	Info          optional.Interface
}

/*
QosPolicyModify Method for QosPolicyModify
Update a specific QoS policy. ### Related ONTAP commands * &#x60;qos policy-group modify&#x60; * &#x60;qos adaptive-policy-group modify&#x60;  ### Learn more * [&#x60;DOC /storage/qos/policies&#x60;](#docs-storage-storage_qos_policies)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyUuid
 * @param optional nil or *QosPolicyModifyOpts - Optional Parameters:
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning. When doing a POST, PATCH, or DELETE operation on a single record, the default is 0 seconds.  This means that if an asynchronous operation is started, the server immediately returns HTTP code 202 (Accepted) along with a link to the job.  If a non-zero value is specified for POST, PATCH, or DELETE operations, ONTAP waits that length of time to see if the job completes so it can return something other than 202.
 * @param "Info" (optional.Interface of QosPolicy) -  Info specification
@return JobLinkResponse
*/
func (a *StorageApiService) QosPolicyModify(ctx _context.Context, policyUuid string, localVarOptionals *QosPolicyModifyOpts) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/qos/policies/{policy.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"policy.uuid"+"}", _neturl.QueryEscape(parameterToString(policyUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(QosPolicy)
		if !localVarOptionalInfook {
			return localVarReturnValue, nil, reportError("info should be QosPolicy")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// QtreeCollectionGetOpts Optional parameters for the method 'QtreeCollectionGet'
type QtreeCollectionGetOpts struct {
	Path             optional.String
	ExportPolicyName optional.String
	ExportPolicyId   optional.Int32
	VolumeName       optional.String
	VolumeUuid       optional.String
	Name             optional.String
	SvmUuid          optional.String
	SvmName          optional.String
	UnixPermissions  optional.Int32
	SecurityStyle    optional.String
	Id               optional.Int32
	Fields           optional.Interface
	MaxRecords       optional.Int32
	ReturnRecords    optional.Bool
	ReturnTimeout    optional.Int32
	OrderBy          optional.Interface
}

/*
QtreeCollectionGet Method for QtreeCollectionGet
Retrieves qtrees configured for all FlexVols or FlexGroup volumes. &lt;br/&gt; Use the &#x60;fields&#x60; query parameter to retrieve all properties of the qtree. If the &#x60;fields&#x60; query parameter is not used, then GET returns the qtree &#x60;name&#x60; and qtree &#x60;id&#x60; only. ### Related ONTAP commands * &#x60;qtree show&#x60;  ### Learn more * [&#x60;DOC /storage/qtrees&#x60;](#docs-storage-storage_qtrees)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *QtreeCollectionGetOpts - Optional Parameters:
 * @param "Path" (optional.String) -  Filter by path
 * @param "ExportPolicyName" (optional.String) -  Filter by export_policy.name
 * @param "ExportPolicyId" (optional.Int32) -  Filter by export_policy.id
 * @param "VolumeName" (optional.String) -  Filter by volume.name
 * @param "VolumeUuid" (optional.String) -  Filter by volume.uuid
 * @param "Name" (optional.String) -  Filter by name
 * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
 * @param "SvmName" (optional.String) -  Filter by svm.name
 * @param "UnixPermissions" (optional.Int32) -  Filter by unix_permissions
 * @param "SecurityStyle" (optional.String) -  Filter by security_style
 * @param "Id" (optional.Int32) -  Filter by id
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return QtreeResponse
*/
func (a *StorageApiService) QtreeCollectionGet(ctx _context.Context, localVarOptionals *QtreeCollectionGetOpts) (QtreeResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  QtreeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/qtrees"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Path.IsSet() {
		localVarQueryParams.Add("path", parameterToString(localVarOptionals.Path.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExportPolicyName.IsSet() {
		localVarQueryParams.Add("export_policy.name", parameterToString(localVarOptionals.ExportPolicyName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExportPolicyId.IsSet() {
		localVarQueryParams.Add("export_policy.id", parameterToString(localVarOptionals.ExportPolicyId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VolumeName.IsSet() {
		localVarQueryParams.Add("volume.name", parameterToString(localVarOptionals.VolumeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VolumeUuid.IsSet() {
		localVarQueryParams.Add("volume.uuid", parameterToString(localVarOptionals.VolumeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UnixPermissions.IsSet() {
		localVarQueryParams.Add("unix_permissions", parameterToString(localVarOptionals.UnixPermissions.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SecurityStyle.IsSet() {
		localVarQueryParams.Add("security_style", parameterToString(localVarOptionals.SecurityStyle.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v QtreeResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
QtreeCreate Method for QtreeCreate
Creates a qtree in a FlexVol or a FlexGroup volume. &lt;br/&gt; After a qtree is created, the new qtree is assigned an identifier. This identifier is obtained using a qtree GET request. This identifier is used in the API path for the qtree PATCH and DELETE operations. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the qtree. * &#x60;volume.uuid&#x60; or &#x60;volume.name&#x60; - Existing volume in which to create the qtree. * &#x60;name&#x60; - Name for the qtree. ### Recommended optional properties If not specified in POST, the values are inherited from the volume. * &#x60;security_style&#x60; - Security style for the qtree. * &#x60;unix_permissions&#x60; - UNIX permissions for the qtree. * &#x60;export_policy.name or export_policy.id&#x60; - Export policy of the SVM for the qtree. ### Related ONTAP commands * &#x60;qtree create&#x60;  ### Learn more * [&#x60;DOC /storage/qtrees&#x60;](#docs-storage-storage_qtrees)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info Info specification
@return JobLinkResponse
*/
func (a *StorageApiService) QtreeCreate(ctx _context.Context, info Qtree) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/qtrees"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
QtreeDelete Method for QtreeDelete
Deletes a qtree. ### Related ONTAP commands * &#x60;qtree delete&#x60;  ### Learn more * [&#x60;DOC /storage/qtrees&#x60;](#docs-storage-storage_qtrees)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param volumeUuid Volume UUID
 * @param id Qtree ID
@return JobLinkResponse
*/
func (a *StorageApiService) QtreeDelete(ctx _context.Context, volumeUuid string, id string) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/qtrees/{volume.uuid}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"volume.uuid"+"}", _neturl.QueryEscape(parameterToString(volumeUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// QtreeGetOpts Optional parameters for the method 'QtreeGet'
type QtreeGetOpts struct {
	Fields optional.Interface
}

/*
QtreeGet Method for QtreeGet
Retrieves properties for a specific qtree identified by the &#x60;volume.uuid&#x60; and the &#x60;id&#x60; in the api path. ### Related ONTAP commands * &#x60;qtree show&#x60;  ### Learn more * [&#x60;DOC /storage/qtrees&#x60;](#docs-storage-storage_qtrees)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param volumeUuid Volume UUID
 * @param id Qtree ID
 * @param optional nil or *QtreeGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return Qtree
*/
func (a *StorageApiService) QtreeGet(ctx _context.Context, volumeUuid string, id string, localVarOptionals *QtreeGetOpts) (Qtree, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Qtree
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/qtrees/{volume.uuid}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"volume.uuid"+"}", _neturl.QueryEscape(parameterToString(volumeUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Qtree
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
QtreeModify Method for QtreeModify
Updates properties for a specific qtree. ### Related ONTAP commands * &#x60;qtree modify&#x60; * &#x60;qtree rename&#x60;  ### Learn more * [&#x60;DOC /storage/qtrees&#x60;](#docs-storage-storage_qtrees)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param volumeUuid Volume UUID
 * @param id Qtree ID
 * @param info The new property values for the qtree.
@return JobLinkResponse
*/
func (a *StorageApiService) QtreeModify(ctx _context.Context, volumeUuid string, id string, info Qtree) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/qtrees/{volume.uuid}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"volume.uuid"+"}", _neturl.QueryEscape(parameterToString(volumeUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// QuotaReportCollectionGetOpts Optional parameters for the method 'QuotaReportCollectionGet'
type QuotaReportCollectionGetOpts struct {
	SvmUuid                   optional.String
	SvmName                   optional.String
	VolumeName                optional.String
	VolumeUuid                optional.String
	UsersId                   optional.String
	UsersName                 optional.String
	GroupId                   optional.String
	GroupName                 optional.String
	Type_                     optional.String
	FilesUsedTotal            optional.Int32
	FilesUsedHardLimitPercent optional.String
	FilesUsedSoftLimitPercent optional.String
	FilesHardLimit            optional.Int32
	FilesSoftLimit            optional.Int32
	SpaceSoftLimit            optional.Int32
	SpaceHardLimit            optional.Int32
	SpaceUsedSoftLimitPercent optional.String
	SpaceUsedTotal            optional.Int32
	SpaceUsedHardLimitPercent optional.String
	Index                     optional.Int32
	Specifier                 optional.String
	QtreeId                   optional.Int32
	QtreeName                 optional.String
	Fields                    optional.Interface
	MaxRecords                optional.Int32
	ReturnRecords             optional.Bool
	ReturnTimeout             optional.Int32
	OrderBy                   optional.Interface
}

/*
QuotaReportCollectionGet Method for QuotaReportCollectionGet
Retrieves the quota report records for all FlexVols and FlexGroup volumes. ### Related ONTAP commands * &#x60;quota report&#x60;  ### Learn more * [&#x60;DOC /storage/quota/reports&#x60;](#docs-storage-storage_quota_reports)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *QuotaReportCollectionGetOpts - Optional Parameters:
 * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
 * @param "SvmName" (optional.String) -  Filter by svm.name
 * @param "VolumeName" (optional.String) -  Filter by volume.name
 * @param "VolumeUuid" (optional.String) -  Filter by volume.uuid
 * @param "UsersId" (optional.String) -  Filter by users.id
 * @param "UsersName" (optional.String) -  Filter by users.name
 * @param "GroupId" (optional.String) -  Filter by group.id
 * @param "GroupName" (optional.String) -  Filter by group.name
 * @param "Type_" (optional.String) -  Filter by type
 * @param "FilesUsedTotal" (optional.Int32) -  Filter by files.used.total
 * @param "FilesUsedHardLimitPercent" (optional.String) -  Filter by files.used.hard_limit_percent
 * @param "FilesUsedSoftLimitPercent" (optional.String) -  Filter by files.used.soft_limit_percent
 * @param "FilesHardLimit" (optional.Int32) -  Filter by files.hard_limit
 * @param "FilesSoftLimit" (optional.Int32) -  Filter by files.soft_limit
 * @param "SpaceSoftLimit" (optional.Int32) -  Filter by space.soft_limit
 * @param "SpaceHardLimit" (optional.Int32) -  Filter by space.hard_limit
 * @param "SpaceUsedSoftLimitPercent" (optional.String) -  Filter by space.used.soft_limit_percent
 * @param "SpaceUsedTotal" (optional.Int32) -  Filter by space.used.total
 * @param "SpaceUsedHardLimitPercent" (optional.String) -  Filter by space.used.hard_limit_percent
 * @param "Index" (optional.Int32) -  Filter by index
 * @param "Specifier" (optional.String) -  Filter by specifier
 * @param "QtreeId" (optional.Int32) -  Filter by qtree.id
 * @param "QtreeName" (optional.String) -  Filter by qtree.name
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return QuotaReportResponse
*/
func (a *StorageApiService) QuotaReportCollectionGet(ctx _context.Context, localVarOptionals *QuotaReportCollectionGetOpts) (QuotaReportResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  QuotaReportResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/quota/reports"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VolumeName.IsSet() {
		localVarQueryParams.Add("volume.name", parameterToString(localVarOptionals.VolumeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VolumeUuid.IsSet() {
		localVarQueryParams.Add("volume.uuid", parameterToString(localVarOptionals.VolumeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UsersId.IsSet() {
		localVarQueryParams.Add("users.id", parameterToString(localVarOptionals.UsersId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UsersName.IsSet() {
		localVarQueryParams.Add("users.name", parameterToString(localVarOptionals.UsersName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.GroupId.IsSet() {
		localVarQueryParams.Add("group.id", parameterToString(localVarOptionals.GroupId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.GroupName.IsSet() {
		localVarQueryParams.Add("group.name", parameterToString(localVarOptionals.GroupName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FilesUsedTotal.IsSet() {
		localVarQueryParams.Add("files.used.total", parameterToString(localVarOptionals.FilesUsedTotal.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FilesUsedHardLimitPercent.IsSet() {
		localVarQueryParams.Add("files.used.hard_limit_percent", parameterToString(localVarOptionals.FilesUsedHardLimitPercent.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FilesUsedSoftLimitPercent.IsSet() {
		localVarQueryParams.Add("files.used.soft_limit_percent", parameterToString(localVarOptionals.FilesUsedSoftLimitPercent.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FilesHardLimit.IsSet() {
		localVarQueryParams.Add("files.hard_limit", parameterToString(localVarOptionals.FilesHardLimit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FilesSoftLimit.IsSet() {
		localVarQueryParams.Add("files.soft_limit", parameterToString(localVarOptionals.FilesSoftLimit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceSoftLimit.IsSet() {
		localVarQueryParams.Add("space.soft_limit", parameterToString(localVarOptionals.SpaceSoftLimit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceHardLimit.IsSet() {
		localVarQueryParams.Add("space.hard_limit", parameterToString(localVarOptionals.SpaceHardLimit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceUsedSoftLimitPercent.IsSet() {
		localVarQueryParams.Add("space.used.soft_limit_percent", parameterToString(localVarOptionals.SpaceUsedSoftLimitPercent.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceUsedTotal.IsSet() {
		localVarQueryParams.Add("space.used.total", parameterToString(localVarOptionals.SpaceUsedTotal.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceUsedHardLimitPercent.IsSet() {
		localVarQueryParams.Add("space.used.hard_limit_percent", parameterToString(localVarOptionals.SpaceUsedHardLimitPercent.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Index.IsSet() {
		localVarQueryParams.Add("index", parameterToString(localVarOptionals.Index.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Specifier.IsSet() {
		localVarQueryParams.Add("specifier", parameterToString(localVarOptionals.Specifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QtreeId.IsSet() {
		localVarQueryParams.Add("qtree.id", parameterToString(localVarOptionals.QtreeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QtreeName.IsSet() {
		localVarQueryParams.Add("qtree.name", parameterToString(localVarOptionals.QtreeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v QuotaReportResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// QuotaReportGetOpts Optional parameters for the method 'QuotaReportGet'
type QuotaReportGetOpts struct {
	Fields optional.Interface
}

/*
QuotaReportGet Method for QuotaReportGet
Retrieves a specific quota report record. ### Related ONTAP commands * &#x60;quota report&#x60;  ### Learn more * [&#x60;DOC /storage/quota/reports&#x60;](#docs-storage-storage_quota_reports)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param volumeUuid Volume UUID
 * @param index Quota report index
 * @param optional nil or *QuotaReportGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return QuotaReport
*/
func (a *StorageApiService) QuotaReportGet(ctx _context.Context, volumeUuid string, index int32, localVarOptionals *QuotaReportGetOpts) (QuotaReport, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  QuotaReport
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/quota/reports/{volume.uuid}/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"volume.uuid"+"}", _neturl.QueryEscape(parameterToString(volumeUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", _neturl.QueryEscape(parameterToString(index, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v QuotaReport
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// QuotaRuleCollectionGetOpts Optional parameters for the method 'QuotaRuleCollectionGet'
type QuotaRuleCollectionGetOpts struct {
	SvmUuid        optional.String
	SvmName        optional.String
	VolumeName     optional.String
	VolumeUuid     optional.String
	Uuid           optional.String
	GroupName      optional.String
	GroupId        optional.String
	Type_          optional.String
	UsersName      optional.String
	UsersId        optional.String
	UserMapping    optional.Bool
	FilesHardLimit optional.Int32
	FilesSoftLimit optional.Int32
	SpaceSoftLimit optional.Int32
	SpaceHardLimit optional.Int32
	QtreeId        optional.Int32
	QtreeName      optional.String
	Fields         optional.Interface
	MaxRecords     optional.Int32
	ReturnRecords  optional.Bool
	ReturnTimeout  optional.Int32
	OrderBy        optional.Interface
}

/*
QuotaRuleCollectionGet Method for QuotaRuleCollectionGet
Retrieves quota policy rules configured for all FlexVols and FlexGroup volumes. ### Related ONTAP commands * &#x60;quota policy rule show&#x60;  ### Learn more * [&#x60;DOC /storage/quota/rules&#x60;](#docs-storage-storage_quota_rules)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *QuotaRuleCollectionGetOpts - Optional Parameters:
 * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
 * @param "SvmName" (optional.String) -  Filter by svm.name
 * @param "VolumeName" (optional.String) -  Filter by volume.name
 * @param "VolumeUuid" (optional.String) -  Filter by volume.uuid
 * @param "Uuid" (optional.String) -  Filter by uuid
 * @param "GroupName" (optional.String) -  Filter by group.name
 * @param "GroupId" (optional.String) -  Filter by group.id
 * @param "Type_" (optional.String) -  Filter by type
 * @param "UsersName" (optional.String) -  Filter by users.name
 * @param "UsersId" (optional.String) -  Filter by users.id
 * @param "UserMapping" (optional.Bool) -  Filter by user_mapping
 * @param "FilesHardLimit" (optional.Int32) -  Filter by files.hard_limit
 * @param "FilesSoftLimit" (optional.Int32) -  Filter by files.soft_limit
 * @param "SpaceSoftLimit" (optional.Int32) -  Filter by space.soft_limit
 * @param "SpaceHardLimit" (optional.Int32) -  Filter by space.hard_limit
 * @param "QtreeId" (optional.Int32) -  Filter by qtree.id
 * @param "QtreeName" (optional.String) -  Filter by qtree.name
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return QuotaRuleResponse
*/
func (a *StorageApiService) QuotaRuleCollectionGet(ctx _context.Context, localVarOptionals *QuotaRuleCollectionGetOpts) (QuotaRuleResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  QuotaRuleResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/quota/rules"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VolumeName.IsSet() {
		localVarQueryParams.Add("volume.name", parameterToString(localVarOptionals.VolumeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VolumeUuid.IsSet() {
		localVarQueryParams.Add("volume.uuid", parameterToString(localVarOptionals.VolumeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.GroupName.IsSet() {
		localVarQueryParams.Add("group.name", parameterToString(localVarOptionals.GroupName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.GroupId.IsSet() {
		localVarQueryParams.Add("group.id", parameterToString(localVarOptionals.GroupId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UsersName.IsSet() {
		localVarQueryParams.Add("users.name", parameterToString(localVarOptionals.UsersName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UsersId.IsSet() {
		localVarQueryParams.Add("users.id", parameterToString(localVarOptionals.UsersId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserMapping.IsSet() {
		localVarQueryParams.Add("user_mapping", parameterToString(localVarOptionals.UserMapping.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FilesHardLimit.IsSet() {
		localVarQueryParams.Add("files.hard_limit", parameterToString(localVarOptionals.FilesHardLimit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FilesSoftLimit.IsSet() {
		localVarQueryParams.Add("files.soft_limit", parameterToString(localVarOptionals.FilesSoftLimit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceSoftLimit.IsSet() {
		localVarQueryParams.Add("space.soft_limit", parameterToString(localVarOptionals.SpaceSoftLimit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceHardLimit.IsSet() {
		localVarQueryParams.Add("space.hard_limit", parameterToString(localVarOptionals.SpaceHardLimit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QtreeId.IsSet() {
		localVarQueryParams.Add("qtree.id", parameterToString(localVarOptionals.QtreeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QtreeName.IsSet() {
		localVarQueryParams.Add("qtree.name", parameterToString(localVarOptionals.QtreeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v QuotaRuleResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
QuotaRuleCreate Method for QuotaRuleCreate
Creates a quota policy rule for a FlexVol or a FlexGroup volume.&lt;br/&gt; Important notes: * Unlike CLI/ONTAPI, the &#x60;quota policy&#x60; input is not needed for POST. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the qtree. * &#x60;volume.uuid&#x60; or &#x60;volume.name&#x60; - Existing volume in which to create the qtree. * &#x60;type&#x60; - Quota type for the rule. This type can be &#x60;user&#x60;, &#x60;group&#x60;, or &#x60;tree&#x60;. * &#x60;users.name&#x60; or &#x60;user.id&#x60; -  If the quota type is user, this property takes the user name or user ID. For default user quota rules, the user name must be specified as \&quot;\&quot;. * &#x60;group.name&#x60; or &#x60;group.id&#x60; - If the quota type is group, this property takes the group name or group ID. For default group quota rules, the group name must be specified as \&quot;\&quot;. * &#x60;qtree.name&#x60; - Qtree for which to create the rule. For default tree rules, the qtree name must be specified as \&quot;\&quot;. ### Recommended optional properties * &#x60;space.hard_limit&#x60; - Specifies the space hard limit, in bytes. If less than 1024 bytes, the value is rounded up to 1024 bytes. * &#x60;space.soft_limit&#x60; - Specifies the space soft limit, in bytes. If less than 1024 bytes, the value is rounded up to 1024 bytes. * &#x60;files.hard_limit&#x60; - Specifies the hard limit for files. * &#x60;files.hard_limit&#x60; - Specifies the soft limit for files. * &#x60;user_mapping&#x60; - Specifies the user_mapping. This property is valid only for quota policy rules of type &#x60;user&#x60;. ### Related ONTAP commands * &#x60;quota policy rule create&#x60;  ### Learn more * [&#x60;DOC /storage/quota/rules&#x60;](#docs-storage-storage_quota_rules)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info Info specification
@return JobLinkResponse
*/
func (a *StorageApiService) QuotaRuleCreate(ctx _context.Context, info QuotaRule) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/quota/rules"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
QuotaRuleDelete Method for QuotaRuleDelete
Deletes a quota policy rule. ### Related ONTAP commands * &#x60;quota policy rule delete&#x60;  ### Learn more * [&#x60;DOC /storage/quota/rules&#x60;](#docs-storage-storage_quota_rules)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param ruleUuid Rule UUID
@return JobLinkResponse
*/
func (a *StorageApiService) QuotaRuleDelete(ctx _context.Context, ruleUuid string) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/quota/rules/{rule.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"rule.uuid"+"}", _neturl.QueryEscape(parameterToString(ruleUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// QuotaRuleGetOpts Optional parameters for the method 'QuotaRuleGet'
type QuotaRuleGetOpts struct {
	Fields optional.Interface
}

/*
QuotaRuleGet Method for QuotaRuleGet
Retrieves properties for a specific quota policy rule. ### Related ONTAP commands * &#x60;quota policy rule show&#x60;  ### Learn more * [&#x60;DOC /storage/quota/rules&#x60;](#docs-storage-storage_quota_rules)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param ruleUuid Rule UUID
 * @param optional nil or *QuotaRuleGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return QuotaRule
*/
func (a *StorageApiService) QuotaRuleGet(ctx _context.Context, ruleUuid string, localVarOptionals *QuotaRuleGetOpts) (QuotaRule, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  QuotaRule
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/quota/rules/{rule.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"rule.uuid"+"}", _neturl.QueryEscape(parameterToString(ruleUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v QuotaRule
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// QuotaRuleModifyOpts Optional parameters for the method 'QuotaRuleModify'
type QuotaRuleModifyOpts struct {
	Info optional.Interface
}

/*
QuotaRuleModify Method for QuotaRuleModify
Updates properties of a specific quota policy rule. &lt;br&gt; Important notes: * The quota resize functionality is supported with the PATCH operation. * Quota resize allows you to modify the quota limits, directly in the filesystem. * The quota must be enabled on a FlexVol or a FlexGroup volume for &#x60;quota resize&#x60; to take effect. * If the quota is disabled on the volume, the quota policy rule PATCH API modifies the rule, but this does not affect the limits in the filesystem. ### Related ONTAP commands * &#x60;quota policy rule modify&#x60; * &#x60;quota resize&#x60;  ### Learn more * [&#x60;DOC /storage/quota/rules&#x60;](#docs-storage-storage_quota_rules)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param ruleUuid Rule UUID
 * @param optional nil or *QuotaRuleModifyOpts - Optional Parameters:
 * @param "Info" (optional.Interface of QuotaRule) -  Info specification
@return JobLinkResponse
*/
func (a *StorageApiService) QuotaRuleModify(ctx _context.Context, ruleUuid string, localVarOptionals *QuotaRuleModifyOpts) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/quota/rules/{rule.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"rule.uuid"+"}", _neturl.QueryEscape(parameterToString(ruleUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(QuotaRule)
		if !localVarOptionalInfook {
			return localVarReturnValue, nil, reportError("info should be QuotaRule")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ShelfCollectionGetOpts Optional parameters for the method 'ShelfCollectionGet'
type ShelfCollectionGetOpts struct {
	PortsMacAddress        optional.String
	PortsInternal          optional.Bool
	PortsCableIdentifier   optional.String
	PortsCableLength       optional.String
	PortsCableSerialNumber optional.String
	PortsCablePartNumber   optional.String
	PortsModuleId          optional.String
	PortsState             optional.String
	PortsDesignator        optional.String
	PortsRemoteChassis     optional.String
	PortsRemoteWwn         optional.String
	PortsRemotePhy         optional.String
	PortsRemoteMacAddress  optional.String
	PortsRemotePort        optional.String
	PortsId                optional.Int32
	PortsWwn               optional.String
	Model                  optional.String
	Id                     optional.String
	State                  optional.String
	DiskCount              optional.Int32
	ModuleType             optional.String
	DrawersState           optional.String
	DrawersSerialNumber    optional.String
	DrawersDiskCount       optional.Int32
	DrawersPartNumber      optional.String
	DrawersError           optional.String
	DrawersId              optional.Int32
	DrawersClosed          optional.Bool
	Name                   optional.String
	ConnectionType         optional.String
	PathsName              optional.String
	PathsNodeUuid          optional.String
	PathsNodeName          optional.String
	Uid                    optional.String
	BaysId                 optional.Int32
	BaysHasDisk            optional.Bool
	BaysType               optional.String
	BaysState              optional.String
	Internal               optional.Bool
	FrusSerialNumber       optional.String
	FrusState              optional.String
	FrusPartNumber         optional.String
	FrusType               optional.String
	FrusFirmwareVersion    optional.String
	FrusId                 optional.Int32
	SerialNumber           optional.String
	Fields                 optional.Interface
	MaxRecords             optional.Int32
	ReturnRecords          optional.Bool
	ReturnTimeout          optional.Int32
	OrderBy                optional.Interface
}

/*
ShelfCollectionGet Method for ShelfCollectionGet
Retrieves a collection of shelves. ### Related ONTAP commands * &#x60;storage shelf show&#x60; * &#x60;storage shelf port show&#x60; * &#x60;storage shelf drawer show&#x60; ### Learn more * [&#x60;DOC /storage/shelves&#x60;](#docs-storage-storage_shelves)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ShelfCollectionGetOpts - Optional Parameters:
 * @param "PortsMacAddress" (optional.String) -  Filter by ports.mac_address
 * @param "PortsInternal" (optional.Bool) -  Filter by ports.internal
 * @param "PortsCableIdentifier" (optional.String) -  Filter by ports.cable.identifier
 * @param "PortsCableLength" (optional.String) -  Filter by ports.cable.length
 * @param "PortsCableSerialNumber" (optional.String) -  Filter by ports.cable.serial_number
 * @param "PortsCablePartNumber" (optional.String) -  Filter by ports.cable.part_number
 * @param "PortsModuleId" (optional.String) -  Filter by ports.module_id
 * @param "PortsState" (optional.String) -  Filter by ports.state
 * @param "PortsDesignator" (optional.String) -  Filter by ports.designator
 * @param "PortsRemoteChassis" (optional.String) -  Filter by ports.remote.chassis
 * @param "PortsRemoteWwn" (optional.String) -  Filter by ports.remote.wwn
 * @param "PortsRemotePhy" (optional.String) -  Filter by ports.remote.phy
 * @param "PortsRemoteMacAddress" (optional.String) -  Filter by ports.remote.mac_address
 * @param "PortsRemotePort" (optional.String) -  Filter by ports.remote.port
 * @param "PortsId" (optional.Int32) -  Filter by ports.id
 * @param "PortsWwn" (optional.String) -  Filter by ports.wwn
 * @param "Model" (optional.String) -  Filter by model
 * @param "Id" (optional.String) -  Filter by id
 * @param "State" (optional.String) -  Filter by state
 * @param "DiskCount" (optional.Int32) -  Filter by disk_count
 * @param "ModuleType" (optional.String) -  Filter by module_type
 * @param "DrawersState" (optional.String) -  Filter by drawers.state
 * @param "DrawersSerialNumber" (optional.String) -  Filter by drawers.serial_number
 * @param "DrawersDiskCount" (optional.Int32) -  Filter by drawers.disk_count
 * @param "DrawersPartNumber" (optional.String) -  Filter by drawers.part_number
 * @param "DrawersError" (optional.String) -  Filter by drawers.error
 * @param "DrawersId" (optional.Int32) -  Filter by drawers.id
 * @param "DrawersClosed" (optional.Bool) -  Filter by drawers.closed
 * @param "Name" (optional.String) -  Filter by name
 * @param "ConnectionType" (optional.String) -  Filter by connection_type
 * @param "PathsName" (optional.String) -  Filter by paths.name
 * @param "PathsNodeUuid" (optional.String) -  Filter by paths.node.uuid
 * @param "PathsNodeName" (optional.String) -  Filter by paths.node.name
 * @param "Uid" (optional.String) -  Filter by uid
 * @param "BaysId" (optional.Int32) -  Filter by bays.id
 * @param "BaysHasDisk" (optional.Bool) -  Filter by bays.has_disk
 * @param "BaysType" (optional.String) -  Filter by bays.type
 * @param "BaysState" (optional.String) -  Filter by bays.state
 * @param "Internal" (optional.Bool) -  Filter by internal
 * @param "FrusSerialNumber" (optional.String) -  Filter by frus.serial_number
 * @param "FrusState" (optional.String) -  Filter by frus.state
 * @param "FrusPartNumber" (optional.String) -  Filter by frus.part_number
 * @param "FrusType" (optional.String) -  Filter by frus.type
 * @param "FrusFirmwareVersion" (optional.String) -  Filter by frus.firmware_version
 * @param "FrusId" (optional.Int32) -  Filter by frus.id
 * @param "SerialNumber" (optional.String) -  Filter by serial_number
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return ShelfResponse
*/
func (a *StorageApiService) ShelfCollectionGet(ctx _context.Context, localVarOptionals *ShelfCollectionGetOpts) (ShelfResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ShelfResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/shelves"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.PortsMacAddress.IsSet() {
		localVarQueryParams.Add("ports.mac_address", parameterToString(localVarOptionals.PortsMacAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortsInternal.IsSet() {
		localVarQueryParams.Add("ports.internal", parameterToString(localVarOptionals.PortsInternal.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortsCableIdentifier.IsSet() {
		localVarQueryParams.Add("ports.cable.identifier", parameterToString(localVarOptionals.PortsCableIdentifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortsCableLength.IsSet() {
		localVarQueryParams.Add("ports.cable.length", parameterToString(localVarOptionals.PortsCableLength.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortsCableSerialNumber.IsSet() {
		localVarQueryParams.Add("ports.cable.serial_number", parameterToString(localVarOptionals.PortsCableSerialNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortsCablePartNumber.IsSet() {
		localVarQueryParams.Add("ports.cable.part_number", parameterToString(localVarOptionals.PortsCablePartNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortsModuleId.IsSet() {
		localVarQueryParams.Add("ports.module_id", parameterToString(localVarOptionals.PortsModuleId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortsState.IsSet() {
		localVarQueryParams.Add("ports.state", parameterToString(localVarOptionals.PortsState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortsDesignator.IsSet() {
		localVarQueryParams.Add("ports.designator", parameterToString(localVarOptionals.PortsDesignator.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortsRemoteChassis.IsSet() {
		localVarQueryParams.Add("ports.remote.chassis", parameterToString(localVarOptionals.PortsRemoteChassis.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortsRemoteWwn.IsSet() {
		localVarQueryParams.Add("ports.remote.wwn", parameterToString(localVarOptionals.PortsRemoteWwn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortsRemotePhy.IsSet() {
		localVarQueryParams.Add("ports.remote.phy", parameterToString(localVarOptionals.PortsRemotePhy.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortsRemoteMacAddress.IsSet() {
		localVarQueryParams.Add("ports.remote.mac_address", parameterToString(localVarOptionals.PortsRemoteMacAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortsRemotePort.IsSet() {
		localVarQueryParams.Add("ports.remote.port", parameterToString(localVarOptionals.PortsRemotePort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortsId.IsSet() {
		localVarQueryParams.Add("ports.id", parameterToString(localVarOptionals.PortsId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortsWwn.IsSet() {
		localVarQueryParams.Add("ports.wwn", parameterToString(localVarOptionals.PortsWwn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Model.IsSet() {
		localVarQueryParams.Add("model", parameterToString(localVarOptionals.Model.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DiskCount.IsSet() {
		localVarQueryParams.Add("disk_count", parameterToString(localVarOptionals.DiskCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ModuleType.IsSet() {
		localVarQueryParams.Add("module_type", parameterToString(localVarOptionals.ModuleType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DrawersState.IsSet() {
		localVarQueryParams.Add("drawers.state", parameterToString(localVarOptionals.DrawersState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DrawersSerialNumber.IsSet() {
		localVarQueryParams.Add("drawers.serial_number", parameterToString(localVarOptionals.DrawersSerialNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DrawersDiskCount.IsSet() {
		localVarQueryParams.Add("drawers.disk_count", parameterToString(localVarOptionals.DrawersDiskCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DrawersPartNumber.IsSet() {
		localVarQueryParams.Add("drawers.part_number", parameterToString(localVarOptionals.DrawersPartNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DrawersError.IsSet() {
		localVarQueryParams.Add("drawers.error", parameterToString(localVarOptionals.DrawersError.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DrawersId.IsSet() {
		localVarQueryParams.Add("drawers.id", parameterToString(localVarOptionals.DrawersId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DrawersClosed.IsSet() {
		localVarQueryParams.Add("drawers.closed", parameterToString(localVarOptionals.DrawersClosed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ConnectionType.IsSet() {
		localVarQueryParams.Add("connection_type", parameterToString(localVarOptionals.ConnectionType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PathsName.IsSet() {
		localVarQueryParams.Add("paths.name", parameterToString(localVarOptionals.PathsName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PathsNodeUuid.IsSet() {
		localVarQueryParams.Add("paths.node.uuid", parameterToString(localVarOptionals.PathsNodeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PathsNodeName.IsSet() {
		localVarQueryParams.Add("paths.node.name", parameterToString(localVarOptionals.PathsNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uid.IsSet() {
		localVarQueryParams.Add("uid", parameterToString(localVarOptionals.Uid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BaysId.IsSet() {
		localVarQueryParams.Add("bays.id", parameterToString(localVarOptionals.BaysId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BaysHasDisk.IsSet() {
		localVarQueryParams.Add("bays.has_disk", parameterToString(localVarOptionals.BaysHasDisk.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BaysType.IsSet() {
		localVarQueryParams.Add("bays.type", parameterToString(localVarOptionals.BaysType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BaysState.IsSet() {
		localVarQueryParams.Add("bays.state", parameterToString(localVarOptionals.BaysState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Internal.IsSet() {
		localVarQueryParams.Add("internal", parameterToString(localVarOptionals.Internal.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FrusSerialNumber.IsSet() {
		localVarQueryParams.Add("frus.serial_number", parameterToString(localVarOptionals.FrusSerialNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FrusState.IsSet() {
		localVarQueryParams.Add("frus.state", parameterToString(localVarOptionals.FrusState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FrusPartNumber.IsSet() {
		localVarQueryParams.Add("frus.part_number", parameterToString(localVarOptionals.FrusPartNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FrusType.IsSet() {
		localVarQueryParams.Add("frus.type", parameterToString(localVarOptionals.FrusType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FrusFirmwareVersion.IsSet() {
		localVarQueryParams.Add("frus.firmware_version", parameterToString(localVarOptionals.FrusFirmwareVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FrusId.IsSet() {
		localVarQueryParams.Add("frus.id", parameterToString(localVarOptionals.FrusId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SerialNumber.IsSet() {
		localVarQueryParams.Add("serial_number", parameterToString(localVarOptionals.SerialNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ShelfResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ShelfGetOpts Optional parameters for the method 'ShelfGet'
type ShelfGetOpts struct {
	Fields optional.Interface
}

/*
ShelfGet Method for ShelfGet
Retrieves a specific shelf. ### Related ONTAP commands * &#x60;storage shelf show&#x60; * &#x60;storage shelf port show&#x60; * &#x60;storage shelf drawer show&#x60; ### Learn more * [&#x60;DOC /storage/shelves&#x60;](#docs-storage-storage_shelves)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uid Shelf UID
 * @param optional nil or *ShelfGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return Shelf
*/
func (a *StorageApiService) ShelfGet(ctx _context.Context, uid string, localVarOptionals *ShelfGetOpts) (Shelf, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Shelf
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/shelves/{uid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uid"+"}", _neturl.QueryEscape(parameterToString(uid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Shelf
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// SnapshotCollectionGetOpts Optional parameters for the method 'SnapshotCollectionGet'
type SnapshotCollectionGetOpts struct {
	SnaplockExpiryTime optional.String
	CreateTime         optional.String
	State              optional.String
	ExpiryTime         optional.String
	Comment            optional.String
	Name               optional.String
	SvmUuid            optional.String
	SvmName            optional.String
	Uuid               optional.String
	VolumeName         optional.String
	VolumeUuid2        optional.String
	Fields             optional.Interface
	MaxRecords         optional.Int32
	ReturnRecords      optional.Bool
	ReturnTimeout      optional.Int32
	OrderBy            optional.Interface
}

/*
SnapshotCollectionGet Method for SnapshotCollectionGet
Retrieves a collection of volume Snapshot copies. ### Related ONTAP commands * &#x60;snapshot show&#x60; ### Learn more * [&#x60;DOC /storage/volumes/{volume.uuid}/snapshots&#x60;](#docs-storage-storage_volumes_{volume.uuid}_snapshots)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param volumeUuid Volume
 * @param optional nil or *SnapshotCollectionGetOpts - Optional Parameters:
 * @param "SnaplockExpiryTime" (optional.String) -  Filter by snaplock_expiry_time
 * @param "CreateTime" (optional.String) -  Filter by create_time
 * @param "State" (optional.String) -  Filter by state
 * @param "ExpiryTime" (optional.String) -  Filter by expiry_time
 * @param "Comment" (optional.String) -  Filter by comment
 * @param "Name" (optional.String) -  Filter by name
 * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
 * @param "SvmName" (optional.String) -  Filter by svm.name
 * @param "Uuid" (optional.String) -  Filter by uuid
 * @param "VolumeName" (optional.String) -  Filter by volume.name
 * @param "VolumeUuid2" (optional.String) -  Filter by volume.uuid
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return SnapshotResponse
*/
func (a *StorageApiService) SnapshotCollectionGet(ctx _context.Context, volumeUuid string, localVarOptionals *SnapshotCollectionGetOpts) (SnapshotResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SnapshotResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/volumes/{volume.uuid}/snapshots"
	localVarPath = strings.Replace(localVarPath, "{"+"volume.uuid"+"}", _neturl.QueryEscape(parameterToString(volumeUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.SnaplockExpiryTime.IsSet() {
		localVarQueryParams.Add("snaplock_expiry_time", parameterToString(localVarOptionals.SnaplockExpiryTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreateTime.IsSet() {
		localVarQueryParams.Add("create_time", parameterToString(localVarOptionals.CreateTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExpiryTime.IsSet() {
		localVarQueryParams.Add("expiry_time", parameterToString(localVarOptionals.ExpiryTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Comment.IsSet() {
		localVarQueryParams.Add("comment", parameterToString(localVarOptionals.Comment.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VolumeName.IsSet() {
		localVarQueryParams.Add("volume.name", parameterToString(localVarOptionals.VolumeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VolumeUuid2.IsSet() {
		localVarQueryParams.Add("volume.uuid", parameterToString(localVarOptionals.VolumeUuid2.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v SnapshotResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// SnapshotCreateOpts Optional parameters for the method 'SnapshotCreate'
type SnapshotCreateOpts struct {
	Info optional.Interface
}

/*
SnapshotCreate Method for SnapshotCreate
Creates a volume Snapshot copy. ### Required properties * &#x60;name&#x60; - Name of the Snapshot copy to be created. ### Recommended optional properties * &#x60;comment&#x60; - Comment associated with the Snapshot copy. * &#x60;expiry_time&#x60; - Snapshot copies with an expiry time set are not allowed to be deleted until the retention time is reached. ### Related ONTAP commands * &#x60;snapshot create&#x60; ### Learn more * [&#x60;DOC /storage/volumes/{volume.uuid}/snapshots&#x60;](#docs-storage-storage_volumes_{volume.uuid}_snapshots)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param volumeUuid Volume UUID
 * @param optional nil or *SnapshotCreateOpts - Optional Parameters:
 * @param "Info" (optional.Interface of Snapshot) -  Info specification
@return JobLinkResponse
*/
func (a *StorageApiService) SnapshotCreate(ctx _context.Context, volumeUuid string, localVarOptionals *SnapshotCreateOpts) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/volumes/{volume.uuid}/snapshots"
	localVarPath = strings.Replace(localVarPath, "{"+"volume.uuid"+"}", _neturl.QueryEscape(parameterToString(volumeUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(Snapshot)
		if !localVarOptionalInfook {
			return localVarReturnValue, nil, reportError("info should be Snapshot")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
SnapshotDelete Method for SnapshotDelete
Deletes a Volume Snapshot copy. ### Related ONTAP commands * &#x60;snapshot delete&#x60; ### Learn more * [&#x60;DOC /storage/volumes/{volume.uuid}/snapshots&#x60;](#docs-storage-storage_volumes_{volume.uuid}_snapshots)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param volumeUuid Volume UUID
 * @param uuid Snapshot copy UUID
@return JobLinkResponse
*/
func (a *StorageApiService) SnapshotDelete(ctx _context.Context, volumeUuid string, uuid string) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/volumes/{volume.uuid}/snapshots/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"volume.uuid"+"}", _neturl.QueryEscape(parameterToString(volumeUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// SnapshotGetOpts Optional parameters for the method 'SnapshotGet'
type SnapshotGetOpts struct {
	Fields optional.Interface
}

/*
SnapshotGet Method for SnapshotGet
Retrieves details of a specific volume Snapshot copy. ### Related ONTAP commands * &#x60;snapshot show&#x60; ### Learn more * [&#x60;DOC /storage/volumes/{volume.uuid}/snapshots&#x60;](#docs-storage-storage_volumes_{volume.uuid}_snapshots)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param volumeUuid Volume UUID
 * @param uuid Snapshot copy UUID
 * @param optional nil or *SnapshotGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return Snapshot
*/
func (a *StorageApiService) SnapshotGet(ctx _context.Context, volumeUuid string, uuid string, localVarOptionals *SnapshotGetOpts) (Snapshot, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Snapshot
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/volumes/{volume.uuid}/snapshots/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"volume.uuid"+"}", _neturl.QueryEscape(parameterToString(volumeUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Snapshot
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// SnapshotModifyOpts Optional parameters for the method 'SnapshotModify'
type SnapshotModifyOpts struct {
	Info optional.Interface
}

/*
SnapshotModify Method for SnapshotModify
Updates a Volume Snapshot copy. ### Related ONTAP commands * &#x60;snapshot modify&#x60; * &#x60;snapshot rename&#x60; ### Learn more * [&#x60;DOC /storage/volumes/{volume.uuid}/snapshots&#x60;](#docs-storage-storage_volumes_{volume.uuid}_snapshots)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param volumeUuid Volume UUID
 * @param uuid Snapshot copy UUID
 * @param optional nil or *SnapshotModifyOpts - Optional Parameters:
 * @param "Info" (optional.Interface of Snapshot) -  Info specification
@return JobLinkResponse
*/
func (a *StorageApiService) SnapshotModify(ctx _context.Context, volumeUuid string, uuid string, localVarOptionals *SnapshotModifyOpts) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/volumes/{volume.uuid}/snapshots/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"volume.uuid"+"}", _neturl.QueryEscape(parameterToString(volumeUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(Snapshot)
		if !localVarOptionalInfook {
			return localVarReturnValue, nil, reportError("info should be Snapshot")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// SnapshotPolicyCollectionGetOpts Optional parameters for the method 'SnapshotPolicyCollectionGet'
type SnapshotPolicyCollectionGetOpts struct {
	Uuid                  optional.String
	CopiesPrefix          optional.String
	CopiesCount           optional.Int32
	CopiesSnapmirrorLabel optional.String
	CopiesScheduleName    optional.String
	SvmUuid               optional.String
	SvmName               optional.String
	Name                  optional.String
	Scope                 optional.String
	Comment               optional.String
	Enabled               optional.Bool
	Fields                optional.Interface
	MaxRecords            optional.Int32
	ReturnRecords         optional.Bool
	ReturnTimeout         optional.Int32
	OrderBy               optional.Interface
}

/*
SnapshotPolicyCollectionGet Method for SnapshotPolicyCollectionGet
Retrieves a collection of Snapshot copy policies. ### Related ONTAP commands * &#x60;snapshot policy show&#x60; ### Learn more * [&#x60;DOC /storage/snapshot-policies&#x60;](#docs-storage-storage_snapshot-policies)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *SnapshotPolicyCollectionGetOpts - Optional Parameters:
 * @param "Uuid" (optional.String) -  Filter by uuid
 * @param "CopiesPrefix" (optional.String) -  Filter by copies.prefix
 * @param "CopiesCount" (optional.Int32) -  Filter by copies.count
 * @param "CopiesSnapmirrorLabel" (optional.String) -  Filter by copies.snapmirror_label
 * @param "CopiesScheduleName" (optional.String) -  Filter by copies.schedule.name
 * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
 * @param "SvmName" (optional.String) -  Filter by svm.name
 * @param "Name" (optional.String) -  Filter by name
 * @param "Scope" (optional.String) -  Filter by scope
 * @param "Comment" (optional.String) -  Filter by comment
 * @param "Enabled" (optional.Bool) -  Filter by enabled
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return SnapshotPolicyResponse
*/
func (a *StorageApiService) SnapshotPolicyCollectionGet(ctx _context.Context, localVarOptionals *SnapshotPolicyCollectionGetOpts) (SnapshotPolicyResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SnapshotPolicyResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/snapshot-policies"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CopiesPrefix.IsSet() {
		localVarQueryParams.Add("copies.prefix", parameterToString(localVarOptionals.CopiesPrefix.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CopiesCount.IsSet() {
		localVarQueryParams.Add("copies.count", parameterToString(localVarOptionals.CopiesCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CopiesSnapmirrorLabel.IsSet() {
		localVarQueryParams.Add("copies.snapmirror_label", parameterToString(localVarOptionals.CopiesSnapmirrorLabel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CopiesScheduleName.IsSet() {
		localVarQueryParams.Add("copies.schedule.name", parameterToString(localVarOptionals.CopiesScheduleName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Scope.IsSet() {
		localVarQueryParams.Add("scope", parameterToString(localVarOptionals.Scope.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Comment.IsSet() {
		localVarQueryParams.Add("comment", parameterToString(localVarOptionals.Comment.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarQueryParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v SnapshotPolicyResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// SnapshotPolicyCreateOpts Optional parameters for the method 'SnapshotPolicyCreate'
type SnapshotPolicyCreateOpts struct {
	Info optional.Interface
}

/*
SnapshotPolicyCreate Method for SnapshotPolicyCreate
Creates a Snapshot copy policy. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the Snapshot copy policy. * &#x60;name&#x60; - Name for the Snapshot copy policy. * &#x60;copies.schedule&#x60; - Schedule at which Snapshot copies are captured on the volume. * &#x60;copies.count&#x60; - Number of Snapshot copies to maintain for this schedule. ### Recommended optional properties * &#x60;copies.prefix&#x60; - Prefix to use when creating Snapshot copies at regular intervals. ### Default property values If not specified in POST, the following default property values are assigned: * &#x60;enabled&#x60; - _true_ * &#x60;copies.prefix&#x60; - Value of &#x60;schedule.name&#x60; ### Related ONTAP commands * &#x60;snapshot policy create&#x60; ### Learn more * [&#x60;DOC /storage/snapshot-policies&#x60;](#docs-storage-storage_snapshot-policies)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *SnapshotPolicyCreateOpts - Optional Parameters:
 * @param "Info" (optional.Interface of SnapshotPolicy) -  Info specification
*/
func (a *StorageApiService) SnapshotPolicyCreate(ctx _context.Context, localVarOptionals *SnapshotPolicyCreateOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/snapshot-policies"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(SnapshotPolicy)
		if !localVarOptionalInfook {
			return nil, reportError("info should be SnapshotPolicy")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
SnapshotPolicyDelete Method for SnapshotPolicyDelete
Deletes a Snapshot copy policy ### Related ONTAP commands * &#x60;snapshot policy delete&#x60; ### Learn more * [&#x60;DOC /storage/snapshot-policies&#x60;](#docs-storage-storage_snapshot-policies)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Snapshot policy UUID
*/
func (a *StorageApiService) SnapshotPolicyDelete(ctx _context.Context, uuid string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/snapshot-policies/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// SnapshotPolicyGetOpts Optional parameters for the method 'SnapshotPolicyGet'
type SnapshotPolicyGetOpts struct {
	Fields optional.Interface
}

/*
SnapshotPolicyGet Method for SnapshotPolicyGet
Retrieves details of a specific Snapshot copy policy. ### Related ONTAP commands * &#x60;snapshot policy show&#x60; ### Learn more * [&#x60;DOC /storage/snapshot-policies&#x60;](#docs-storage-storage_snapshot-policies)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Snapshot copy policy ID
 * @param optional nil or *SnapshotPolicyGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return SnapshotPolicy
*/
func (a *StorageApiService) SnapshotPolicyGet(ctx _context.Context, uuid string, localVarOptionals *SnapshotPolicyGetOpts) (SnapshotPolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SnapshotPolicy
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/snapshot-policies/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v SnapshotPolicy
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// SnapshotPolicyModifyOpts Optional parameters for the method 'SnapshotPolicyModify'
type SnapshotPolicyModifyOpts struct {
	Info optional.Interface
}

/*
SnapshotPolicyModify Method for SnapshotPolicyModify
Updates a Snapshot copy policy ### Related ONTAP commands * &#x60;snapshot policy modify&#x60; * &#x60;snapshot policy modify-schedule&#x60; * &#x60;snapshot policy add-schedule&#x60; ### Learn more * [&#x60;DOC /storage/snapshot-policies&#x60;](#docs-storage-storage_snapshot-policies)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Snapshot policy UUID
 * @param optional nil or *SnapshotPolicyModifyOpts - Optional Parameters:
 * @param "Info" (optional.Interface of SnapshotPolicy) -  Info specification
*/
func (a *StorageApiService) SnapshotPolicyModify(ctx _context.Context, uuid string, localVarOptionals *SnapshotPolicyModifyOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/snapshot-policies/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(SnapshotPolicy)
		if !localVarOptionalInfook {
			return nil, reportError("info should be SnapshotPolicy")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// StorageClusterGetOpts Optional parameters for the method 'StorageClusterGet'
type StorageClusterGetOpts struct {
	Fields optional.Interface
}

/*
StorageClusterGet Method for StorageClusterGet
Reports cluster wide storage details across different tiers. By default, this endpoint returns all fields. Supports the following roles: admin, and readonly.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *StorageClusterGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return ClusterSpace
*/
func (a *StorageApiService) StorageClusterGet(ctx _context.Context, localVarOptionals *StorageClusterGetOpts) (ClusterSpace, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ClusterSpace
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/cluster"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ClusterSpace
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// VolumeCollectionGetOpts Optional parameters for the method 'VolumeCollectionGet'
type VolumeCollectionGetOpts struct {
	NasUnixPermissions                optional.Int32
	NasSecurityStyle                  optional.String
	NasGid                            optional.Int32
	NasExportPolicyName               optional.String
	NasExportPolicyId                 optional.Int32
	NasPath                           optional.String
	NasUid                            optional.Int32
	CloneIsFlexclone                  optional.Bool
	CloneParentVolumeName             optional.String
	CloneParentVolumeUuid             optional.String
	CloneParentSvmUuid                optional.String
	CloneParentSvmName                optional.String
	CloneSplitEstimate                optional.Int32
	CloneSplitCompletePercent         optional.Int32
	CloneSplitInitiated               optional.Bool
	CloneParentSnapshotUuid           optional.String
	CloneParentSnapshotName           optional.String
	ErrorStateIsInconsistent          optional.Bool
	ErrorStateHasBadBlocks            optional.Bool
	FlexcacheEndpointType             optional.String
	StatisticsLatencyRawTotal         optional.Int32
	StatisticsLatencyRawOther         optional.Int32
	StatisticsLatencyRawWrite         optional.Int32
	StatisticsLatencyRawRead          optional.Int32
	StatisticsStatus                  optional.String
	StatisticsTimestamp               optional.String
	StatisticsIopsRawTotal            optional.Int32
	StatisticsIopsRawOther            optional.Int32
	StatisticsIopsRawWrite            optional.Int32
	StatisticsIopsRawRead             optional.Int32
	StatisticsThroughputRawTotal      optional.Int32
	StatisticsThroughputRawOther      optional.Int32
	StatisticsThroughputRawWrite      optional.Int32
	StatisticsThroughputRawRead       optional.Int32
	QosPolicyUuid                     optional.String
	QosPolicyMinThroughputIops        optional.Int32
	QosPolicyMaxThroughputMbps        optional.Int32
	QosPolicyName                     optional.String
	QosPolicyMaxThroughputIops        optional.Int32
	SpaceSize                         optional.Int32
	SpaceOverProvisioned              optional.Int32
	SpaceAvailable                    optional.Int32
	SpaceMetadata                     optional.Int32
	SpaceLogicalSpaceUsedByAfs        optional.Int32
	SpaceLogicalSpaceReporting        optional.Bool
	SpaceLogicalSpaceEnforcement      optional.Bool
	SpaceLogicalSpaceAvailable        optional.Int32
	SpaceBlockStorageInactiveUserData optional.Int32
	SpaceCapacityTierFootprint        optional.Int32
	SpaceUsed                         optional.Int32
	SpaceFootprint                    optional.Int32
	SpaceSnapshotReservePercent       optional.Int32
	SpaceSnapshotUsed                 optional.Int32
	Name                              optional.String
	MovementPercentComplete           optional.String
	MovementState                     optional.String
	MovementDestinationAggregateUuid  optional.String
	MovementDestinationAggregateName  optional.String
	MovementCutoverWindow             optional.Int32
	SnapshotPolicyName                optional.String
	SnapshotPolicyUuid                optional.String
	Size                              optional.Int32
	SnaplockType                      optional.String
	SnaplockComplianceClockTime       optional.String
	SnaplockPrivilegedDelete          optional.String
	SnaplockAutocommitPeriod          optional.String
	SnaplockIsAuditLog                optional.Bool
	SnaplockAppendModeEnabled         optional.Bool
	SnaplockExpiryTime                optional.String
	SnaplockRetentionMaximum          optional.String
	SnaplockRetentionMinimum          optional.String
	SnaplockRetentionDefault          optional.String
	SnaplockLitigationCount           optional.Int32
	CreateTime                        optional.String
	EfficiencyDedupe                  optional.String
	EfficiencyCrossVolumeDedupe       optional.String
	EfficiencyCompression             optional.String
	EfficiencyCompaction              optional.String
	AutosizeShrinkThreshold           optional.Int32
	AutosizeMode                      optional.String
	AutosizeGrowThreshold             optional.Int32
	AutosizeMaximum                   optional.Int32
	AutosizeMinimum                   optional.Int32
	Comment                           optional.String
	GuaranteeType                     optional.String
	GuaranteeHonored                  optional.Bool
	Uuid                              optional.String
	MetricTimestamp                   optional.String
	MetricIopsTotal                   optional.Int32
	MetricIopsOther                   optional.Int32
	MetricIopsWrite                   optional.Int32
	MetricIopsRead                    optional.Int32
	MetricDuration                    optional.String
	MetricThroughputTotal             optional.Int32
	MetricThroughputOther             optional.Int32
	MetricThroughputWrite             optional.Int32
	MetricThroughputRead              optional.Int32
	MetricLatencyTotal                optional.Int32
	MetricLatencyOther                optional.Int32
	MetricLatencyWrite                optional.Int32
	MetricLatencyRead                 optional.Int32
	MetricStatus                      optional.String
	SvmUuid                           optional.String
	SvmName                           optional.String
	QuotaState                        optional.String
	TieringPolicy                     optional.String
	Style                             optional.String
	Type_                             optional.String
	EncryptionState                   optional.String
	EncryptionKeyId                   optional.String
	EncryptionRekey                   optional.Bool
	EncryptionStatusCode              optional.String
	EncryptionStatusMessage           optional.String
	EncryptionEnabled                 optional.Bool
	EncryptionType                    optional.String
	FilesUsed                         optional.Int32
	FilesMaximum                      optional.Int32
	AggregatesUuid                    optional.String
	AggregatesName                    optional.String
	Language                          optional.String
	ApplicationName                   optional.String
	ApplicationUuid                   optional.String
	State                             optional.String
	Fields                            optional.Interface
	MaxRecords                        optional.Int32
	ReturnRecords                     optional.Bool
	ReturnTimeout                     optional.Int32
	OrderBy                           optional.Interface
}

/*
VolumeCollectionGet Method for VolumeCollectionGet
Retrieves volumes. ### Expensive properties There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the &#x60;fields&#x60; query parameter. See [&#x60;DOC Requesting specific fields&#x60;](#docs-docs-Requesting-specific-fields) to learn more. * &#x60;application.*&#x60; * &#x60;encryption.*&#x60; * &#x60;clone.parent_snapshot.name&#x60; * &#x60;clone.parent_snapshot.uuid&#x60; * &#x60;clone.parent_svm.name&#x60; * &#x60;clone.parent_svm.uuid&#x60; * &#x60;clone.parent_volume.name&#x60; * &#x60;clone.parent_volume.uuid&#x60; * &#x60;clone.split_complete_percent&#x60; * &#x60;clone.split_estimate&#x60; * &#x60;clone.split_initiated&#x60; * &#x60;efficiency.*&#x60; * &#x60;error_state.*&#x60; * &#x60;files.*&#x60; * &#x60;nas.export_policy.id&#x60; * &#x60;nas.gid&#x60; * &#x60;nas.path&#x60; * &#x60;nas.security_style&#x60; * &#x60;nas.uid&#x60; * &#x60;nas.unix_permissions&#x60; * &#x60;snaplock.*&#x60; * &#x60;restore_to.*&#x60; * &#x60;snapshot_policy.uuid&#x60; * &#x60;quota.*&#x60; * &#x60;qos.*&#x60; * &#x60;flexcache_endpoint_type&#x60; * &#x60;space.block_storage_inactive_user_data&#x60; * &#x60;space.capacity_tier_footprint&#x60; * &#x60;space.footprint&#x60; * &#x60;space.over_provisioned&#x60; * &#x60;space.metadata&#x60; * &#x60;space.logical_space.*&#x60; * &#x60;space.snapshot.*&#x60; * &#x60;guarantee.*&#x60; * &#x60;autosize.*&#x60; * &#x60;movement.*&#x60; * &#x60;statistics.*&#x60; ### Related ONTAP commands * &#x60;volume show&#x60; * &#x60;volume clone show&#x60; * &#x60;volume efficiency show&#x60; * &#x60;volume encryption show&#x60; * &#x60;volume flexcache show&#x60; * &#x60;volume flexgroup show&#x60; * &#x60;volume move show&#x60; * &#x60;volume quota show&#x60; * &#x60;volume show-space&#x60; * &#x60;volume snaplock show&#x60;  ### Learn more * [&#x60;DOC /storage/volumes&#x60;](#docs-storage-storage_volumes)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *VolumeCollectionGetOpts - Optional Parameters:
 * @param "NasUnixPermissions" (optional.Int32) -  Filter by nas.unix_permissions
 * @param "NasSecurityStyle" (optional.String) -  Filter by nas.security_style
 * @param "NasGid" (optional.Int32) -  Filter by nas.gid
 * @param "NasExportPolicyName" (optional.String) -  Filter by nas.export_policy.name
 * @param "NasExportPolicyId" (optional.Int32) -  Filter by nas.export_policy.id
 * @param "NasPath" (optional.String) -  Filter by nas.path
 * @param "NasUid" (optional.Int32) -  Filter by nas.uid
 * @param "CloneIsFlexclone" (optional.Bool) -  Filter by clone.is_flexclone
 * @param "CloneParentVolumeName" (optional.String) -  Filter by clone.parent_volume.name
 * @param "CloneParentVolumeUuid" (optional.String) -  Filter by clone.parent_volume.uuid
 * @param "CloneParentSvmUuid" (optional.String) -  Filter by clone.parent_svm.uuid
 * @param "CloneParentSvmName" (optional.String) -  Filter by clone.parent_svm.name
 * @param "CloneSplitEstimate" (optional.Int32) -  Filter by clone.split_estimate
 * @param "CloneSplitCompletePercent" (optional.Int32) -  Filter by clone.split_complete_percent
 * @param "CloneSplitInitiated" (optional.Bool) -  Filter by clone.split_initiated
 * @param "CloneParentSnapshotUuid" (optional.String) -  Filter by clone.parent_snapshot.uuid
 * @param "CloneParentSnapshotName" (optional.String) -  Filter by clone.parent_snapshot.name
 * @param "ErrorStateIsInconsistent" (optional.Bool) -  Filter by error_state.is_inconsistent
 * @param "ErrorStateHasBadBlocks" (optional.Bool) -  Filter by error_state.has_bad_blocks
 * @param "FlexcacheEndpointType" (optional.String) -  Filter by flexcache_endpoint_type
 * @param "StatisticsLatencyRawTotal" (optional.Int32) -  Filter by statistics.latency_raw.total
 * @param "StatisticsLatencyRawOther" (optional.Int32) -  Filter by statistics.latency_raw.other
 * @param "StatisticsLatencyRawWrite" (optional.Int32) -  Filter by statistics.latency_raw.write
 * @param "StatisticsLatencyRawRead" (optional.Int32) -  Filter by statistics.latency_raw.read
 * @param "StatisticsStatus" (optional.String) -  Filter by statistics.status
 * @param "StatisticsTimestamp" (optional.String) -  Filter by statistics.timestamp
 * @param "StatisticsIopsRawTotal" (optional.Int32) -  Filter by statistics.iops_raw.total
 * @param "StatisticsIopsRawOther" (optional.Int32) -  Filter by statistics.iops_raw.other
 * @param "StatisticsIopsRawWrite" (optional.Int32) -  Filter by statistics.iops_raw.write
 * @param "StatisticsIopsRawRead" (optional.Int32) -  Filter by statistics.iops_raw.read
 * @param "StatisticsThroughputRawTotal" (optional.Int32) -  Filter by statistics.throughput_raw.total
 * @param "StatisticsThroughputRawOther" (optional.Int32) -  Filter by statistics.throughput_raw.other
 * @param "StatisticsThroughputRawWrite" (optional.Int32) -  Filter by statistics.throughput_raw.write
 * @param "StatisticsThroughputRawRead" (optional.Int32) -  Filter by statistics.throughput_raw.read
 * @param "QosPolicyUuid" (optional.String) -  Filter by qos.policy.uuid
 * @param "QosPolicyMinThroughputIops" (optional.Int32) -  Filter by qos.policy.min_throughput_iops
 * @param "QosPolicyMaxThroughputMbps" (optional.Int32) -  Filter by qos.policy.max_throughput_mbps
 * @param "QosPolicyName" (optional.String) -  Filter by qos.policy.name
 * @param "QosPolicyMaxThroughputIops" (optional.Int32) -  Filter by qos.policy.max_throughput_iops
 * @param "SpaceSize" (optional.Int32) -  Filter by space.size
 * @param "SpaceOverProvisioned" (optional.Int32) -  Filter by space.over_provisioned
 * @param "SpaceAvailable" (optional.Int32) -  Filter by space.available
 * @param "SpaceMetadata" (optional.Int32) -  Filter by space.metadata
 * @param "SpaceLogicalSpaceUsedByAfs" (optional.Int32) -  Filter by space.logical_space.used_by_afs
 * @param "SpaceLogicalSpaceReporting" (optional.Bool) -  Filter by space.logical_space.reporting
 * @param "SpaceLogicalSpaceEnforcement" (optional.Bool) -  Filter by space.logical_space.enforcement
 * @param "SpaceLogicalSpaceAvailable" (optional.Int32) -  Filter by space.logical_space.available
 * @param "SpaceBlockStorageInactiveUserData" (optional.Int32) -  Filter by space.block_storage_inactive_user_data
 * @param "SpaceCapacityTierFootprint" (optional.Int32) -  Filter by space.capacity_tier_footprint
 * @param "SpaceUsed" (optional.Int32) -  Filter by space.used
 * @param "SpaceFootprint" (optional.Int32) -  Filter by space.footprint
 * @param "SpaceSnapshotReservePercent" (optional.Int32) -  Filter by space.snapshot.reserve_percent
 * @param "SpaceSnapshotUsed" (optional.Int32) -  Filter by space.snapshot.used
 * @param "Name" (optional.String) -  Filter by name
 * @param "MovementPercentComplete" (optional.String) -  Filter by movement.percent_complete
 * @param "MovementState" (optional.String) -  Filter by movement.state
 * @param "MovementDestinationAggregateUuid" (optional.String) -  Filter by movement.destination_aggregate.uuid
 * @param "MovementDestinationAggregateName" (optional.String) -  Filter by movement.destination_aggregate.name
 * @param "MovementCutoverWindow" (optional.Int32) -  Filter by movement.cutover_window
 * @param "SnapshotPolicyName" (optional.String) -  Filter by snapshot_policy.name
 * @param "SnapshotPolicyUuid" (optional.String) -  Filter by snapshot_policy.uuid
 * @param "Size" (optional.Int32) -  Filter by size
 * @param "SnaplockType" (optional.String) -  Filter by snaplock.type
 * @param "SnaplockComplianceClockTime" (optional.String) -  Filter by snaplock.compliance_clock_time
 * @param "SnaplockPrivilegedDelete" (optional.String) -  Filter by snaplock.privileged_delete
 * @param "SnaplockAutocommitPeriod" (optional.String) -  Filter by snaplock.autocommit_period
 * @param "SnaplockIsAuditLog" (optional.Bool) -  Filter by snaplock.is_audit_log
 * @param "SnaplockAppendModeEnabled" (optional.Bool) -  Filter by snaplock.append_mode_enabled
 * @param "SnaplockExpiryTime" (optional.String) -  Filter by snaplock.expiry_time
 * @param "SnaplockRetentionMaximum" (optional.String) -  Filter by snaplock.retention.maximum
 * @param "SnaplockRetentionMinimum" (optional.String) -  Filter by snaplock.retention.minimum
 * @param "SnaplockRetentionDefault" (optional.String) -  Filter by snaplock.retention.default
 * @param "SnaplockLitigationCount" (optional.Int32) -  Filter by snaplock.litigation_count
 * @param "CreateTime" (optional.String) -  Filter by create_time
 * @param "EfficiencyDedupe" (optional.String) -  Filter by efficiency.dedupe
 * @param "EfficiencyCrossVolumeDedupe" (optional.String) -  Filter by efficiency.cross_volume_dedupe
 * @param "EfficiencyCompression" (optional.String) -  Filter by efficiency.compression
 * @param "EfficiencyCompaction" (optional.String) -  Filter by efficiency.compaction
 * @param "AutosizeShrinkThreshold" (optional.Int32) -  Filter by autosize.shrink_threshold
 * @param "AutosizeMode" (optional.String) -  Filter by autosize.mode
 * @param "AutosizeGrowThreshold" (optional.Int32) -  Filter by autosize.grow_threshold
 * @param "AutosizeMaximum" (optional.Int32) -  Filter by autosize.maximum
 * @param "AutosizeMinimum" (optional.Int32) -  Filter by autosize.minimum
 * @param "Comment" (optional.String) -  Filter by comment
 * @param "GuaranteeType" (optional.String) -  Filter by guarantee.type
 * @param "GuaranteeHonored" (optional.Bool) -  Filter by guarantee.honored
 * @param "Uuid" (optional.String) -  Filter by uuid
 * @param "MetricTimestamp" (optional.String) -  Filter by metric.timestamp
 * @param "MetricIopsTotal" (optional.Int32) -  Filter by metric.iops.total
 * @param "MetricIopsOther" (optional.Int32) -  Filter by metric.iops.other
 * @param "MetricIopsWrite" (optional.Int32) -  Filter by metric.iops.write
 * @param "MetricIopsRead" (optional.Int32) -  Filter by metric.iops.read
 * @param "MetricDuration" (optional.String) -  Filter by metric.duration
 * @param "MetricThroughputTotal" (optional.Int32) -  Filter by metric.throughput.total
 * @param "MetricThroughputOther" (optional.Int32) -  Filter by metric.throughput.other
 * @param "MetricThroughputWrite" (optional.Int32) -  Filter by metric.throughput.write
 * @param "MetricThroughputRead" (optional.Int32) -  Filter by metric.throughput.read
 * @param "MetricLatencyTotal" (optional.Int32) -  Filter by metric.latency.total
 * @param "MetricLatencyOther" (optional.Int32) -  Filter by metric.latency.other
 * @param "MetricLatencyWrite" (optional.Int32) -  Filter by metric.latency.write
 * @param "MetricLatencyRead" (optional.Int32) -  Filter by metric.latency.read
 * @param "MetricStatus" (optional.String) -  Filter by metric.status
 * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
 * @param "SvmName" (optional.String) -  Filter by svm.name
 * @param "QuotaState" (optional.String) -  Filter by quota.state
 * @param "TieringPolicy" (optional.String) -  Filter by tiering.policy
 * @param "Style" (optional.String) -  Filter by style
 * @param "Type_" (optional.String) -  Filter by type
 * @param "EncryptionState" (optional.String) -  Filter by encryption.state
 * @param "EncryptionKeyId" (optional.String) -  Filter by encryption.key_id
 * @param "EncryptionRekey" (optional.Bool) -  Filter by encryption.rekey
 * @param "EncryptionStatusCode" (optional.String) -  Filter by encryption.status.code
 * @param "EncryptionStatusMessage" (optional.String) -  Filter by encryption.status.message
 * @param "EncryptionEnabled" (optional.Bool) -  Filter by encryption.enabled
 * @param "EncryptionType" (optional.String) -  Filter by encryption.type
 * @param "FilesUsed" (optional.Int32) -  Filter by files.used
 * @param "FilesMaximum" (optional.Int32) -  Filter by files.maximum
 * @param "AggregatesUuid" (optional.String) -  Filter by aggregates.uuid
 * @param "AggregatesName" (optional.String) -  Filter by aggregates.name
 * @param "Language" (optional.String) -  Filter by language
 * @param "ApplicationName" (optional.String) -  Filter by application.name
 * @param "ApplicationUuid" (optional.String) -  Filter by application.uuid
 * @param "State" (optional.String) -  Filter by state
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return VolumeResponse
*/
func (a *StorageApiService) VolumeCollectionGet(ctx _context.Context, localVarOptionals *VolumeCollectionGetOpts) (VolumeResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  VolumeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/volumes"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.NasUnixPermissions.IsSet() {
		localVarQueryParams.Add("nas.unix_permissions", parameterToString(localVarOptionals.NasUnixPermissions.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NasSecurityStyle.IsSet() {
		localVarQueryParams.Add("nas.security_style", parameterToString(localVarOptionals.NasSecurityStyle.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NasGid.IsSet() {
		localVarQueryParams.Add("nas.gid", parameterToString(localVarOptionals.NasGid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NasExportPolicyName.IsSet() {
		localVarQueryParams.Add("nas.export_policy.name", parameterToString(localVarOptionals.NasExportPolicyName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NasExportPolicyId.IsSet() {
		localVarQueryParams.Add("nas.export_policy.id", parameterToString(localVarOptionals.NasExportPolicyId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NasPath.IsSet() {
		localVarQueryParams.Add("nas.path", parameterToString(localVarOptionals.NasPath.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NasUid.IsSet() {
		localVarQueryParams.Add("nas.uid", parameterToString(localVarOptionals.NasUid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CloneIsFlexclone.IsSet() {
		localVarQueryParams.Add("clone.is_flexclone", parameterToString(localVarOptionals.CloneIsFlexclone.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CloneParentVolumeName.IsSet() {
		localVarQueryParams.Add("clone.parent_volume.name", parameterToString(localVarOptionals.CloneParentVolumeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CloneParentVolumeUuid.IsSet() {
		localVarQueryParams.Add("clone.parent_volume.uuid", parameterToString(localVarOptionals.CloneParentVolumeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CloneParentSvmUuid.IsSet() {
		localVarQueryParams.Add("clone.parent_svm.uuid", parameterToString(localVarOptionals.CloneParentSvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CloneParentSvmName.IsSet() {
		localVarQueryParams.Add("clone.parent_svm.name", parameterToString(localVarOptionals.CloneParentSvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CloneSplitEstimate.IsSet() {
		localVarQueryParams.Add("clone.split_estimate", parameterToString(localVarOptionals.CloneSplitEstimate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CloneSplitCompletePercent.IsSet() {
		localVarQueryParams.Add("clone.split_complete_percent", parameterToString(localVarOptionals.CloneSplitCompletePercent.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CloneSplitInitiated.IsSet() {
		localVarQueryParams.Add("clone.split_initiated", parameterToString(localVarOptionals.CloneSplitInitiated.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CloneParentSnapshotUuid.IsSet() {
		localVarQueryParams.Add("clone.parent_snapshot.uuid", parameterToString(localVarOptionals.CloneParentSnapshotUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CloneParentSnapshotName.IsSet() {
		localVarQueryParams.Add("clone.parent_snapshot.name", parameterToString(localVarOptionals.CloneParentSnapshotName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ErrorStateIsInconsistent.IsSet() {
		localVarQueryParams.Add("error_state.is_inconsistent", parameterToString(localVarOptionals.ErrorStateIsInconsistent.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ErrorStateHasBadBlocks.IsSet() {
		localVarQueryParams.Add("error_state.has_bad_blocks", parameterToString(localVarOptionals.ErrorStateHasBadBlocks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FlexcacheEndpointType.IsSet() {
		localVarQueryParams.Add("flexcache_endpoint_type", parameterToString(localVarOptionals.FlexcacheEndpointType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsLatencyRawTotal.IsSet() {
		localVarQueryParams.Add("statistics.latency_raw.total", parameterToString(localVarOptionals.StatisticsLatencyRawTotal.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsLatencyRawOther.IsSet() {
		localVarQueryParams.Add("statistics.latency_raw.other", parameterToString(localVarOptionals.StatisticsLatencyRawOther.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsLatencyRawWrite.IsSet() {
		localVarQueryParams.Add("statistics.latency_raw.write", parameterToString(localVarOptionals.StatisticsLatencyRawWrite.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsLatencyRawRead.IsSet() {
		localVarQueryParams.Add("statistics.latency_raw.read", parameterToString(localVarOptionals.StatisticsLatencyRawRead.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsStatus.IsSet() {
		localVarQueryParams.Add("statistics.status", parameterToString(localVarOptionals.StatisticsStatus.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsTimestamp.IsSet() {
		localVarQueryParams.Add("statistics.timestamp", parameterToString(localVarOptionals.StatisticsTimestamp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsIopsRawTotal.IsSet() {
		localVarQueryParams.Add("statistics.iops_raw.total", parameterToString(localVarOptionals.StatisticsIopsRawTotal.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsIopsRawOther.IsSet() {
		localVarQueryParams.Add("statistics.iops_raw.other", parameterToString(localVarOptionals.StatisticsIopsRawOther.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsIopsRawWrite.IsSet() {
		localVarQueryParams.Add("statistics.iops_raw.write", parameterToString(localVarOptionals.StatisticsIopsRawWrite.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsIopsRawRead.IsSet() {
		localVarQueryParams.Add("statistics.iops_raw.read", parameterToString(localVarOptionals.StatisticsIopsRawRead.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsThroughputRawTotal.IsSet() {
		localVarQueryParams.Add("statistics.throughput_raw.total", parameterToString(localVarOptionals.StatisticsThroughputRawTotal.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsThroughputRawOther.IsSet() {
		localVarQueryParams.Add("statistics.throughput_raw.other", parameterToString(localVarOptionals.StatisticsThroughputRawOther.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsThroughputRawWrite.IsSet() {
		localVarQueryParams.Add("statistics.throughput_raw.write", parameterToString(localVarOptionals.StatisticsThroughputRawWrite.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsThroughputRawRead.IsSet() {
		localVarQueryParams.Add("statistics.throughput_raw.read", parameterToString(localVarOptionals.StatisticsThroughputRawRead.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QosPolicyUuid.IsSet() {
		localVarQueryParams.Add("qos.policy.uuid", parameterToString(localVarOptionals.QosPolicyUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QosPolicyMinThroughputIops.IsSet() {
		localVarQueryParams.Add("qos.policy.min_throughput_iops", parameterToString(localVarOptionals.QosPolicyMinThroughputIops.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QosPolicyMaxThroughputMbps.IsSet() {
		localVarQueryParams.Add("qos.policy.max_throughput_mbps", parameterToString(localVarOptionals.QosPolicyMaxThroughputMbps.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QosPolicyName.IsSet() {
		localVarQueryParams.Add("qos.policy.name", parameterToString(localVarOptionals.QosPolicyName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QosPolicyMaxThroughputIops.IsSet() {
		localVarQueryParams.Add("qos.policy.max_throughput_iops", parameterToString(localVarOptionals.QosPolicyMaxThroughputIops.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceSize.IsSet() {
		localVarQueryParams.Add("space.size", parameterToString(localVarOptionals.SpaceSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceOverProvisioned.IsSet() {
		localVarQueryParams.Add("space.over_provisioned", parameterToString(localVarOptionals.SpaceOverProvisioned.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceAvailable.IsSet() {
		localVarQueryParams.Add("space.available", parameterToString(localVarOptionals.SpaceAvailable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceMetadata.IsSet() {
		localVarQueryParams.Add("space.metadata", parameterToString(localVarOptionals.SpaceMetadata.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceLogicalSpaceUsedByAfs.IsSet() {
		localVarQueryParams.Add("space.logical_space.used_by_afs", parameterToString(localVarOptionals.SpaceLogicalSpaceUsedByAfs.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceLogicalSpaceReporting.IsSet() {
		localVarQueryParams.Add("space.logical_space.reporting", parameterToString(localVarOptionals.SpaceLogicalSpaceReporting.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceLogicalSpaceEnforcement.IsSet() {
		localVarQueryParams.Add("space.logical_space.enforcement", parameterToString(localVarOptionals.SpaceLogicalSpaceEnforcement.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceLogicalSpaceAvailable.IsSet() {
		localVarQueryParams.Add("space.logical_space.available", parameterToString(localVarOptionals.SpaceLogicalSpaceAvailable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceBlockStorageInactiveUserData.IsSet() {
		localVarQueryParams.Add("space.block_storage_inactive_user_data", parameterToString(localVarOptionals.SpaceBlockStorageInactiveUserData.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceCapacityTierFootprint.IsSet() {
		localVarQueryParams.Add("space.capacity_tier_footprint", parameterToString(localVarOptionals.SpaceCapacityTierFootprint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceUsed.IsSet() {
		localVarQueryParams.Add("space.used", parameterToString(localVarOptionals.SpaceUsed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceFootprint.IsSet() {
		localVarQueryParams.Add("space.footprint", parameterToString(localVarOptionals.SpaceFootprint.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceSnapshotReservePercent.IsSet() {
		localVarQueryParams.Add("space.snapshot.reserve_percent", parameterToString(localVarOptionals.SpaceSnapshotReservePercent.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceSnapshotUsed.IsSet() {
		localVarQueryParams.Add("space.snapshot.used", parameterToString(localVarOptionals.SpaceSnapshotUsed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementPercentComplete.IsSet() {
		localVarQueryParams.Add("movement.percent_complete", parameterToString(localVarOptionals.MovementPercentComplete.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementState.IsSet() {
		localVarQueryParams.Add("movement.state", parameterToString(localVarOptionals.MovementState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementDestinationAggregateUuid.IsSet() {
		localVarQueryParams.Add("movement.destination_aggregate.uuid", parameterToString(localVarOptionals.MovementDestinationAggregateUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementDestinationAggregateName.IsSet() {
		localVarQueryParams.Add("movement.destination_aggregate.name", parameterToString(localVarOptionals.MovementDestinationAggregateName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementCutoverWindow.IsSet() {
		localVarQueryParams.Add("movement.cutover_window", parameterToString(localVarOptionals.MovementCutoverWindow.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnapshotPolicyName.IsSet() {
		localVarQueryParams.Add("snapshot_policy.name", parameterToString(localVarOptionals.SnapshotPolicyName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnapshotPolicyUuid.IsSet() {
		localVarQueryParams.Add("snapshot_policy.uuid", parameterToString(localVarOptionals.SnapshotPolicyUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarQueryParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnaplockType.IsSet() {
		localVarQueryParams.Add("snaplock.type", parameterToString(localVarOptionals.SnaplockType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnaplockComplianceClockTime.IsSet() {
		localVarQueryParams.Add("snaplock.compliance_clock_time", parameterToString(localVarOptionals.SnaplockComplianceClockTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnaplockPrivilegedDelete.IsSet() {
		localVarQueryParams.Add("snaplock.privileged_delete", parameterToString(localVarOptionals.SnaplockPrivilegedDelete.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnaplockAutocommitPeriod.IsSet() {
		localVarQueryParams.Add("snaplock.autocommit_period", parameterToString(localVarOptionals.SnaplockAutocommitPeriod.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnaplockIsAuditLog.IsSet() {
		localVarQueryParams.Add("snaplock.is_audit_log", parameterToString(localVarOptionals.SnaplockIsAuditLog.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnaplockAppendModeEnabled.IsSet() {
		localVarQueryParams.Add("snaplock.append_mode_enabled", parameterToString(localVarOptionals.SnaplockAppendModeEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnaplockExpiryTime.IsSet() {
		localVarQueryParams.Add("snaplock.expiry_time", parameterToString(localVarOptionals.SnaplockExpiryTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnaplockRetentionMaximum.IsSet() {
		localVarQueryParams.Add("snaplock.retention.maximum", parameterToString(localVarOptionals.SnaplockRetentionMaximum.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnaplockRetentionMinimum.IsSet() {
		localVarQueryParams.Add("snaplock.retention.minimum", parameterToString(localVarOptionals.SnaplockRetentionMinimum.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnaplockRetentionDefault.IsSet() {
		localVarQueryParams.Add("snaplock.retention.default", parameterToString(localVarOptionals.SnaplockRetentionDefault.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnaplockLitigationCount.IsSet() {
		localVarQueryParams.Add("snaplock.litigation_count", parameterToString(localVarOptionals.SnaplockLitigationCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreateTime.IsSet() {
		localVarQueryParams.Add("create_time", parameterToString(localVarOptionals.CreateTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EfficiencyDedupe.IsSet() {
		localVarQueryParams.Add("efficiency.dedupe", parameterToString(localVarOptionals.EfficiencyDedupe.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EfficiencyCrossVolumeDedupe.IsSet() {
		localVarQueryParams.Add("efficiency.cross_volume_dedupe", parameterToString(localVarOptionals.EfficiencyCrossVolumeDedupe.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EfficiencyCompression.IsSet() {
		localVarQueryParams.Add("efficiency.compression", parameterToString(localVarOptionals.EfficiencyCompression.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EfficiencyCompaction.IsSet() {
		localVarQueryParams.Add("efficiency.compaction", parameterToString(localVarOptionals.EfficiencyCompaction.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AutosizeShrinkThreshold.IsSet() {
		localVarQueryParams.Add("autosize.shrink_threshold", parameterToString(localVarOptionals.AutosizeShrinkThreshold.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AutosizeMode.IsSet() {
		localVarQueryParams.Add("autosize.mode", parameterToString(localVarOptionals.AutosizeMode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AutosizeGrowThreshold.IsSet() {
		localVarQueryParams.Add("autosize.grow_threshold", parameterToString(localVarOptionals.AutosizeGrowThreshold.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AutosizeMaximum.IsSet() {
		localVarQueryParams.Add("autosize.maximum", parameterToString(localVarOptionals.AutosizeMaximum.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AutosizeMinimum.IsSet() {
		localVarQueryParams.Add("autosize.minimum", parameterToString(localVarOptionals.AutosizeMinimum.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Comment.IsSet() {
		localVarQueryParams.Add("comment", parameterToString(localVarOptionals.Comment.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.GuaranteeType.IsSet() {
		localVarQueryParams.Add("guarantee.type", parameterToString(localVarOptionals.GuaranteeType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.GuaranteeHonored.IsSet() {
		localVarQueryParams.Add("guarantee.honored", parameterToString(localVarOptionals.GuaranteeHonored.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MetricTimestamp.IsSet() {
		localVarQueryParams.Add("metric.timestamp", parameterToString(localVarOptionals.MetricTimestamp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MetricIopsTotal.IsSet() {
		localVarQueryParams.Add("metric.iops.total", parameterToString(localVarOptionals.MetricIopsTotal.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MetricIopsOther.IsSet() {
		localVarQueryParams.Add("metric.iops.other", parameterToString(localVarOptionals.MetricIopsOther.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MetricIopsWrite.IsSet() {
		localVarQueryParams.Add("metric.iops.write", parameterToString(localVarOptionals.MetricIopsWrite.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MetricIopsRead.IsSet() {
		localVarQueryParams.Add("metric.iops.read", parameterToString(localVarOptionals.MetricIopsRead.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MetricDuration.IsSet() {
		localVarQueryParams.Add("metric.duration", parameterToString(localVarOptionals.MetricDuration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MetricThroughputTotal.IsSet() {
		localVarQueryParams.Add("metric.throughput.total", parameterToString(localVarOptionals.MetricThroughputTotal.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MetricThroughputOther.IsSet() {
		localVarQueryParams.Add("metric.throughput.other", parameterToString(localVarOptionals.MetricThroughputOther.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MetricThroughputWrite.IsSet() {
		localVarQueryParams.Add("metric.throughput.write", parameterToString(localVarOptionals.MetricThroughputWrite.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MetricThroughputRead.IsSet() {
		localVarQueryParams.Add("metric.throughput.read", parameterToString(localVarOptionals.MetricThroughputRead.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MetricLatencyTotal.IsSet() {
		localVarQueryParams.Add("metric.latency.total", parameterToString(localVarOptionals.MetricLatencyTotal.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MetricLatencyOther.IsSet() {
		localVarQueryParams.Add("metric.latency.other", parameterToString(localVarOptionals.MetricLatencyOther.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MetricLatencyWrite.IsSet() {
		localVarQueryParams.Add("metric.latency.write", parameterToString(localVarOptionals.MetricLatencyWrite.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MetricLatencyRead.IsSet() {
		localVarQueryParams.Add("metric.latency.read", parameterToString(localVarOptionals.MetricLatencyRead.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MetricStatus.IsSet() {
		localVarQueryParams.Add("metric.status", parameterToString(localVarOptionals.MetricStatus.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QuotaState.IsSet() {
		localVarQueryParams.Add("quota.state", parameterToString(localVarOptionals.QuotaState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TieringPolicy.IsSet() {
		localVarQueryParams.Add("tiering.policy", parameterToString(localVarOptionals.TieringPolicy.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Style.IsSet() {
		localVarQueryParams.Add("style", parameterToString(localVarOptionals.Style.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EncryptionState.IsSet() {
		localVarQueryParams.Add("encryption.state", parameterToString(localVarOptionals.EncryptionState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EncryptionKeyId.IsSet() {
		localVarQueryParams.Add("encryption.key_id", parameterToString(localVarOptionals.EncryptionKeyId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EncryptionRekey.IsSet() {
		localVarQueryParams.Add("encryption.rekey", parameterToString(localVarOptionals.EncryptionRekey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EncryptionStatusCode.IsSet() {
		localVarQueryParams.Add("encryption.status.code", parameterToString(localVarOptionals.EncryptionStatusCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EncryptionStatusMessage.IsSet() {
		localVarQueryParams.Add("encryption.status.message", parameterToString(localVarOptionals.EncryptionStatusMessage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EncryptionEnabled.IsSet() {
		localVarQueryParams.Add("encryption.enabled", parameterToString(localVarOptionals.EncryptionEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EncryptionType.IsSet() {
		localVarQueryParams.Add("encryption.type", parameterToString(localVarOptionals.EncryptionType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FilesUsed.IsSet() {
		localVarQueryParams.Add("files.used", parameterToString(localVarOptionals.FilesUsed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FilesMaximum.IsSet() {
		localVarQueryParams.Add("files.maximum", parameterToString(localVarOptionals.FilesMaximum.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AggregatesUuid.IsSet() {
		localVarQueryParams.Add("aggregates.uuid", parameterToString(localVarOptionals.AggregatesUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AggregatesName.IsSet() {
		localVarQueryParams.Add("aggregates.name", parameterToString(localVarOptionals.AggregatesName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Language.IsSet() {
		localVarQueryParams.Add("language", parameterToString(localVarOptionals.Language.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApplicationName.IsSet() {
		localVarQueryParams.Add("application.name", parameterToString(localVarOptionals.ApplicationName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApplicationUuid.IsSet() {
		localVarQueryParams.Add("application.uuid", parameterToString(localVarOptionals.ApplicationUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v VolumeResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// VolumeCollectionPerformanceMetricsGetOpts Optional parameters for the method 'VolumeCollectionPerformanceMetricsGet'
type VolumeCollectionPerformanceMetricsGetOpts struct {
	Timestamp       optional.String
	IopsTotal       optional.Int32
	IopsOther       optional.Int32
	IopsWrite       optional.Int32
	IopsRead        optional.Int32
	Duration        optional.String
	ThroughputTotal optional.Int32
	ThroughputOther optional.Int32
	ThroughputWrite optional.Int32
	ThroughputRead  optional.Int32
	LatencyTotal    optional.Int32
	LatencyOther    optional.Int32
	LatencyWrite    optional.Int32
	LatencyRead     optional.Int32
	Status          optional.String
	ReturnTimeout   optional.Int32
	Fields          optional.Interface
	MaxRecords      optional.Int32
	OrderBy         optional.Interface
	ReturnRecords   optional.Bool
	Interval        optional.String
}

/*
VolumeCollectionPerformanceMetricsGet Method for VolumeCollectionPerformanceMetricsGet
Retrieves historical performance metrics for a volume.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Unique identifier of the volume.
 * @param optional nil or *VolumeCollectionPerformanceMetricsGetOpts - Optional Parameters:
 * @param "Timestamp" (optional.String) -  Filter by timestamp
 * @param "IopsTotal" (optional.Int32) -  Filter by iops.total
 * @param "IopsOther" (optional.Int32) -  Filter by iops.other
 * @param "IopsWrite" (optional.Int32) -  Filter by iops.write
 * @param "IopsRead" (optional.Int32) -  Filter by iops.read
 * @param "Duration" (optional.String) -  Filter by duration
 * @param "ThroughputTotal" (optional.Int32) -  Filter by throughput.total
 * @param "ThroughputOther" (optional.Int32) -  Filter by throughput.other
 * @param "ThroughputWrite" (optional.Int32) -  Filter by throughput.write
 * @param "ThroughputRead" (optional.Int32) -  Filter by throughput.read
 * @param "LatencyTotal" (optional.Int32) -  Filter by latency.total
 * @param "LatencyOther" (optional.Int32) -  Filter by latency.other
 * @param "LatencyWrite" (optional.Int32) -  Filter by latency.write
 * @param "LatencyRead" (optional.Int32) -  Filter by latency.read
 * @param "Status" (optional.String) -  Filter by status
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "Interval" (optional.String) -  The time range for the data. Examples can be 1h, 1d, 1m, 1w, 1y. The period for each time range is as follows: * 1h: Metrics over the most recent hour sampled over 15 seconds. * 1d: Metrics over the most recent day sampled over 4 minutes. * 1w: Metrics over the most recent week sampled over 30 minutes. * 1m: Metrics over the most recent month sampled over 2 hours. * 1y: Metrics over the most recent year sampled over a day.
@return VolumeMetricsResponse
*/
func (a *StorageApiService) VolumeCollectionPerformanceMetricsGet(ctx _context.Context, uuid string, localVarOptionals *VolumeCollectionPerformanceMetricsGetOpts) (VolumeMetricsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  VolumeMetricsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/volumes/{uuid}/metrics"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Timestamp.IsSet() {
		localVarQueryParams.Add("timestamp", parameterToString(localVarOptionals.Timestamp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IopsTotal.IsSet() {
		localVarQueryParams.Add("iops.total", parameterToString(localVarOptionals.IopsTotal.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IopsOther.IsSet() {
		localVarQueryParams.Add("iops.other", parameterToString(localVarOptionals.IopsOther.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IopsWrite.IsSet() {
		localVarQueryParams.Add("iops.write", parameterToString(localVarOptionals.IopsWrite.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IopsRead.IsSet() {
		localVarQueryParams.Add("iops.read", parameterToString(localVarOptionals.IopsRead.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Duration.IsSet() {
		localVarQueryParams.Add("duration", parameterToString(localVarOptionals.Duration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ThroughputTotal.IsSet() {
		localVarQueryParams.Add("throughput.total", parameterToString(localVarOptionals.ThroughputTotal.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ThroughputOther.IsSet() {
		localVarQueryParams.Add("throughput.other", parameterToString(localVarOptionals.ThroughputOther.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ThroughputWrite.IsSet() {
		localVarQueryParams.Add("throughput.write", parameterToString(localVarOptionals.ThroughputWrite.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ThroughputRead.IsSet() {
		localVarQueryParams.Add("throughput.read", parameterToString(localVarOptionals.ThroughputRead.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LatencyTotal.IsSet() {
		localVarQueryParams.Add("latency.total", parameterToString(localVarOptionals.LatencyTotal.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LatencyOther.IsSet() {
		localVarQueryParams.Add("latency.other", parameterToString(localVarOptionals.LatencyOther.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LatencyWrite.IsSet() {
		localVarQueryParams.Add("latency.write", parameterToString(localVarOptionals.LatencyWrite.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LatencyRead.IsSet() {
		localVarQueryParams.Add("latency.read", parameterToString(localVarOptionals.LatencyRead.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Status.IsSet() {
		localVarQueryParams.Add("status", parameterToString(localVarOptionals.Status.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Interval.IsSet() {
		localVarQueryParams.Add("interval", parameterToString(localVarOptionals.Interval.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v VolumeMetricsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
VolumeCreate Method for VolumeCreate
Creates a volume on a specified SVM and storage aggregates. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the volume. * &#x60;name&#x60; - Name of the volume. * &#x60;aggregates.name&#x60; or &#x60;aggregates.uuid&#x60; - Existing aggregates in which to create the volume. ### Default property values * &#x60;state&#x60; -  _online_ * &#x60;size&#x60; - _20MB_ * &#x60;style&#x60; - _flexvol_ * &#x60;type&#x60; - _rw_ * &#x60;encryption.enabled&#x60; - _false_ * &#x60;snapshot_policy.name&#x60; - _default_ * &#x60;gaurantee.type&#x60; - _volume_ ### Related ONTAP commands * &#x60;volume create&#x60; * &#x60;volume clone create&#x60;  ### Learn more * [&#x60;DOC /storage/volumes&#x60;](#docs-storage-storage_volumes)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info Info specification
@return JobLinkResponse
*/
func (a *StorageApiService) VolumeCreate(ctx _context.Context, info Volume) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/volumes"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
VolumeDelete Method for VolumeDelete
Deletes a volume. If the UUID belongs to a volume, all of its blocks are freed and returned to its containing aggregate. If a volume is online, it is offlined before deletion. ### Related ONTAP commands * &#x60;volume delete&#x60; * &#x60;volume clone delete&#x60;  ### Learn more * [&#x60;DOC /storage/volumes&#x60;](#docs-storage-storage_volumes)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Unique identifier of the volume.
@return JobLinkResponse
*/
func (a *StorageApiService) VolumeDelete(ctx _context.Context, uuid string) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/volumes/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// VolumeGetOpts Optional parameters for the method 'VolumeGet'
type VolumeGetOpts struct {
	Fields optional.Interface
}

/*
VolumeGet Method for VolumeGet
Retrieves a volume. The GET API can be used to retrieve the quota state for a FlexVol or a FlexGroup volume. ### Expensive properties There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the &#x60;fields&#x60; query parameter. See [&#x60;DOC Requesting specific fields&#x60;](#docs-docs-Requesting-specific-fields) to learn more. * &#x60;application.*&#x60; * &#x60;encryption.*&#x60; * &#x60;clone.parent_snapshot.name&#x60; * &#x60;clone.parent_snapshot.uuid&#x60; * &#x60;clone.parent_svm.name&#x60; * &#x60;clone.parent_svm.uuid&#x60; * &#x60;clone.parent_volume.name&#x60; * &#x60;clone.parent_volume.uuid&#x60; * &#x60;clone.split_complete_percent&#x60; * &#x60;clone.split_estimate&#x60; * &#x60;clone.split_initiated&#x60; * &#x60;efficiency.*&#x60; * &#x60;error_state.*&#x60; * &#x60;files.*&#x60; * &#x60;nas.export_policy.id&#x60; * &#x60;nas.gid&#x60; * &#x60;nas.path&#x60; * &#x60;nas.security_style&#x60; * &#x60;nas.uid&#x60; * &#x60;nas.unix_permissions&#x60; * &#x60;snaplock.*&#x60; * &#x60;restore_to.*&#x60; * &#x60;snapshot_policy.uuid&#x60; * &#x60;quota.*&#x60; * &#x60;qos.*&#x60; * &#x60;flexcache_endpoint_type&#x60; * &#x60;space.block_storage_inactive_user_data&#x60; * &#x60;space.capacity_tier_footprint&#x60; * &#x60;space.footprint&#x60; * &#x60;space.over_provisioned&#x60; * &#x60;space.metadata&#x60; * &#x60;space.logical_space.*&#x60; * &#x60;space.snapshot.*&#x60; * &#x60;guarantee.*&#x60; * &#x60;autosize.*&#x60; * &#x60;movement.*&#x60; * &#x60;statistics.*&#x60; ### Related ONTAP commands * &#x60;volume show&#x60; * &#x60;volume clone show&#x60; * &#x60;volume efficiency show&#x60; * &#x60;volume encryption show&#x60; * &#x60;volume flexcache show&#x60; * &#x60;volume flexgroup show&#x60; * &#x60;volume move show&#x60; * &#x60;volume quota show&#x60; * &#x60;volume show-space&#x60; * &#x60;volume snaplock show&#x60;  ### Learn more * [&#x60;DOC /storage/volumes&#x60;](#docs-storage-storage_volumes)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Unique identifier of the volume.
 * @param optional nil or *VolumeGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return Volume
*/
func (a *StorageApiService) VolumeGet(ctx _context.Context, uuid string, localVarOptionals *VolumeGetOpts) (Volume, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Volume
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/volumes/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Volume
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// VolumeModifyOpts Optional parameters for the method 'VolumeModify'
type VolumeModifyOpts struct {
	RestoreToSnapshotUuid            optional.String
	RestoreToSnapshotName            optional.String
	SizingMethod                     optional.String
	MovementDestinationAggregateName optional.String
	MovementDestinationAggregateUuid optional.String
	ValidateOnly                     optional.Bool
	Info                             optional.Interface
}

/*
VolumeModify Method for VolumeModify
Updates the attributes of a volume. For movement, use the \&quot;validate_only\&quot; field on the request to validate but not perform the operation. The PATCH API can be used to enable or disable quotas for a FlexVol or a FlexGroup volume. ### Related ONTAP commands * &#x60;volume modify&#x60; * &#x60;volume clone modify&#x60; * &#x60;volume efficiency modify&#x60; * &#x60;volume quota on&#x60; * &#x60;volume quota off&#x60;  ### Learn more * [&#x60;DOC /storage/volumes&#x60;](#docs-storage-storage_volumes)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Unique identifier of the volume.
 * @param optional nil or *VolumeModifyOpts - Optional Parameters:
 * @param "RestoreToSnapshotUuid" (optional.String) -  UUID of the Snapshot copy to restore volume to the point in time the Snapshot copy was taken.
 * @param "RestoreToSnapshotName" (optional.String) -  Name of the Snapshot copy to restore volume to the point in time the Snapshot copy was taken.
 * @param "SizingMethod" (optional.String) -  Represents the method to modify the size of a Flexgroup. The following methods are supported: * use_existing_resources - Increases or decreases the size of the FlexGroup by increasing or decreasing the size of the current FlexGroup resources * add_new_resources - Increases the size of the FlexGroup by adding new resources
 * @param "MovementDestinationAggregateName" (optional.String) -  Name of the aggregates to which the specified volume can be moved.
 * @param "MovementDestinationAggregateUuid" (optional.String) -  UUID of the aggregates to which the specified volume can be moved.
 * @param "ValidateOnly" (optional.Bool) -  Validate the operation and its parameters, without actually performing the operation.
 * @param "Info" (optional.Interface of Volume) -  Info specification
@return JobLinkResponse
*/
func (a *StorageApiService) VolumeModify(ctx _context.Context, uuid string, localVarOptionals *VolumeModifyOpts) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/volumes/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.RestoreToSnapshotUuid.IsSet() {
		localVarQueryParams.Add("restore_to.snapshot.uuid", parameterToString(localVarOptionals.RestoreToSnapshotUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RestoreToSnapshotName.IsSet() {
		localVarQueryParams.Add("restore_to.snapshot.name", parameterToString(localVarOptionals.RestoreToSnapshotName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SizingMethod.IsSet() {
		localVarQueryParams.Add("sizing_method", parameterToString(localVarOptionals.SizingMethod.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementDestinationAggregateName.IsSet() {
		localVarQueryParams.Add("movement.destination_aggregate.name", parameterToString(localVarOptionals.MovementDestinationAggregateName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementDestinationAggregateUuid.IsSet() {
		localVarQueryParams.Add("movement.destination_aggregate.uuid", parameterToString(localVarOptionals.MovementDestinationAggregateUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ValidateOnly.IsSet() {
		localVarQueryParams.Add("validate_only", parameterToString(localVarOptionals.ValidateOnly.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(Volume)
		if !localVarOptionalInfook {
			return localVarReturnValue, nil, reportError("info should be Volume")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
