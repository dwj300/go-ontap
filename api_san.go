/*
 * ONTAP REST API
 *
 * ONTAP 9.6 adds support for an expansive RESTful API. The documentation below provides information about the types of API calls available to you, as well as details about using each API endpoint. You can learn more about the ONTAP REST API and ONTAP in the ONTAP 9 Documentation Center:  http://docs.netapp.com/ontap-9/topic/com.netapp.doc.dot-rest-api/home.html. NetApp welcomes your comments and suggestions about the ONTAP REST API and the documentation for its use.</br> **Using the ONTAP 9.6 REST API online documentation** Each API method includes usage examples, as well as a model that displays all the required and optional properties supported by the method. Click the _Model_ link, available with each API method, to see all the required and optional properties supported by each method.
 *
 * API version: v1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package ontap

import (
	_context "context"
	"github.com/antihax/optional"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// SANApiService SANApi service
type SANApiService service

/*
FcLoginCollectionGet Method for FcLoginCollectionGet
Retrieves FC logins. ### Related ONTAP commands * &#x60;vserver fcp initiator show&#x60; ### Learn more * SAN: [&#x60;DOC /network/fc/logins&#x60;](#docs-SAN-network_fc_logins) * NVMe: [&#x60;DOC /network/fc/logins&#x60;](#docs-NVMe-network_fc_logins)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *FcLoginCollectionGetOpts - Optional Parameters:
 * @param "Protocol" (optional.String) -  Filter by protocol
 * @param "InitiatorPortAddress" (optional.String) -  Filter by initiator.port_address
 * @param "InitiatorWwpn" (optional.String) -  Filter by initiator.wwpn
 * @param "InitiatorWwnn" (optional.String) -  Filter by initiator.wwnn
 * @param "InitiatorAliases" (optional.String) -  Filter by initiator.aliases
 * @param "IgroupsUuid" (optional.String) -  Filter by igroups.uuid
 * @param "IgroupsName" (optional.String) -  Filter by igroups.name
 * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
 * @param "SvmName" (optional.String) -  Filter by svm.name
 * @param "InterfaceName" (optional.String) -  Filter by interface.name
 * @param "InterfaceWwpn" (optional.String) -  Filter by interface.wwpn
 * @param "InterfaceUuid" (optional.String) -  Filter by interface.uuid
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return FcLoginResponse
*/
func (a *SANApiService) FcLoginCollectionGet(ctx _context.Context, localVarOptionals *FcLoginCollectionGetOpts) (FcLoginResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FcLoginResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/fc/logins"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Protocol.IsSet() {
		localVarQueryParams.Add("protocol", parameterToString(localVarOptionals.Protocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitiatorPortAddress.IsSet() {
		localVarQueryParams.Add("initiator.port_address", parameterToString(localVarOptionals.InitiatorPortAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitiatorWwpn.IsSet() {
		localVarQueryParams.Add("initiator.wwpn", parameterToString(localVarOptionals.InitiatorWwpn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitiatorWwnn.IsSet() {
		localVarQueryParams.Add("initiator.wwnn", parameterToString(localVarOptionals.InitiatorWwnn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitiatorAliases.IsSet() {
		localVarQueryParams.Add("initiator.aliases", parameterToString(localVarOptionals.InitiatorAliases.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IgroupsUuid.IsSet() {
		localVarQueryParams.Add("igroups.uuid", parameterToString(localVarOptionals.IgroupsUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IgroupsName.IsSet() {
		localVarQueryParams.Add("igroups.name", parameterToString(localVarOptionals.IgroupsName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InterfaceName.IsSet() {
		localVarQueryParams.Add("interface.name", parameterToString(localVarOptionals.InterfaceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InterfaceWwpn.IsSet() {
		localVarQueryParams.Add("interface.wwpn", parameterToString(localVarOptionals.InterfaceWwpn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InterfaceUuid.IsSet() {
		localVarQueryParams.Add("interface.uuid", parameterToString(localVarOptionals.InterfaceUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v FcLoginResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
FcLoginGet Method for FcLoginGet
Retrieves an FC login. ### Related ONTAP commands * &#x60;vserver fcp initiator show&#x60; ### Learn more * SAN: [&#x60;DOC /network/fc/logins&#x60;](#docs-SAN-network_fc_logins) * NVMe: [&#x60;DOC /network/fc/logins&#x60;](#docs-NVMe-network_fc_logins)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param interfaceUuid The unique identifier of the FC interface through which the initiator logged in.
 * @param initiatorWwpn The world wide port name (WWPN) of the initiator.
 * @param optional nil or *FcLoginGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return FcLogin
*/
func (a *SANApiService) FcLoginGet(ctx _context.Context, interfaceUuid string, initiatorWwpn string, localVarOptionals *FcLoginGetOpts) (FcLogin, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FcLogin
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/fc/logins/{interface.uuid}/{initiator.wwpn}"
	localVarPath = strings.Replace(localVarPath, "{"+"interface.uuid"+"}", _neturl.QueryEscape(parameterToString(interfaceUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"initiator.wwpn"+"}", _neturl.QueryEscape(parameterToString(initiatorWwpn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v FcLogin
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// FcpServiceCollectionGetOpts Optional parameters for the method 'FcpServiceCollectionGet'
type FcpServiceCollectionGetOpts struct {
	SvmUuid       optional.String
	SvmName       optional.String
	TargetName    optional.String
	Enabled       optional.Bool
	Fields        optional.Interface
	MaxRecords    optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy       optional.Interface
}

/*
FcpServiceCollectionGet Method for FcpServiceCollectionGet
Retrieves FC Protocol services. ### Related ONTAP commands * &#x60;vserver fcp show&#x60; ### Learn more * [&#x60;DOC /protocols/san/fcp/services&#x60;](#docs-SAN-protocols_san_fcp_services)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *FcpServiceCollectionGetOpts - Optional Parameters:
 * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
 * @param "SvmName" (optional.String) -  Filter by svm.name
 * @param "TargetName" (optional.String) -  Filter by target.name
 * @param "Enabled" (optional.Bool) -  Filter by enabled
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return FcpServiceResponse
*/
func (a *SANApiService) FcpServiceCollectionGet(ctx _context.Context, localVarOptionals *FcpServiceCollectionGetOpts) (FcpServiceResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FcpServiceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/fcp/services"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TargetName.IsSet() {
		localVarQueryParams.Add("target.name", parameterToString(localVarOptionals.TargetName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarQueryParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v FcpServiceResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
FcpServiceCreate Method for FcpServiceCreate
Creates an FC Protocol service. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the FC service. ### Related ONTAP commands * &#x60;vserver fcp create&#x60; ### Learn more * [&#x60;DOC /protocols/san/fcp/services&#x60;](#docs-SAN-protocols_san_fcp_services)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info The property values for the new FC Protocol service.
@return FcpServiceResponse
*/
func (a *SANApiService) FcpServiceCreate(ctx _context.Context, info FcpService) (FcpServiceResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FcpServiceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/fcp/services"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 201 {
			var v FcpServiceResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
FcpServiceDelete Method for FcpServiceDelete
Deletes an FC Protocol service. An FC Protocol service must be disabled before it can be deleted. ### Related ONTAP commands * &#x60;vserver fcp delete&#x60; ### Learn more * [&#x60;DOC /protocols/san/fcp/services&#x60;](#docs-SAN-protocols_san_fcp_services)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid The unique identifier of the SVM for which to delete the FC Protocol service.
*/
func (a *SANApiService) FcpServiceDelete(ctx _context.Context, svmUuid string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/fcp/services/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", _neturl.QueryEscape(parameterToString(svmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// FcpServiceGetOpts Optional parameters for the method 'FcpServiceGet'
type FcpServiceGetOpts struct {
	Fields optional.Interface
}

/*
FcpServiceGet Method for FcpServiceGet
Retrieves a Fibre Channel Protocol service. ### Related ONTAP commands * &#x60;vserver fcp show&#x60; ### Learn more * [&#x60;DOC /protocols/san/fcp/services&#x60;](#docs-SAN-protocols_san_fcp_services)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid The unique identifier of the SVM for which to retrieve the FC Protocol service.
 * @param optional nil or *FcpServiceGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return FcpService
*/
func (a *SANApiService) FcpServiceGet(ctx _context.Context, svmUuid string, localVarOptionals *FcpServiceGetOpts) (FcpService, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FcpService
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/fcp/services/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", _neturl.QueryEscape(parameterToString(svmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v FcpService
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
FcpServiceModify Method for FcpServiceModify
Updates an FC Protocol service. ### Related ONTAP commands * &#x60;vserver fcp modify&#x60; * &#x60;vserver fcp start&#x60; * &#x60;vserver fcp stop&#x60; ### Learn more * [&#x60;DOC /protocols/san/fcp/services&#x60;](#docs-SAN-protocols_san_fcp_services)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid The unique identifier of the SVM whose FC Protocol service is to be patched.
 * @param info The new property values for the FC Protocol service.
*/
func (a *SANApiService) FcpServiceModify(ctx _context.Context, svmUuid string, info FcpService) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/fcp/services/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", _neturl.QueryEscape(parameterToString(svmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// IgroupCollectionGetOpts Optional parameters for the method 'IgroupCollectionGet'
type IgroupCollectionGetOpts struct {
	DeleteOnUnmap            optional.Bool
	Protocol                 optional.String
	LunMapsLogicalUnitNumber optional.Int32
	LunMapsLunNodeUuid       optional.String
	LunMapsLunNodeName       optional.String
	LunMapsLunUuid           optional.String
	LunMapsLunName           optional.String
	InitiatorsIgroupUuid     optional.String
	InitiatorsName           optional.String
	Uuid                     optional.String
	OsType                   optional.String
	SvmUuid                  optional.String
	SvmName                  optional.String
	Name                     optional.String
	Fields                   optional.Interface
	MaxRecords               optional.Int32
	ReturnRecords            optional.Bool
	ReturnTimeout            optional.Int32
	OrderBy                  optional.Interface
}

/*
IgroupCollectionGet Method for IgroupCollectionGet
Retrieves initiator groups. ### Expensive properties There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the &#x60;fields&#x60; query parameter. See [&#x60;DOC Requesting specific fields&#x60;](#docs-docs-Requesting-specific-fields) to learn more. * &#x60;lun_maps.*&#x60; ### Related ONTAP commands * &#x60;lun igroup show&#x60; * &#x60;lun mapping show&#x60; ### Learn more * [&#x60;DOC /protocols/san/igroups&#x60;](#docs-SAN-protocols_san_igroups)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *IgroupCollectionGetOpts - Optional Parameters:
 * @param "DeleteOnUnmap" (optional.Bool) -  Filter by delete_on_unmap
 * @param "Protocol" (optional.String) -  Filter by protocol
 * @param "LunMapsLogicalUnitNumber" (optional.Int32) -  Filter by lun_maps.logical_unit_number
 * @param "LunMapsLunNodeUuid" (optional.String) -  Filter by lun_maps.lun.node.uuid
 * @param "LunMapsLunNodeName" (optional.String) -  Filter by lun_maps.lun.node.name
 * @param "LunMapsLunUuid" (optional.String) -  Filter by lun_maps.lun.uuid
 * @param "LunMapsLunName" (optional.String) -  Filter by lun_maps.lun.name
 * @param "InitiatorsIgroupUuid" (optional.String) -  Filter by initiators.igroup.uuid
 * @param "InitiatorsName" (optional.String) -  Filter by initiators.name
 * @param "Uuid" (optional.String) -  Filter by uuid
 * @param "OsType" (optional.String) -  Filter by os_type
 * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
 * @param "SvmName" (optional.String) -  Filter by svm.name
 * @param "Name" (optional.String) -  Filter by name
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return IgroupResponse
*/
func (a *SANApiService) IgroupCollectionGet(ctx _context.Context, localVarOptionals *IgroupCollectionGetOpts) (IgroupResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IgroupResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/igroups"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.DeleteOnUnmap.IsSet() {
		localVarQueryParams.Add("delete_on_unmap", parameterToString(localVarOptionals.DeleteOnUnmap.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Protocol.IsSet() {
		localVarQueryParams.Add("protocol", parameterToString(localVarOptionals.Protocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LunMapsLogicalUnitNumber.IsSet() {
		localVarQueryParams.Add("lun_maps.logical_unit_number", parameterToString(localVarOptionals.LunMapsLogicalUnitNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LunMapsLunNodeUuid.IsSet() {
		localVarQueryParams.Add("lun_maps.lun.node.uuid", parameterToString(localVarOptionals.LunMapsLunNodeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LunMapsLunNodeName.IsSet() {
		localVarQueryParams.Add("lun_maps.lun.node.name", parameterToString(localVarOptionals.LunMapsLunNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LunMapsLunUuid.IsSet() {
		localVarQueryParams.Add("lun_maps.lun.uuid", parameterToString(localVarOptionals.LunMapsLunUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LunMapsLunName.IsSet() {
		localVarQueryParams.Add("lun_maps.lun.name", parameterToString(localVarOptionals.LunMapsLunName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitiatorsIgroupUuid.IsSet() {
		localVarQueryParams.Add("initiators.igroup.uuid", parameterToString(localVarOptionals.InitiatorsIgroupUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitiatorsName.IsSet() {
		localVarQueryParams.Add("initiators.name", parameterToString(localVarOptionals.InitiatorsName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OsType.IsSet() {
		localVarQueryParams.Add("os_type", parameterToString(localVarOptionals.OsType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v IgroupResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
IgroupCreate Method for IgroupCreate
Creates an initiator group. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the initiator group. * &#x60;name&#x60; - Name of the initiator group. * &#x60;os_type&#x60; - Operating system of the initiator group&#39;s initiators. ### Recommended optional properties * &#x60;initiators.name&#x60; - Name(s) of initiator group&#39;s initiators. This property can be used to create the initiator group and populate it with initiators in a single request. ### Default property values If not specified in POST, the following default property values are assigned. * &#x60;protocol&#x60; - _mixed_ - Data protocol of the initiator group&#39;s initiators. ### Learn more * [&#x60;DOC /protocols/san/igroups&#x60;](#docs-SAN-protocols_san_igroups)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info The property values for the new initiator group.
@return IgroupResponse
*/
func (a *SANApiService) IgroupCreate(ctx _context.Context, info Igroup) (IgroupResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IgroupResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/igroups"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 201 {
			var v IgroupResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// IgroupDeleteOpts Optional parameters for the method 'IgroupDelete'
type IgroupDeleteOpts struct {
	AllowDeleteWhileMapped optional.Bool
}

/*
IgroupDelete Method for IgroupDelete
Deletes an initiator group. ### Related ONTAP commands * &#x60;lun igroup delete&#x60; ### Learn more * [&#x60;DOC /protocols/san/igroups&#x60;](#docs-SAN-protocols_san_igroups)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid The unique identifier of the initiator group.
 * @param optional nil or *IgroupDeleteOpts - Optional Parameters:
 * @param "AllowDeleteWhileMapped" (optional.Bool) -  Allow deletion of a mapped initiator group.<br/> Deleting a mapped initiator group makes the LUNs to which the initiator group is mapped no longer available. This might cause a disruption in the availability of data.<br/> <b>This parameter should be used with caution.</b>
*/
func (a *SANApiService) IgroupDelete(ctx _context.Context, uuid string, localVarOptionals *IgroupDeleteOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/igroups/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.AllowDeleteWhileMapped.IsSet() {
		localVarQueryParams.Add("allow_delete_while_mapped", parameterToString(localVarOptionals.AllowDeleteWhileMapped.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// IgroupGetOpts Optional parameters for the method 'IgroupGet'
type IgroupGetOpts struct {
	Fields optional.Interface
}

/*
IgroupGet Method for IgroupGet
Retrieves an initiator group. ### Expensive properties There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the &#x60;fields&#x60; query parameter. See [&#x60;DOC Requesting specific fields&#x60;](#docs-docs-Requesting-specific-fields) to learn more. * &#x60;lun_maps.*&#x60; ### Related ONTAP commands * &#x60;lun igroup show&#x60; * &#x60;lun mapping show&#x60; ### Learn more * [&#x60;DOC /protocols/san/igroups&#x60;](#docs-SAN-protocols_san_igroups)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid The unique identifier of the initiator group.
 * @param optional nil or *IgroupGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return Igroup
*/
func (a *SANApiService) IgroupGet(ctx _context.Context, uuid string, localVarOptionals *IgroupGetOpts) (Igroup, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Igroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/igroups/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Igroup
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// IgroupInitiatorCollectionGetOpts Optional parameters for the method 'IgroupInitiatorCollectionGet'
type IgroupInitiatorCollectionGetOpts struct {
	Fields        optional.Interface
	MaxRecords    optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy       optional.Interface
}

/*
IgroupInitiatorCollectionGet Method for IgroupInitiatorCollectionGet
Retrieves initiators of an initiator group. ### Related ONTAP commands * &#x60;lun igroup show&#x60; ### Learn more * [&#x60;DOC /protocols/san/igroups&#x60;](#docs-SAN-protocols_san_igroups)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param igroupUuid The unique identifier of the initiator group.
 * @param optional nil or *IgroupInitiatorCollectionGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return IgroupInitiatorResponse
*/
func (a *SANApiService) IgroupInitiatorCollectionGet(ctx _context.Context, igroupUuid string, localVarOptionals *IgroupInitiatorCollectionGetOpts) (IgroupInitiatorResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IgroupInitiatorResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/igroups/{igroup.uuid}/initiators"
	localVarPath = strings.Replace(localVarPath, "{"+"igroup.uuid"+"}", _neturl.QueryEscape(parameterToString(igroupUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v IgroupInitiatorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
IgroupInitiatorCreate Method for IgroupInitiatorCreate
Adds one or more initiators to an initiator group. ### Required properties * &#x60;name&#x60; or &#x60;records.name&#x60; - Initiator name(s) to add to the initiator group. ### Related ONTAP commands * &#x60;lun igroup add&#x60; ### Learn more * [&#x60;DOC /protocols/san/igroups&#x60;](#docs-SAN-protocols_san_igroups)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param igroupUuid The unique identifier of the initiator group.
 * @param info The properties of the initiator to add to the initiator group.
@return IgroupInitiatorResponse
*/
func (a *SANApiService) IgroupInitiatorCreate(ctx _context.Context, igroupUuid string, info IgroupInitiator) (IgroupInitiatorResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IgroupInitiatorResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/igroups/{igroup.uuid}/initiators"
	localVarPath = strings.Replace(localVarPath, "{"+"igroup.uuid"+"}", _neturl.QueryEscape(parameterToString(igroupUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 201 {
			var v IgroupInitiatorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// IgroupInitiatorDeleteOpts Optional parameters for the method 'IgroupInitiatorDelete'
type IgroupInitiatorDeleteOpts struct {
	AllowDeleteWhileMapped optional.Bool
}

/*
IgroupInitiatorDelete Method for IgroupInitiatorDelete
Deletes an initiator from an initiator group. ### Related ONTAP commands * &#x60;lun igroup remove&#x60; ### Learn more * [&#x60;DOC /protocols/san/igroups&#x60;](#docs-SAN-protocols_san_igroups)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param igroupUuid The unique identifier of the initiator group.
 * @param name The initiator name.
 * @param optional nil or *IgroupInitiatorDeleteOpts - Optional Parameters:
 * @param "AllowDeleteWhileMapped" (optional.Bool) -  Allow deletion of an initiator from of a mapped initiator group.<br/> Deleting an initiator from a mapped initiator group makes the LUNs to which the initiator group is mapped no longer available to the initiator. This might cause a disruption in the availability of data.<br/> <b>This parameter should be used with caution.</b>
*/
func (a *SANApiService) IgroupInitiatorDelete(ctx _context.Context, igroupUuid string, name string, localVarOptionals *IgroupInitiatorDeleteOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/igroups/{igroup.uuid}/initiators/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"igroup.uuid"+"}", _neturl.QueryEscape(parameterToString(igroupUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.QueryEscape(parameterToString(name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.AllowDeleteWhileMapped.IsSet() {
		localVarQueryParams.Add("allow_delete_while_mapped", parameterToString(localVarOptionals.AllowDeleteWhileMapped.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// IgroupInitiatorGetOpts Optional parameters for the method 'IgroupInitiatorGet'
type IgroupInitiatorGetOpts struct {
	Fields optional.Interface
}

/*
IgroupInitiatorGet Method for IgroupInitiatorGet
Retrieves an initiator of an initiator group. ### Related ONTAP commands * &#x60;lun igroup show&#x60; ### Learn more * [&#x60;DOC /protocols/san/igroups&#x60;](#docs-SAN-protocols_san_igroups)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param igroupUuid The unique identifier of the initiator group.
 * @param name The initiator name.
 * @param optional nil or *IgroupInitiatorGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return IgroupInitiator
*/
func (a *SANApiService) IgroupInitiatorGet(ctx _context.Context, igroupUuid string, name string, localVarOptionals *IgroupInitiatorGetOpts) (IgroupInitiator, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IgroupInitiator
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/igroups/{igroup.uuid}/initiators/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"igroup.uuid"+"}", _neturl.QueryEscape(parameterToString(igroupUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.QueryEscape(parameterToString(name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v IgroupInitiator
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
IgroupModify Method for IgroupModify
Updates an initiator group. ### Related ONTAP commands * &#x60;lun igroup modify&#x60; * &#x60;lun igroup rename&#x60; ### Learn more * [&#x60;DOC /protocols/san/igroups&#x60;](#docs-SAN-protocols_san_igroups)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid The unique identifier of the initiator group.
 * @param info The new property values for the initiator group.
*/
func (a *SANApiService) IgroupModify(ctx _context.Context, uuid string, info Igroup) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/igroups/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// IscsiCredentialsCollectionGetOpts Optional parameters for the method 'IscsiCredentialsCollectionGet'
type IscsiCredentialsCollectionGetOpts struct {
	InitiatorAddressMasksAddress optional.String
	InitiatorAddressMasksNetmask optional.String
	InitiatorAddressMasksFamily  optional.String
	InitiatorAddressRangesFamily optional.String
	InitiatorAddressRangesStart  optional.String
	InitiatorAddressRangesEnd    optional.String
	SvmUuid                      optional.String
	SvmName                      optional.String
	Initiator                    optional.String
	AuthenticationType           optional.String
	ChapInboundUser              optional.String
	ChapOutboundUser             optional.String
	Fields                       optional.Interface
	MaxRecords                   optional.Int32
	ReturnRecords                optional.Bool
	ReturnTimeout                optional.Int32
	OrderBy                      optional.Interface
}

/*
IscsiCredentialsCollectionGet Method for IscsiCredentialsCollectionGet
Retrieves iSCSI credentials. ### Related ONTAP commands * &#x60;vserver iscsi security show&#x60; ### Learn more * [&#x60;DOC /protocols/san/iscsi/credentials&#x60;](#docs-SAN-protocols_san_iscsi_credentials)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *IscsiCredentialsCollectionGetOpts - Optional Parameters:
 * @param "InitiatorAddressMasksAddress" (optional.String) -  Filter by initiator_address.masks.address
 * @param "InitiatorAddressMasksNetmask" (optional.String) -  Filter by initiator_address.masks.netmask
 * @param "InitiatorAddressMasksFamily" (optional.String) -  Filter by initiator_address.masks.family
 * @param "InitiatorAddressRangesFamily" (optional.String) -  Filter by initiator_address.ranges.family
 * @param "InitiatorAddressRangesStart" (optional.String) -  Filter by initiator_address.ranges.start
 * @param "InitiatorAddressRangesEnd" (optional.String) -  Filter by initiator_address.ranges.end
 * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
 * @param "SvmName" (optional.String) -  Filter by svm.name
 * @param "Initiator" (optional.String) -  Filter by initiator
 * @param "AuthenticationType" (optional.String) -  Filter by authentication_type
 * @param "ChapInboundUser" (optional.String) -  Filter by chap.inbound.user
 * @param "ChapOutboundUser" (optional.String) -  Filter by chap.outbound.user
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return IscsiCredentialsResponse
*/
func (a *SANApiService) IscsiCredentialsCollectionGet(ctx _context.Context, localVarOptionals *IscsiCredentialsCollectionGetOpts) (IscsiCredentialsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IscsiCredentialsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/iscsi/credentials"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.InitiatorAddressMasksAddress.IsSet() {
		localVarQueryParams.Add("initiator_address.masks.address", parameterToString(localVarOptionals.InitiatorAddressMasksAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitiatorAddressMasksNetmask.IsSet() {
		localVarQueryParams.Add("initiator_address.masks.netmask", parameterToString(localVarOptionals.InitiatorAddressMasksNetmask.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitiatorAddressMasksFamily.IsSet() {
		localVarQueryParams.Add("initiator_address.masks.family", parameterToString(localVarOptionals.InitiatorAddressMasksFamily.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitiatorAddressRangesFamily.IsSet() {
		localVarQueryParams.Add("initiator_address.ranges.family", parameterToString(localVarOptionals.InitiatorAddressRangesFamily.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitiatorAddressRangesStart.IsSet() {
		localVarQueryParams.Add("initiator_address.ranges.start", parameterToString(localVarOptionals.InitiatorAddressRangesStart.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitiatorAddressRangesEnd.IsSet() {
		localVarQueryParams.Add("initiator_address.ranges.end", parameterToString(localVarOptionals.InitiatorAddressRangesEnd.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Initiator.IsSet() {
		localVarQueryParams.Add("initiator", parameterToString(localVarOptionals.Initiator.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AuthenticationType.IsSet() {
		localVarQueryParams.Add("authentication_type", parameterToString(localVarOptionals.AuthenticationType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChapInboundUser.IsSet() {
		localVarQueryParams.Add("chap.inbound.user", parameterToString(localVarOptionals.ChapInboundUser.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChapOutboundUser.IsSet() {
		localVarQueryParams.Add("chap.outbound.user", parameterToString(localVarOptionals.ChapOutboundUser.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v IscsiCredentialsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
IscsiCredentialsCreate Method for IscsiCredentialsCreate
Creates iSCSI credentials. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the iSCSI credentials. * &#x60;initiator&#x60; - Initiator for which the iSCSI credentials are to be created. * &#x60;authentication_type&#x60; - Type of authentication to use for the credentials. ### Recommended optional properties * &#x60;chap.inbound.user&#x60; - In-bound CHAP authentication user name. * &#x60;chap.inbound.password&#x60; - In-bound CHAP authentication password. * &#x60;chap.outbound.user&#x60; - Out-bound CHAP authentication user name. * &#x60;chap.outbound.password&#x60; - Out-bound CHAP authentication password. ### Related ONTAP commands * &#x60;vserver iscsi security create&#x60; ### Learn more * [&#x60;DOC /protocols/san/iscsi/credentials&#x60;](#docs-SAN-protocols_san_iscsi_credentials)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info The property values for the new iSCSI credentials object.
@return IscsiCredentialsResponse
*/
func (a *SANApiService) IscsiCredentialsCreate(ctx _context.Context, info IscsiCredentials) (IscsiCredentialsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IscsiCredentialsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/iscsi/credentials"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 201 {
			var v IscsiCredentialsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
IscsiCredentialsDelete Method for IscsiCredentialsDelete
Deletes specified iSCSI credentials. ### Related ONTAP commands * &#x60;vserver iscsi security delete&#x60; ### Learn more * [&#x60;DOC /protocols/san/iscsi/credentials&#x60;](#docs-SAN-protocols_san_iscsi_credentials)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid The unique identifier of an SVM.
 * @param initiator The iSCSI initiator of the credentials object.
*/
func (a *SANApiService) IscsiCredentialsDelete(ctx _context.Context, svmUuid string, initiator string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/iscsi/credentials/{svm.uuid}/{initiator}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", _neturl.QueryEscape(parameterToString(svmUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"initiator"+"}", _neturl.QueryEscape(parameterToString(initiator, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// IscsiCredentialsGetOpts Optional parameters for the method 'IscsiCredentialsGet'
type IscsiCredentialsGetOpts struct {
	Fields optional.Interface
}

/*
IscsiCredentialsGet Method for IscsiCredentialsGet
Retrieves specified iSCSI credentials. ### Related ONTAP commands * &#x60;vserver iscsi security show&#x60; ### Learn more * [&#x60;DOC /protocols/san/iscsi/credentials&#x60;](#docs-SAN-protocols_san_iscsi_credentials)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid The unique identifier of an SVM.
 * @param initiator The iSCSI initiator of the credentials object.
 * @param optional nil or *IscsiCredentialsGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return IscsiCredentials
*/
func (a *SANApiService) IscsiCredentialsGet(ctx _context.Context, svmUuid string, initiator string, localVarOptionals *IscsiCredentialsGetOpts) (IscsiCredentials, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IscsiCredentials
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/iscsi/credentials/{svm.uuid}/{initiator}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", _neturl.QueryEscape(parameterToString(svmUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"initiator"+"}", _neturl.QueryEscape(parameterToString(initiator, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v IscsiCredentials
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// IscsiCredentialsModifyOpts Optional parameters for the method 'IscsiCredentialsModify'
type IscsiCredentialsModifyOpts struct {
	AddInitiatorAddresses    optional.Bool
	RemoveInitiatorAddresses optional.Bool
}

/*
IscsiCredentialsModify Method for IscsiCredentialsModify
Updates specified iSCSI credentials. ### Related ONTAP commands * &#x60;vserver iscsi security add-initiator-address-ranges&#x60; * &#x60;vserver iscsi security default&#x60; * &#x60;vserver iscsi security modify&#x60; * &#x60;vserver iscsi security remove-initiator-address-ranges&#x60; ### Learn more * [&#x60;DOC /protocols/san/iscsi/credentials&#x60;](#docs-SAN-protocols_san_iscsi_credentials)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid The unique identifier of an SVM.
 * @param initiator The iSCSI initiator of the credentials object.
 * @param info The new property values for the iSCSI credentials object.
 * @param optional nil or *IscsiCredentialsModifyOpts - Optional Parameters:
 * @param "AddInitiatorAddresses" (optional.Bool) -  If _true_, the initiator addresses in the body merge into the existing addresses in the iSCSI security object rather than replace the existing addresses.
 * @param "RemoveInitiatorAddresses" (optional.Bool) -  If _true_, the initiator addresses in the body are removed from the existing addresses in the iSCSI security object rather than replace the existing addresses.
*/
func (a *SANApiService) IscsiCredentialsModify(ctx _context.Context, svmUuid string, initiator string, info IscsiCredentials, localVarOptionals *IscsiCredentialsModifyOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/iscsi/credentials/{svm.uuid}/{initiator}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", _neturl.QueryEscape(parameterToString(svmUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"initiator"+"}", _neturl.QueryEscape(parameterToString(initiator, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.AddInitiatorAddresses.IsSet() {
		localVarQueryParams.Add("add_initiator_addresses", parameterToString(localVarOptionals.AddInitiatorAddresses.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RemoveInitiatorAddresses.IsSet() {
		localVarQueryParams.Add("remove_initiator_addresses", parameterToString(localVarOptionals.RemoveInitiatorAddresses.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// IscsiServiceCollectionGetOpts Optional parameters for the method 'IscsiServiceCollectionGet'
type IscsiServiceCollectionGetOpts struct {
	SvmUuid       optional.String
	SvmName       optional.String
	Enabled       optional.Bool
	TargetName    optional.String
	TargetAlias   optional.String
	Fields        optional.Interface
	MaxRecords    optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy       optional.Interface
}

/*
IscsiServiceCollectionGet Method for IscsiServiceCollectionGet
Retrieves iSCSI services. ### Related ONTAP commands * &#x60;vserver iscsi show&#x60; ### Learn more * [&#x60;DOC /protocols/san/iscsi/services&#x60;](#docs-SAN-protocols_san_iscsi_services)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *IscsiServiceCollectionGetOpts - Optional Parameters:
 * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
 * @param "SvmName" (optional.String) -  Filter by svm.name
 * @param "Enabled" (optional.Bool) -  Filter by enabled
 * @param "TargetName" (optional.String) -  Filter by target.name
 * @param "TargetAlias" (optional.String) -  Filter by target.alias
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return IscsiServiceResponse
*/
func (a *SANApiService) IscsiServiceCollectionGet(ctx _context.Context, localVarOptionals *IscsiServiceCollectionGetOpts) (IscsiServiceResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IscsiServiceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/iscsi/services"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarQueryParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TargetName.IsSet() {
		localVarQueryParams.Add("target.name", parameterToString(localVarOptionals.TargetName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TargetAlias.IsSet() {
		localVarQueryParams.Add("target.alias", parameterToString(localVarOptionals.TargetAlias.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v IscsiServiceResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
IscsiServiceCreate Method for IscsiServiceCreate
Creates an iSCSI service. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the iSCSI service. ### Related ONTAP commands * &#x60;vserver iscsi create&#x60; ### Learn more * [&#x60;DOC /protocols/san/iscsi/services&#x60;](#docs-SAN-protocols_san_iscsi_services)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info The property values for the new iSCSI service.
@return IscsiServiceResponse
*/
func (a *SANApiService) IscsiServiceCreate(ctx _context.Context, info IscsiService) (IscsiServiceResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IscsiServiceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/iscsi/services"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 201 {
			var v IscsiServiceResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
IscsiServiceDelete Method for IscsiServiceDelete
Deletes an iSCSI service. An iSCSI service must be disabled before it can be deleted. ### Related ONTAP commands * &#x60;vserver iscsi delete&#x60; ### Learn more * [&#x60;DOC /protocols/san/iscsi/services&#x60;](#docs-SAN-protocols_san_iscsi_services)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid The unique identifier of the SVM for which to delete the iSCSI service.
*/
func (a *SANApiService) IscsiServiceDelete(ctx _context.Context, svmUuid string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/iscsi/services/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", _neturl.QueryEscape(parameterToString(svmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// IscsiServiceGetOpts Optional parameters for the method 'IscsiServiceGet'
type IscsiServiceGetOpts struct {
	Fields optional.Interface
}

/*
IscsiServiceGet Method for IscsiServiceGet
Retrieves an iSCSI service. ### Related ONTAP commands * &#x60;vserver iscsi show&#x60; ### Learn more * [&#x60;DOC /protocols/san/iscsi/services&#x60;](#docs-SAN-protocols_san_iscsi_services)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid The unique identifier of the SVM for which to retrieve the iSCSI service.
 * @param optional nil or *IscsiServiceGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return IscsiService
*/
func (a *SANApiService) IscsiServiceGet(ctx _context.Context, svmUuid string, localVarOptionals *IscsiServiceGetOpts) (IscsiService, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IscsiService
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/iscsi/services/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", _neturl.QueryEscape(parameterToString(svmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v IscsiService
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
IscsiServiceModify Method for IscsiServiceModify
Updates an iSCSI service. ### Related ONTAP commands * &#x60;vserver iscsi modify&#x60; * &#x60;vserver iscsi start&#x60; * &#x60;vserver iscsi stop&#x60; ### Learn more * [&#x60;DOC /protocols/san/iscsi/services&#x60;](#docs-SAN-protocols_san_iscsi_services)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid The unique identifier of the SVM for which to update the iSCSI service.
 * @param info The new property values for the iSCSI service.
*/
func (a *SANApiService) IscsiServiceModify(ctx _context.Context, svmUuid string, info IscsiService) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/iscsi/services/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", _neturl.QueryEscape(parameterToString(svmUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// IscsiSessionCollectionGetOpts Optional parameters for the method 'IscsiSessionCollectionGet'
type IscsiSessionCollectionGetOpts struct {
	IgroupsUuid                        optional.String
	IgroupsName                        optional.String
	ConnectionsAuthenticationType      optional.String
	ConnectionsCid                     optional.Int32
	ConnectionsInterfaceIpAddress      optional.String
	ConnectionsInterfaceIpPort         optional.Int32
	ConnectionsInterfaceUuid           optional.String
	ConnectionsInterfaceName           optional.String
	ConnectionsInitiatorAddressPort    optional.Int32
	ConnectionsInitiatorAddressAddress optional.String
	TargetPortalGroup                  optional.String
	Tsih                               optional.Int32
	InitiatorName                      optional.String
	InitiatorAlias                     optional.String
	SvmUuid                            optional.String
	SvmName                            optional.String
	Isid                               optional.String
	TargetPortalGroupTag               optional.Int32
	Fields                             optional.Interface
	MaxRecords                         optional.Int32
	ReturnRecords                      optional.Bool
	ReturnTimeout                      optional.Int32
	OrderBy                            optional.Interface
}

/*
IscsiSessionCollectionGet Method for IscsiSessionCollectionGet
Retrieves iSCSI sessions. ### Related ONTAP commands * &#x60;vserver iscsi connection show&#x60; * &#x60;vserver iscsi session parameter show&#x60; * &#x60;vserver iscsi session show&#x60; ### Learn more * [&#x60;DOC /protocols/san/iscsi/sessions&#x60;](#docs-SAN-protocols_san_iscsi_sessions)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *IscsiSessionCollectionGetOpts - Optional Parameters:
 * @param "IgroupsUuid" (optional.String) -  Filter by igroups.uuid
 * @param "IgroupsName" (optional.String) -  Filter by igroups.name
 * @param "ConnectionsAuthenticationType" (optional.String) -  Filter by connections.authentication_type
 * @param "ConnectionsCid" (optional.Int32) -  Filter by connections.cid
 * @param "ConnectionsInterfaceIpAddress" (optional.String) -  Filter by connections.interface.ip.address
 * @param "ConnectionsInterfaceIpPort" (optional.Int32) -  Filter by connections.interface.ip.port
 * @param "ConnectionsInterfaceUuid" (optional.String) -  Filter by connections.interface.uuid
 * @param "ConnectionsInterfaceName" (optional.String) -  Filter by connections.interface.name
 * @param "ConnectionsInitiatorAddressPort" (optional.Int32) -  Filter by connections.initiator_address.port
 * @param "ConnectionsInitiatorAddressAddress" (optional.String) -  Filter by connections.initiator_address.address
 * @param "TargetPortalGroup" (optional.String) -  Filter by target_portal_group
 * @param "Tsih" (optional.Int32) -  Filter by tsih
 * @param "InitiatorName" (optional.String) -  Filter by initiator.name
 * @param "InitiatorAlias" (optional.String) -  Filter by initiator.alias
 * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
 * @param "SvmName" (optional.String) -  Filter by svm.name
 * @param "Isid" (optional.String) -  Filter by isid
 * @param "TargetPortalGroupTag" (optional.Int32) -  Filter by target_portal_group_tag
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return IscsiSessionResponse
*/
func (a *SANApiService) IscsiSessionCollectionGet(ctx _context.Context, localVarOptionals *IscsiSessionCollectionGetOpts) (IscsiSessionResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IscsiSessionResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/iscsi/sessions"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IgroupsUuid.IsSet() {
		localVarQueryParams.Add("igroups.uuid", parameterToString(localVarOptionals.IgroupsUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IgroupsName.IsSet() {
		localVarQueryParams.Add("igroups.name", parameterToString(localVarOptionals.IgroupsName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ConnectionsAuthenticationType.IsSet() {
		localVarQueryParams.Add("connections.authentication_type", parameterToString(localVarOptionals.ConnectionsAuthenticationType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ConnectionsCid.IsSet() {
		localVarQueryParams.Add("connections.cid", parameterToString(localVarOptionals.ConnectionsCid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ConnectionsInterfaceIpAddress.IsSet() {
		localVarQueryParams.Add("connections.interface.ip.address", parameterToString(localVarOptionals.ConnectionsInterfaceIpAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ConnectionsInterfaceIpPort.IsSet() {
		localVarQueryParams.Add("connections.interface.ip.port", parameterToString(localVarOptionals.ConnectionsInterfaceIpPort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ConnectionsInterfaceUuid.IsSet() {
		localVarQueryParams.Add("connections.interface.uuid", parameterToString(localVarOptionals.ConnectionsInterfaceUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ConnectionsInterfaceName.IsSet() {
		localVarQueryParams.Add("connections.interface.name", parameterToString(localVarOptionals.ConnectionsInterfaceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ConnectionsInitiatorAddressPort.IsSet() {
		localVarQueryParams.Add("connections.initiator_address.port", parameterToString(localVarOptionals.ConnectionsInitiatorAddressPort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ConnectionsInitiatorAddressAddress.IsSet() {
		localVarQueryParams.Add("connections.initiator_address.address", parameterToString(localVarOptionals.ConnectionsInitiatorAddressAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TargetPortalGroup.IsSet() {
		localVarQueryParams.Add("target_portal_group", parameterToString(localVarOptionals.TargetPortalGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tsih.IsSet() {
		localVarQueryParams.Add("tsih", parameterToString(localVarOptionals.Tsih.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitiatorName.IsSet() {
		localVarQueryParams.Add("initiator.name", parameterToString(localVarOptionals.InitiatorName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitiatorAlias.IsSet() {
		localVarQueryParams.Add("initiator.alias", parameterToString(localVarOptionals.InitiatorAlias.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Isid.IsSet() {
		localVarQueryParams.Add("isid", parameterToString(localVarOptionals.Isid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TargetPortalGroupTag.IsSet() {
		localVarQueryParams.Add("target_portal_group_tag", parameterToString(localVarOptionals.TargetPortalGroupTag.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v IscsiSessionResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// IscsiSessionGetOpts Optional parameters for the method 'IscsiSessionGet'
type IscsiSessionGetOpts struct {
	Fields optional.Interface
}

/*
IscsiSessionGet Method for IscsiSessionGet
Retrieves an iSCSI session. ### Related ONTAP commands * &#x60;vserver iscsi connection show&#x60; * &#x60;vserver iscsi session parameter show&#x60; * &#x60;vserver iscsi session show&#x60; ### Learn more * [&#x60;DOC /protocols/san/iscsi/sessions&#x60;](#docs-SAN-protocols_san_iscsi_sessions)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid The unique identifier of the SVM of the iSCSI session.
 * @param tpgroup The target portal group of the iSCSI session.
 * @param tsih The target session identifying handle.
 * @param optional nil or *IscsiSessionGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return IscsiSession
*/
func (a *SANApiService) IscsiSessionGet(ctx _context.Context, svmUuid string, tpgroup string, tsih int32, localVarOptionals *IscsiSessionGetOpts) (IscsiSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IscsiSession
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/iscsi/sessions/{svm.uuid}/{tpgroup}/{tsih}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", _neturl.QueryEscape(parameterToString(svmUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"tpgroup"+"}", _neturl.QueryEscape(parameterToString(tpgroup, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"tsih"+"}", _neturl.QueryEscape(parameterToString(tsih, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v IscsiSession
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// LunCollectionGetOpts Optional parameters for the method 'LunCollectionGet'
type LunCollectionGetOpts struct {
	LocationLogicalUnit                     optional.String
	LocationQtreeName                       optional.String
	LocationQtreeId                         optional.Int32
	LocationVolumeName                      optional.String
	LocationVolumeUuid                      optional.String
	StatusContainerState                    optional.String
	StatusMapped                            optional.Bool
	StatusState                             optional.String
	StatusReadOnly                          optional.Bool
	QosPolicyUuid                           optional.String
	QosPolicyName                           optional.String
	Class                                   optional.String
	MovementMaxThroughput                   optional.String
	MovementPathsSource                     optional.String
	MovementPathsDestination                optional.String
	MovementProgressState                   optional.String
	MovementProgressFailureCode             optional.String
	MovementProgressFailureArgumentsMessage optional.String
	MovementProgressFailureArgumentsCode    optional.String
	MovementProgressFailureMessage          optional.String
	MovementProgressFailureTarget           optional.String
	MovementProgressPercentComplete         optional.Int32
	MovementProgressVolumeSnapshotBlocked   optional.Bool
	MovementProgressElapsed                 optional.Int32
	SvmUuid                                 optional.String
	SvmName                                 optional.String
	Name                                    optional.String
	Enabled                                 optional.Bool
	LunMapsLogicalUnitNumber                optional.Int32
	LunMapsIgroupUuid                       optional.String
	LunMapsIgroupName                       optional.String
	SpaceSize                               optional.Int32
	SpaceGuaranteeRequested                 optional.Bool
	SpaceGuaranteeReserved                  optional.Bool
	SpaceUsed                               optional.Int32
	OsType                                  optional.String
	Comment                                 optional.String
	AutoDelete                              optional.Bool
	Uuid                                    optional.String
	SerialNumber                            optional.String
	Fields                                  optional.Interface
	MaxRecords                              optional.Int32
	ReturnRecords                           optional.Bool
	ReturnTimeout                           optional.Int32
	OrderBy                                 optional.Interface
}

/*
LunCollectionGet Method for LunCollectionGet
Retrieves LUNs. ### Expensive properties There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the &#x60;fields&#x60; query parameter. See [&#x60;DOC Requesting specific fields&#x60;](#docs-docs-Requesting-specific-fields) to learn more. * &#x60;auto_delete&#x60; * &#x60;lun_maps.*&#x60; * &#x60;movement.*&#x60; * &#x60;status.mapped&#x60; ### Related ONTAP commands * &#x60;lun mapping show&#x60; * &#x60;lun move show&#x60; * &#x60;lun show&#x60; * &#x60;volume file clone show-autodelete&#x60; ### Learn more * [&#x60;DOC /storage/luns&#x60;](#docs-SAN-storage_luns)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *LunCollectionGetOpts - Optional Parameters:
 * @param "LocationLogicalUnit" (optional.String) -  Filter by location.logical_unit
 * @param "LocationQtreeName" (optional.String) -  Filter by location.qtree.name
 * @param "LocationQtreeId" (optional.Int32) -  Filter by location.qtree.id
 * @param "LocationVolumeName" (optional.String) -  Filter by location.volume.name
 * @param "LocationVolumeUuid" (optional.String) -  Filter by location.volume.uuid
 * @param "StatusContainerState" (optional.String) -  Filter by status.container_state
 * @param "StatusMapped" (optional.Bool) -  Filter by status.mapped
 * @param "StatusState" (optional.String) -  Filter by status.state
 * @param "StatusReadOnly" (optional.Bool) -  Filter by status.read_only
 * @param "QosPolicyUuid" (optional.String) -  Filter by qos_policy.uuid
 * @param "QosPolicyName" (optional.String) -  Filter by qos_policy.name
 * @param "Class" (optional.String) -  Filter by class
 * @param "MovementMaxThroughput" (optional.String) -  Filter by movement.max_throughput
 * @param "MovementPathsSource" (optional.String) -  Filter by movement.paths.source
 * @param "MovementPathsDestination" (optional.String) -  Filter by movement.paths.destination
 * @param "MovementProgressState" (optional.String) -  Filter by movement.progress.state
 * @param "MovementProgressFailureCode" (optional.String) -  Filter by movement.progress.failure.code
 * @param "MovementProgressFailureArgumentsMessage" (optional.String) -  Filter by movement.progress.failure.arguments.message
 * @param "MovementProgressFailureArgumentsCode" (optional.String) -  Filter by movement.progress.failure.arguments.code
 * @param "MovementProgressFailureMessage" (optional.String) -  Filter by movement.progress.failure.message
 * @param "MovementProgressFailureTarget" (optional.String) -  Filter by movement.progress.failure.target
 * @param "MovementProgressPercentComplete" (optional.Int32) -  Filter by movement.progress.percent_complete
 * @param "MovementProgressVolumeSnapshotBlocked" (optional.Bool) -  Filter by movement.progress.volume_snapshot_blocked
 * @param "MovementProgressElapsed" (optional.Int32) -  Filter by movement.progress.elapsed
 * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
 * @param "SvmName" (optional.String) -  Filter by svm.name
 * @param "Name" (optional.String) -  Filter by name
 * @param "Enabled" (optional.Bool) -  Filter by enabled
 * @param "LunMapsLogicalUnitNumber" (optional.Int32) -  Filter by lun_maps.logical_unit_number
 * @param "LunMapsIgroupUuid" (optional.String) -  Filter by lun_maps.igroup.uuid
 * @param "LunMapsIgroupName" (optional.String) -  Filter by lun_maps.igroup.name
 * @param "SpaceSize" (optional.Int32) -  Filter by space.size
 * @param "SpaceGuaranteeRequested" (optional.Bool) -  Filter by space.guarantee.requested
 * @param "SpaceGuaranteeReserved" (optional.Bool) -  Filter by space.guarantee.reserved
 * @param "SpaceUsed" (optional.Int32) -  Filter by space.used
 * @param "OsType" (optional.String) -  Filter by os_type
 * @param "Comment" (optional.String) -  Filter by comment
 * @param "AutoDelete" (optional.Bool) -  Filter by auto_delete
 * @param "Uuid" (optional.String) -  Filter by uuid
 * @param "SerialNumber" (optional.String) -  Filter by serial_number
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return LunResponse
*/
func (a *SANApiService) LunCollectionGet(ctx _context.Context, localVarOptionals *LunCollectionGetOpts) (LunResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LunResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/luns"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.LocationLogicalUnit.IsSet() {
		localVarQueryParams.Add("location.logical_unit", parameterToString(localVarOptionals.LocationLogicalUnit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationQtreeName.IsSet() {
		localVarQueryParams.Add("location.qtree.name", parameterToString(localVarOptionals.LocationQtreeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationQtreeId.IsSet() {
		localVarQueryParams.Add("location.qtree.id", parameterToString(localVarOptionals.LocationQtreeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationVolumeName.IsSet() {
		localVarQueryParams.Add("location.volume.name", parameterToString(localVarOptionals.LocationVolumeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationVolumeUuid.IsSet() {
		localVarQueryParams.Add("location.volume.uuid", parameterToString(localVarOptionals.LocationVolumeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatusContainerState.IsSet() {
		localVarQueryParams.Add("status.container_state", parameterToString(localVarOptionals.StatusContainerState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatusMapped.IsSet() {
		localVarQueryParams.Add("status.mapped", parameterToString(localVarOptionals.StatusMapped.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatusState.IsSet() {
		localVarQueryParams.Add("status.state", parameterToString(localVarOptionals.StatusState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatusReadOnly.IsSet() {
		localVarQueryParams.Add("status.read_only", parameterToString(localVarOptionals.StatusReadOnly.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QosPolicyUuid.IsSet() {
		localVarQueryParams.Add("qos_policy.uuid", parameterToString(localVarOptionals.QosPolicyUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QosPolicyName.IsSet() {
		localVarQueryParams.Add("qos_policy.name", parameterToString(localVarOptionals.QosPolicyName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Class.IsSet() {
		localVarQueryParams.Add("class", parameterToString(localVarOptionals.Class.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementMaxThroughput.IsSet() {
		localVarQueryParams.Add("movement.max_throughput", parameterToString(localVarOptionals.MovementMaxThroughput.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementPathsSource.IsSet() {
		localVarQueryParams.Add("movement.paths.source", parameterToString(localVarOptionals.MovementPathsSource.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementPathsDestination.IsSet() {
		localVarQueryParams.Add("movement.paths.destination", parameterToString(localVarOptionals.MovementPathsDestination.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementProgressState.IsSet() {
		localVarQueryParams.Add("movement.progress.state", parameterToString(localVarOptionals.MovementProgressState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementProgressFailureCode.IsSet() {
		localVarQueryParams.Add("movement.progress.failure.code", parameterToString(localVarOptionals.MovementProgressFailureCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementProgressFailureArgumentsMessage.IsSet() {
		localVarQueryParams.Add("movement.progress.failure.arguments.message", parameterToString(localVarOptionals.MovementProgressFailureArgumentsMessage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementProgressFailureArgumentsCode.IsSet() {
		localVarQueryParams.Add("movement.progress.failure.arguments.code", parameterToString(localVarOptionals.MovementProgressFailureArgumentsCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementProgressFailureMessage.IsSet() {
		localVarQueryParams.Add("movement.progress.failure.message", parameterToString(localVarOptionals.MovementProgressFailureMessage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementProgressFailureTarget.IsSet() {
		localVarQueryParams.Add("movement.progress.failure.target", parameterToString(localVarOptionals.MovementProgressFailureTarget.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementProgressPercentComplete.IsSet() {
		localVarQueryParams.Add("movement.progress.percent_complete", parameterToString(localVarOptionals.MovementProgressPercentComplete.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementProgressVolumeSnapshotBlocked.IsSet() {
		localVarQueryParams.Add("movement.progress.volume_snapshot_blocked", parameterToString(localVarOptionals.MovementProgressVolumeSnapshotBlocked.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementProgressElapsed.IsSet() {
		localVarQueryParams.Add("movement.progress.elapsed", parameterToString(localVarOptionals.MovementProgressElapsed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarQueryParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LunMapsLogicalUnitNumber.IsSet() {
		localVarQueryParams.Add("lun_maps.logical_unit_number", parameterToString(localVarOptionals.LunMapsLogicalUnitNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LunMapsIgroupUuid.IsSet() {
		localVarQueryParams.Add("lun_maps.igroup.uuid", parameterToString(localVarOptionals.LunMapsIgroupUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LunMapsIgroupName.IsSet() {
		localVarQueryParams.Add("lun_maps.igroup.name", parameterToString(localVarOptionals.LunMapsIgroupName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceSize.IsSet() {
		localVarQueryParams.Add("space.size", parameterToString(localVarOptionals.SpaceSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceGuaranteeRequested.IsSet() {
		localVarQueryParams.Add("space.guarantee.requested", parameterToString(localVarOptionals.SpaceGuaranteeRequested.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceGuaranteeReserved.IsSet() {
		localVarQueryParams.Add("space.guarantee.reserved", parameterToString(localVarOptionals.SpaceGuaranteeReserved.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceUsed.IsSet() {
		localVarQueryParams.Add("space.used", parameterToString(localVarOptionals.SpaceUsed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OsType.IsSet() {
		localVarQueryParams.Add("os_type", parameterToString(localVarOptionals.OsType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Comment.IsSet() {
		localVarQueryParams.Add("comment", parameterToString(localVarOptionals.Comment.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AutoDelete.IsSet() {
		localVarQueryParams.Add("auto_delete", parameterToString(localVarOptionals.AutoDelete.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SerialNumber.IsSet() {
		localVarQueryParams.Add("serial_number", parameterToString(localVarOptionals.SerialNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v LunResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
LunCreate Method for LunCreate
Creates a LUN. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the LUN. * &#x60;name&#x60;, &#x60;location.volume.name&#x60; or &#x60;location.volume.uuid&#x60; - Existing volume in which to create the LUN. * &#x60;name&#x60; or &#x60;location.logical_unit&#x60; - Base name of the LUN. * &#x60;os_type&#x60; - Operating system from which the LUN will be accessed. Required when creating a non-clone LUN and disallowed when creating a clone of an existing LUN. A clone&#39;s &#x60;os_type&#x60; is taken from the source LUN. * &#x60;space.size&#x60; - Size of the LUN. Required when creating a non-clone LUN and disallowed when creating a clone of an existing LUN. A clone&#39;s size is taken from the source LUN. ### Recommended optional properties * &#x60;qos_policy.name&#x60; or &#x60;qos_policy.uuid&#x60; - Existing traditional or adaptive QoS policy to be applied to the LUN. All LUNs should be managed by a QoS policy at the volume or LUN level. ### Default property values If not specified in POST, the follow default property values are assigned. * &#x60;auto_delete&#x60; - _false_ ### Related ONTAP commands * &#x60;lun create&#x60; * &#x60;volume file clone autodelete&#x60; * &#x60;volume file clone create&#x60; ### Learn more * [&#x60;DOC /storage/luns&#x60;](#docs-SAN-storage_luns)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info The property values for the new LUN.
@return LunResponse
*/
func (a *SANApiService) LunCreate(ctx _context.Context, info Lun) (LunResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LunResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/luns"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 201 {
			var v LunResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// LunDeleteOpts Optional parameters for the method 'LunDelete'
type LunDeleteOpts struct {
	AllowDeleteWhileMapped optional.Bool
}

/*
LunDelete Method for LunDelete
Deletes a LUN. ### Related ONTAP commands * &#x60;lun delete&#x60; ### Learn more * [&#x60;DOC /storage/luns&#x60;](#docs-SAN-storage_luns)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid The unique identifier of the LUN.
 * @param optional nil or *LunDeleteOpts - Optional Parameters:
 * @param "AllowDeleteWhileMapped" (optional.Bool) -  Allow deletion of a mapped LUN. A mapped LUN might be in use. Deleting a mapped LUN also deletes the LUN map and makes the data no longer available. This might cause a disruption in the availability of data. **This parameter should be used with caution.**
*/
func (a *SANApiService) LunDelete(ctx _context.Context, uuid string, localVarOptionals *LunDeleteOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/luns/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.AllowDeleteWhileMapped.IsSet() {
		localVarQueryParams.Add("allow_delete_while_mapped", parameterToString(localVarOptionals.AllowDeleteWhileMapped.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// LunGetOpts Optional parameters for the method 'LunGet'
type LunGetOpts struct {
	Fields optional.Interface
}

/*
LunGet Method for LunGet
Retrieves a LUN. ### Expensive properties There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the &#x60;fields&#x60; query parameter. See [&#x60;DOC Requesting specific fields&#x60;](#docs-docs-Requesting-specific-fields) to learn more. * &#x60;auto_delete&#x60; * &#x60;lun_maps.*&#x60; * &#x60;movement.*&#x60; * &#x60;status.mapped&#x60; ### Related ONTAP commands * &#x60;lun mapping show&#x60; * &#x60;lun move show&#x60; * &#x60;lun show&#x60; * &#x60;volume file clone show-autodelete&#x60; ### Learn more * [&#x60;DOC /storage/luns&#x60;](#docs-SAN-storage_luns)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid The unique identifier of the LUN to retrieve.
 * @param optional nil or *LunGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return Lun
*/
func (a *SANApiService) LunGet(ctx _context.Context, uuid string, localVarOptionals *LunGetOpts) (Lun, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Lun
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/luns/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Lun
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// LunMapCollectionGetOpts Optional parameters for the method 'LunMapCollectionGet'
type LunMapCollectionGetOpts struct {
	SvmUuid           optional.String
	SvmName           optional.String
	LogicalUnitNumber optional.Int32
	IgroupProtocol    optional.String
	IgroupUuid        optional.String
	IgroupInitiators  optional.String
	IgroupOsType      optional.String
	IgroupName        optional.String
	LunName           optional.String
	LunNodeName       optional.String
	LunNodeUuid       optional.String
	LunUuid           optional.String
	Fields            optional.Interface
	MaxRecords        optional.Int32
	ReturnRecords     optional.Bool
	ReturnTimeout     optional.Int32
	OrderBy           optional.Interface
}

/*
LunMapCollectionGet Method for LunMapCollectionGet
Retrieves LUN maps. ### Related ONTAP commands * &#x60;lun mapping show&#x60; * [&#x60;DOC /protocols/san/lun-maps&#x60;](#docs-SAN-protocols_san_lun-maps)  ### Learn more * [&#x60;DOC /protocols/san/lun-maps&#x60;](#docs-SAN-protocols_san_lun-maps)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *LunMapCollectionGetOpts - Optional Parameters:
 * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
 * @param "SvmName" (optional.String) -  Filter by svm.name
 * @param "LogicalUnitNumber" (optional.Int32) -  Filter by logical_unit_number
 * @param "IgroupProtocol" (optional.String) -  Filter by igroup.protocol
 * @param "IgroupUuid" (optional.String) -  Filter by igroup.uuid
 * @param "IgroupInitiators" (optional.String) -  Filter by igroup.initiators
 * @param "IgroupOsType" (optional.String) -  Filter by igroup.os_type
 * @param "IgroupName" (optional.String) -  Filter by igroup.name
 * @param "LunName" (optional.String) -  Filter by lun.name
 * @param "LunNodeName" (optional.String) -  Filter by lun.node.name
 * @param "LunNodeUuid" (optional.String) -  Filter by lun.node.uuid
 * @param "LunUuid" (optional.String) -  Filter by lun.uuid
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return LunMapResponse
*/
func (a *SANApiService) LunMapCollectionGet(ctx _context.Context, localVarOptionals *LunMapCollectionGetOpts) (LunMapResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LunMapResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/lun-maps"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LogicalUnitNumber.IsSet() {
		localVarQueryParams.Add("logical_unit_number", parameterToString(localVarOptionals.LogicalUnitNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IgroupProtocol.IsSet() {
		localVarQueryParams.Add("igroup.protocol", parameterToString(localVarOptionals.IgroupProtocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IgroupUuid.IsSet() {
		localVarQueryParams.Add("igroup.uuid", parameterToString(localVarOptionals.IgroupUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IgroupInitiators.IsSet() {
		localVarQueryParams.Add("igroup.initiators", parameterToString(localVarOptionals.IgroupInitiators.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IgroupOsType.IsSet() {
		localVarQueryParams.Add("igroup.os_type", parameterToString(localVarOptionals.IgroupOsType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IgroupName.IsSet() {
		localVarQueryParams.Add("igroup.name", parameterToString(localVarOptionals.IgroupName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LunName.IsSet() {
		localVarQueryParams.Add("lun.name", parameterToString(localVarOptionals.LunName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LunNodeName.IsSet() {
		localVarQueryParams.Add("lun.node.name", parameterToString(localVarOptionals.LunNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LunNodeUuid.IsSet() {
		localVarQueryParams.Add("lun.node.uuid", parameterToString(localVarOptionals.LunNodeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LunUuid.IsSet() {
		localVarQueryParams.Add("lun.uuid", parameterToString(localVarOptionals.LunUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v LunMapResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
LunMapCreate Method for LunMapCreate
Creates a LUN map. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the LUN map. * &#x60;igroup.uuid&#x60; or &#x60;igroup.name&#x60; - Existing initiator group to map to the specified LUN. * &#x60;lun.uuid&#x60; or &#x60;lun.name&#x60; - Existing LUN to map to the specified initiator group. ### Default property values If not specified in POST, the following default property values are assigned. * &#x60;logical_unit_number&#x60; - If no value is provided, ONTAP assigns the lowest available value. ### Related ONTAP commands * &#x60;lun mapping create&#x60; ### Learn more * [&#x60;DOC /protocols/san/lun-maps&#x60;](#docs-SAN-protocols_san_lun-maps)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info The property values for the new LUN map.
@return LunMapResponse
*/
func (a *SANApiService) LunMapCreate(ctx _context.Context, info LunMap) (LunMapResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LunMapResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/lun-maps"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 201 {
			var v LunMapResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
LunMapDelete Method for LunMapDelete
Deletes a LUN map. ### Related ONTAP commands * &#x60;lun mapping delete&#x60; ### Learn more * [&#x60;DOC /protocols/san/lun-maps&#x60;](#docs-SAN-protocols_san_lun-maps)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param lunUuid The unique identifier of the LUN.
 * @param igroupUuid The unique identifier of the igroup.
*/
func (a *SANApiService) LunMapDelete(ctx _context.Context, lunUuid string, igroupUuid string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/lun-maps/{lun.uuid}/{igroup.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"lun.uuid"+"}", _neturl.QueryEscape(parameterToString(lunUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"igroup.uuid"+"}", _neturl.QueryEscape(parameterToString(igroupUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// LunMapGetOpts Optional parameters for the method 'LunMapGet'
type LunMapGetOpts struct {
	Fields optional.Interface
}

/*
LunMapGet Method for LunMapGet
Retrieves a LUN map. ### Related ONTAP commands * &#x60;lun mapping show&#x60; ### Learn more * [&#x60;DOC /protocols/san/lun-maps&#x60;](#docs-SAN-protocols_san_lun-maps)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param lunUuid The unique identifier of the LUN.
 * @param igroupUuid The unique identifier of the igroup.
 * @param optional nil or *LunMapGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return LunMap
*/
func (a *SANApiService) LunMapGet(ctx _context.Context, lunUuid string, igroupUuid string, localVarOptionals *LunMapGetOpts) (LunMap, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LunMap
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/lun-maps/{lun.uuid}/{igroup.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"lun.uuid"+"}", _neturl.QueryEscape(parameterToString(lunUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"igroup.uuid"+"}", _neturl.QueryEscape(parameterToString(igroupUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v LunMap
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
LunModify Method for LunModify
Updates the properties of a LUN. PATCH can also be be used to overwrite the contents of a LUN as a clone of another, to begin movement of a LUN between volumes, and to pause and resume the movement of a LUN between volumes. ### Related ONTAP commands * &#x60;lun modify&#x60; * &#x60;lun move modify&#x60; * &#x60;lun move pause&#x60; * &#x60;lun move resume&#x60; * &#x60;lun move start&#x60; * &#x60;lun resize&#x60; * &#x60;volume file clone autodelete&#x60; ### Learn more * [&#x60;DOC /storage/luns&#x60;](#docs-SAN-storage_luns)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid The unique identifier of the LUN to update.
 * @param info The new property values for the LUN.
*/
func (a *SANApiService) LunModify(ctx _context.Context, uuid string, info Lun) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/luns/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// WwpnAliasCollectionGetOpts Optional parameters for the method 'WwpnAliasCollectionGet'
type WwpnAliasCollectionGetOpts struct {
	Wwpn          optional.String
	SvmUuid       optional.String
	SvmName       optional.String
	Alias         optional.String
	Fields        optional.Interface
	MaxRecords    optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy       optional.Interface
}

/*
WwpnAliasCollectionGet Method for WwpnAliasCollectionGet
Retrieves FC WWPN aliases. ### Related ONTAP commands * &#x60;vserver fcp wwpn-alias show&#x60; ### Learn more * [&#x60;DOC /network/fc/wwpn-aliases&#x60;](#docs-SAN-network_fc_wwpn-aliases)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *WwpnAliasCollectionGetOpts - Optional Parameters:
 * @param "Wwpn" (optional.String) -  Filter by wwpn
 * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
 * @param "SvmName" (optional.String) -  Filter by svm.name
 * @param "Alias" (optional.String) -  Filter by alias
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return WwpnAliasResponse
*/
func (a *SANApiService) WwpnAliasCollectionGet(ctx _context.Context, localVarOptionals *WwpnAliasCollectionGetOpts) (WwpnAliasResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  WwpnAliasResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/fc/wwpn-aliases"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Wwpn.IsSet() {
		localVarQueryParams.Add("wwpn", parameterToString(localVarOptionals.Wwpn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Alias.IsSet() {
		localVarQueryParams.Add("alias", parameterToString(localVarOptionals.Alias.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v WwpnAliasResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
WwpnAliasCreate Method for WwpnAliasCreate
Creates an FC WWPN alias. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the FC alias. * &#x60;alias&#x60; - Name of the FC alias. * &#x60;wwpn&#x60; - FC WWPN for which to create the alias. ### Related ONTAP commands * &#x60;vserver fcp wwpn-alias set&#x60; ### Learn more * [&#x60;DOC /network/fc/wwpn-aliases&#x60;](#docs-SAN-network_fc_wwpn-aliases)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info The property values for the new WWPN alias.
@return WwpnAliasResponse
*/
func (a *SANApiService) WwpnAliasCreate(ctx _context.Context, info WwpnAlias) (WwpnAliasResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  WwpnAliasResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/fc/wwpn-aliases"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 201 {
			var v WwpnAliasResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
WwpnAliasDelete Method for WwpnAliasDelete
Deletes an FC WWPN alias. ### Related ONTAP commands * &#x60;vserver fcp wwpn-alias remove&#x60; ### Learn more * [&#x60;DOC /network/fc/wwpn-aliases&#x60;](#docs-SAN-network_fc_wwpn-aliases)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid The unique identifier of the SVM.
 * @param alias The name of FC WWPN alias.
*/
func (a *SANApiService) WwpnAliasDelete(ctx _context.Context, svmUuid string, alias string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/fc/wwpn-aliases/{svm.uuid}/{alias}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", _neturl.QueryEscape(parameterToString(svmUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"alias"+"}", _neturl.QueryEscape(parameterToString(alias, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// WwpnAliasGetOpts Optional parameters for the method 'WwpnAliasGet'
type WwpnAliasGetOpts struct {
	Fields optional.Interface
}

/*
WwpnAliasGet Method for WwpnAliasGet
Retrieves an FC WWPN alias. ### Related ONTAP commands * &#x60;vserver fcp wwpn-alias show&#x60; ### Learn more * [&#x60;DOC /network/fc/wwpn-aliases&#x60;](#docs-SAN-network_fc_wwpn-aliases)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid The unique identifier of the SVM in which the alias is found.
 * @param alias The name of FC WWPN alias.
 * @param optional nil or *WwpnAliasGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return WwpnAlias
*/
func (a *SANApiService) WwpnAliasGet(ctx _context.Context, svmUuid string, alias string, localVarOptionals *WwpnAliasGetOpts) (WwpnAlias, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  WwpnAlias
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/fc/wwpn-aliases/{svm.uuid}/{alias}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", _neturl.QueryEscape(parameterToString(svmUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"alias"+"}", _neturl.QueryEscape(parameterToString(alias, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v WwpnAlias
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
