/*
 * ONTAP REST API
 *
 * ONTAP 9.6 adds support for an expansive RESTful API. The documentation below provides information about the types of API calls available to you, as well as details about using each API endpoint. You can learn more about the ONTAP REST API and ONTAP in the ONTAP 9 Documentation Center:  http://docs.netapp.com/ontap-9/topic/com.netapp.doc.dot-rest-api/home.html. NetApp welcomes your comments and suggestions about the ONTAP REST API and the documentation for its use.</br> **Using the ONTAP 9.6 REST API online documentation** Each API method includes usage examples, as well as a model that displays all the required and optional properties supported by the method. Click the _Model_ link, available with each API method, to see all the required and optional properties supported by each method. 
 *
 * API version: v1
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type NVMeApiService service

/* 
NVMeApiService
Retrieves FC logins. ### Related ONTAP commands * &#x60;vserver fcp initiator show&#x60; ### Learn more * SAN: [&#x60;DOC /network/fc/logins&#x60;](#docs-SAN-network_fc_logins) * NVMe: [&#x60;DOC /network/fc/logins&#x60;](#docs-NVMe-network_fc_logins) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *FcLoginCollectionGetOpts - Optional Parameters:
     * @param "Protocol" (optional.String) -  Filter by protocol
     * @param "InitiatorPortAddress" (optional.String) -  Filter by initiator.port_address
     * @param "InitiatorWwpn" (optional.String) -  Filter by initiator.wwpn
     * @param "InitiatorWwnn" (optional.String) -  Filter by initiator.wwnn
     * @param "InitiatorAliases" (optional.String) -  Filter by initiator.aliases
     * @param "IgroupsUuid" (optional.String) -  Filter by igroups.uuid
     * @param "IgroupsName" (optional.String) -  Filter by igroups.name
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "InterfaceName" (optional.String) -  Filter by interface.name
     * @param "InterfaceWwpn" (optional.String) -  Filter by interface.wwpn
     * @param "InterfaceUuid" (optional.String) -  Filter by interface.uuid
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return FcLoginResponse
*/

type FcLoginCollectionGetOpts struct { 
	Protocol optional.String
	InitiatorPortAddress optional.String
	InitiatorWwpn optional.String
	InitiatorWwnn optional.String
	InitiatorAliases optional.String
	IgroupsUuid optional.String
	IgroupsName optional.String
	SvmUuid optional.String
	SvmName optional.String
	InterfaceName optional.String
	InterfaceWwpn optional.String
	InterfaceUuid optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NVMeApiService) FcLoginCollectionGet(ctx context.Context, localVarOptionals *FcLoginCollectionGetOpts) (FcLoginResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FcLoginResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/fc/logins"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Protocol.IsSet() {
		localVarQueryParams.Add("protocol", parameterToString(localVarOptionals.Protocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitiatorPortAddress.IsSet() {
		localVarQueryParams.Add("initiator.port_address", parameterToString(localVarOptionals.InitiatorPortAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitiatorWwpn.IsSet() {
		localVarQueryParams.Add("initiator.wwpn", parameterToString(localVarOptionals.InitiatorWwpn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitiatorWwnn.IsSet() {
		localVarQueryParams.Add("initiator.wwnn", parameterToString(localVarOptionals.InitiatorWwnn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitiatorAliases.IsSet() {
		localVarQueryParams.Add("initiator.aliases", parameterToString(localVarOptionals.InitiatorAliases.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IgroupsUuid.IsSet() {
		localVarQueryParams.Add("igroups.uuid", parameterToString(localVarOptionals.IgroupsUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IgroupsName.IsSet() {
		localVarQueryParams.Add("igroups.name", parameterToString(localVarOptionals.IgroupsName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InterfaceName.IsSet() {
		localVarQueryParams.Add("interface.name", parameterToString(localVarOptionals.InterfaceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InterfaceWwpn.IsSet() {
		localVarQueryParams.Add("interface.wwpn", parameterToString(localVarOptionals.InterfaceWwpn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InterfaceUuid.IsSet() {
		localVarQueryParams.Add("interface.uuid", parameterToString(localVarOptionals.InterfaceUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FcLoginResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NVMeApiService
Retrieves an FC login. ### Related ONTAP commands * &#x60;vserver fcp initiator show&#x60; ### Learn more * SAN: [&#x60;DOC /network/fc/logins&#x60;](#docs-SAN-network_fc_logins) * NVMe: [&#x60;DOC /network/fc/logins&#x60;](#docs-NVMe-network_fc_logins) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param interfaceUuid The unique identifier of the FC interface through which the initiator logged in. 
 * @param initiatorWwpn The world wide port name (WWPN) of the initiator. 
 * @param optional nil or *FcLoginGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return FcLogin
*/

type FcLoginGetOpts struct { 
	Fields optional.Interface
}

func (a *NVMeApiService) FcLoginGet(ctx context.Context, interfaceUuid string, initiatorWwpn string, localVarOptionals *FcLoginGetOpts) (FcLogin, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FcLogin
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/fc/logins/{interface.uuid}/{initiator.wwpn}"
	localVarPath = strings.Replace(localVarPath, "{"+"interface.uuid"+"}", fmt.Sprintf("%v", interfaceUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"initiator.wwpn"+"}", fmt.Sprintf("%v", initiatorWwpn), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FcLogin
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NVMeApiService
Retrieves NVMe interfaces. ### Related ONTAP commands * &#x60;vserver nvme show-interface&#x60; ### Learn more * [&#x60;DOC /protocols/nvme/interfaces&#x60;](#docs-NVMe-protocols_nvme_interfaces) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *NvmeInterfaceCollectionGetOpts - Optional Parameters:
     * @param "TransportAddress" (optional.String) -  Filter by transport_address
     * @param "Name" (optional.String) -  Filter by name
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "Enabled" (optional.Bool) -  Filter by enabled
     * @param "FcInterfaceWwpn" (optional.String) -  Filter by fc_interface.wwpn
     * @param "FcInterfaceWwnn" (optional.String) -  Filter by fc_interface.wwnn
     * @param "FcInterfacePortName" (optional.String) -  Filter by fc_interface.port.name
     * @param "FcInterfacePortNodeName" (optional.String) -  Filter by fc_interface.port.node.name
     * @param "FcInterfacePortUuid" (optional.String) -  Filter by fc_interface.port.uuid
     * @param "Uuid" (optional.String) -  Filter by uuid
     * @param "NodeUuid" (optional.String) -  Filter by node.uuid
     * @param "NodeName" (optional.String) -  Filter by node.name
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return NvmeInterfaceResponse
*/

type NvmeInterfaceCollectionGetOpts struct { 
	TransportAddress optional.String
	Name optional.String
	SvmUuid optional.String
	SvmName optional.String
	Enabled optional.Bool
	FcInterfaceWwpn optional.String
	FcInterfaceWwnn optional.String
	FcInterfacePortName optional.String
	FcInterfacePortNodeName optional.String
	FcInterfacePortUuid optional.String
	Uuid optional.String
	NodeUuid optional.String
	NodeName optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NVMeApiService) NvmeInterfaceCollectionGet(ctx context.Context, localVarOptionals *NvmeInterfaceCollectionGetOpts) (NvmeInterfaceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NvmeInterfaceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nvme/interfaces"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.TransportAddress.IsSet() {
		localVarQueryParams.Add("transport_address", parameterToString(localVarOptionals.TransportAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarQueryParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FcInterfaceWwpn.IsSet() {
		localVarQueryParams.Add("fc_interface.wwpn", parameterToString(localVarOptionals.FcInterfaceWwpn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FcInterfaceWwnn.IsSet() {
		localVarQueryParams.Add("fc_interface.wwnn", parameterToString(localVarOptionals.FcInterfaceWwnn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FcInterfacePortName.IsSet() {
		localVarQueryParams.Add("fc_interface.port.name", parameterToString(localVarOptionals.FcInterfacePortName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FcInterfacePortNodeName.IsSet() {
		localVarQueryParams.Add("fc_interface.port.node.name", parameterToString(localVarOptionals.FcInterfacePortNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FcInterfacePortUuid.IsSet() {
		localVarQueryParams.Add("fc_interface.port.uuid", parameterToString(localVarOptionals.FcInterfacePortUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NodeUuid.IsSet() {
		localVarQueryParams.Add("node.uuid", parameterToString(localVarOptionals.NodeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NodeName.IsSet() {
		localVarQueryParams.Add("node.name", parameterToString(localVarOptionals.NodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NvmeInterfaceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NVMeApiService
Retrieves an NVMe interface. ### Related ONTAP commands * &#x60;vserver nvme show-interface&#x60; ### Learn more * [&#x60;DOC /protocols/nvme/interfaces&#x60;](#docs-NVMe-protocols_nvme_interfaces) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid The unique identifier of the NVMe interface. 

@return NvmeInterface
*/
func (a *NVMeApiService) NvmeInterfaceGet(ctx context.Context, uuid string) (NvmeInterface, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NvmeInterface
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nvme/interfaces/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NvmeInterface
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NVMeApiService
Retrieves NVMe namespaces. ### Expensive properties There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the &#x60;fields&#x60; query parameter. See [&#x60;DOC Requesting specific fields&#x60;](#docs-docs-Requesting-specific-fields) to learn more. * &#x60;auto_delete&#x60; * &#x60;subsystem_map.*&#x60; * &#x60;status.mapped&#x60; ### Related ONTAP commands * &#x60;vserver nvme namespace show&#x60; * &#x60;vserver nvme subsystem map show&#x60; ### Learn more * [&#x60;DOC /storage/namespaces&#x60;](#docs-NVMe-storage_namespaces) to learn more and examples. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *NvmeNamespaceCollectionGetOpts - Optional Parameters:
     * @param "Enabled" (optional.Bool) -  Filter by enabled
     * @param "Comment" (optional.String) -  Filter by comment
     * @param "SubsystemMapNsid" (optional.String) -  Filter by subsystem_map.nsid
     * @param "SubsystemMapAnagrpid" (optional.String) -  Filter by subsystem_map.anagrpid
     * @param "SubsystemMapSubsystemName" (optional.String) -  Filter by subsystem_map.subsystem.name
     * @param "SubsystemMapSubsystemUuid" (optional.String) -  Filter by subsystem_map.subsystem.uuid
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "Name" (optional.String) -  Filter by name
     * @param "OsType" (optional.String) -  Filter by os_type
     * @param "Uuid" (optional.String) -  Filter by uuid
     * @param "AutoDelete" (optional.Bool) -  Filter by auto_delete
     * @param "StatusContainerState" (optional.String) -  Filter by status.container_state
     * @param "StatusMapped" (optional.Bool) -  Filter by status.mapped
     * @param "StatusState" (optional.String) -  Filter by status.state
     * @param "StatusReadOnly" (optional.Bool) -  Filter by status.read_only
     * @param "LocationQtreeName" (optional.String) -  Filter by location.qtree.name
     * @param "LocationQtreeId" (optional.Int32) -  Filter by location.qtree.id
     * @param "LocationVolumeName" (optional.String) -  Filter by location.volume.name
     * @param "LocationVolumeUuid" (optional.String) -  Filter by location.volume.uuid
     * @param "LocationNamespace" (optional.String) -  Filter by location.namespace
     * @param "SpaceGuaranteeReserved" (optional.Bool) -  Filter by space.guarantee.reserved
     * @param "SpaceGuaranteeRequested" (optional.Bool) -  Filter by space.guarantee.requested
     * @param "SpaceBlockSize" (optional.Int32) -  Filter by space.block_size
     * @param "SpaceSize" (optional.Int32) -  Filter by space.size
     * @param "SpaceUsed" (optional.Int32) -  Filter by space.used
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return NvmeNamespaceResponse
*/

type NvmeNamespaceCollectionGetOpts struct { 
	Enabled optional.Bool
	Comment optional.String
	SubsystemMapNsid optional.String
	SubsystemMapAnagrpid optional.String
	SubsystemMapSubsystemName optional.String
	SubsystemMapSubsystemUuid optional.String
	SvmUuid optional.String
	SvmName optional.String
	Name optional.String
	OsType optional.String
	Uuid optional.String
	AutoDelete optional.Bool
	StatusContainerState optional.String
	StatusMapped optional.Bool
	StatusState optional.String
	StatusReadOnly optional.Bool
	LocationQtreeName optional.String
	LocationQtreeId optional.Int32
	LocationVolumeName optional.String
	LocationVolumeUuid optional.String
	LocationNamespace optional.String
	SpaceGuaranteeReserved optional.Bool
	SpaceGuaranteeRequested optional.Bool
	SpaceBlockSize optional.Int32
	SpaceSize optional.Int32
	SpaceUsed optional.Int32
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NVMeApiService) NvmeNamespaceCollectionGet(ctx context.Context, localVarOptionals *NvmeNamespaceCollectionGetOpts) (NvmeNamespaceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NvmeNamespaceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/namespaces"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarQueryParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Comment.IsSet() {
		localVarQueryParams.Add("comment", parameterToString(localVarOptionals.Comment.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubsystemMapNsid.IsSet() {
		localVarQueryParams.Add("subsystem_map.nsid", parameterToString(localVarOptionals.SubsystemMapNsid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubsystemMapAnagrpid.IsSet() {
		localVarQueryParams.Add("subsystem_map.anagrpid", parameterToString(localVarOptionals.SubsystemMapAnagrpid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubsystemMapSubsystemName.IsSet() {
		localVarQueryParams.Add("subsystem_map.subsystem.name", parameterToString(localVarOptionals.SubsystemMapSubsystemName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubsystemMapSubsystemUuid.IsSet() {
		localVarQueryParams.Add("subsystem_map.subsystem.uuid", parameterToString(localVarOptionals.SubsystemMapSubsystemUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OsType.IsSet() {
		localVarQueryParams.Add("os_type", parameterToString(localVarOptionals.OsType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AutoDelete.IsSet() {
		localVarQueryParams.Add("auto_delete", parameterToString(localVarOptionals.AutoDelete.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatusContainerState.IsSet() {
		localVarQueryParams.Add("status.container_state", parameterToString(localVarOptionals.StatusContainerState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatusMapped.IsSet() {
		localVarQueryParams.Add("status.mapped", parameterToString(localVarOptionals.StatusMapped.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatusState.IsSet() {
		localVarQueryParams.Add("status.state", parameterToString(localVarOptionals.StatusState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatusReadOnly.IsSet() {
		localVarQueryParams.Add("status.read_only", parameterToString(localVarOptionals.StatusReadOnly.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationQtreeName.IsSet() {
		localVarQueryParams.Add("location.qtree.name", parameterToString(localVarOptionals.LocationQtreeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationQtreeId.IsSet() {
		localVarQueryParams.Add("location.qtree.id", parameterToString(localVarOptionals.LocationQtreeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationVolumeName.IsSet() {
		localVarQueryParams.Add("location.volume.name", parameterToString(localVarOptionals.LocationVolumeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationVolumeUuid.IsSet() {
		localVarQueryParams.Add("location.volume.uuid", parameterToString(localVarOptionals.LocationVolumeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationNamespace.IsSet() {
		localVarQueryParams.Add("location.namespace", parameterToString(localVarOptionals.LocationNamespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceGuaranteeReserved.IsSet() {
		localVarQueryParams.Add("space.guarantee.reserved", parameterToString(localVarOptionals.SpaceGuaranteeReserved.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceGuaranteeRequested.IsSet() {
		localVarQueryParams.Add("space.guarantee.requested", parameterToString(localVarOptionals.SpaceGuaranteeRequested.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceBlockSize.IsSet() {
		localVarQueryParams.Add("space.block_size", parameterToString(localVarOptionals.SpaceBlockSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceSize.IsSet() {
		localVarQueryParams.Add("space.size", parameterToString(localVarOptionals.SpaceSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceUsed.IsSet() {
		localVarQueryParams.Add("space.used", parameterToString(localVarOptionals.SpaceUsed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NvmeNamespaceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NVMeApiService
Creates an NVMe namespace. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the NVMe namespace. * &#x60;name&#x60;, &#x60;location.volume.name&#x60; or &#x60;location.volume.uuid&#x60; - Existing volume in which to create the NVMe namespace. * &#x60;name&#x60; or &#x60;location.namespace&#x60; - Base name for the NVMe namespace. * &#x60;os_type&#x60; - Operating system from which the NVMe namespace will be accessed. (Not used for clones, which are created based on the &#x60;os_type&#x60; of the source NVMe namespace.) * &#x60;space.size&#x60; - Size for the NVMe namespace. (Not used for clones, which are created based on the size of the source NVMe namespace.) ### Default property values If not specified in POST, the following default property values are assigned: * &#x60;auto_delete&#x60; - _false_ * &#x60;space.block_size&#x60; - _4096_ ### Related ONTAP commands * &#x60;volume file clone autodelete&#x60; * &#x60;volume file clone create&#x60; * &#x60;vserver nvme namespace create&#x60; ### Learn more * [&#x60;DOC /storage/namespaces&#x60;](#docs-NVMe-storage_namespaces) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info The property values for the new NVMe namespace. 

@return NvmeNamespaceResponse
*/
func (a *NVMeApiService) NvmeNamespaceCreate(ctx context.Context, info NvmeNamespace) (NvmeNamespaceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NvmeNamespaceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/namespaces"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v NvmeNamespaceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NVMeApiService
Deletes an NVMe namespace. ### Related ONTAP commands * &#x60;vserver nvme namespace delete&#x60; ### Learn more * [&#x60;DOC /storage/namespaces&#x60;](#docs-NVMe-storage_namespaces) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid The unique identifier of the NVMe namespace to delete. 
 * @param optional nil or *NvmeNamespaceDeleteOpts - Optional Parameters:
     * @param "AllowDeleteWhileMapped" (optional.Bool) -  Allows deletion of a mapped NVMe namespace. A mapped NVMe namespace might be in use. Deleting a mapped namespace also deletes the namespace map and makes the data no longer available, possibly causing a disruption in the availability of data. **This parameter should be used with caution.** 


*/

type NvmeNamespaceDeleteOpts struct { 
	AllowDeleteWhileMapped optional.Bool
}

func (a *NVMeApiService) NvmeNamespaceDelete(ctx context.Context, uuid string, localVarOptionals *NvmeNamespaceDeleteOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/namespaces/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AllowDeleteWhileMapped.IsSet() {
		localVarQueryParams.Add("allow_delete_while_mapped", parameterToString(localVarOptionals.AllowDeleteWhileMapped.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NVMeApiService
Retrieves an NVMe namespace. ### Expensive properties There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the &#x60;fields&#x60; query parameter. See [&#x60;DOC Requesting specific fields&#x60;](#docs-docs-Requesting-specific-fields) to learn more. * &#x60;auto_delete&#x60; * &#x60;subsystem_map.*&#x60; * &#x60;status.mapped&#x60; ### Related ONTAP commands * &#x60;vserver nvme namespace show&#x60; * &#x60;vserver nvme subsystem map show&#x60; ### Learn more * [&#x60;DOC /storage/namespaces&#x60;](#docs-NVMe-storage_namespaces) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid The unique identifier of the NVMe namespace to retrieve. 
 * @param optional nil or *NvmeNamespaceGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return NvmeNamespace
*/

type NvmeNamespaceGetOpts struct { 
	Fields optional.Interface
}

func (a *NVMeApiService) NvmeNamespaceGet(ctx context.Context, uuid string, localVarOptionals *NvmeNamespaceGetOpts) (NvmeNamespace, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NvmeNamespace
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/namespaces/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NvmeNamespace
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NVMeApiService
Updates an NVMe namespace. ### Related ONTAP commands * &#x60;volume file clone autodelete&#x60; * &#x60;vserver nvme namespace modify&#x60; ### Learn more * [&#x60;DOC /storage/namespaces&#x60;](#docs-NVMe-storage_namespaces) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid The unique identifier of the NVMe namespace to update. 
 * @param info The new property values for the NVMe namespace. 


*/
func (a *NVMeApiService) NvmeNamespaceModify(ctx context.Context, uuid string, info NvmeNamespace) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/namespaces/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NVMeApiService
Retrieves NVMe services. ### Related ONTAP commands * &#x60;vserver nvme show&#x60; ### Learn more * [&#x60;DOC /protocols/nvme/services&#x60;](#docs-NVMe-protocols_nvme_services) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *NvmeServiceCollectionGetOpts - Optional Parameters:
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "Enabled" (optional.Bool) -  Filter by enabled
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return NvmeServiceResponse
*/

type NvmeServiceCollectionGetOpts struct { 
	SvmUuid optional.String
	SvmName optional.String
	Enabled optional.Bool
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NVMeApiService) NvmeServiceCollectionGet(ctx context.Context, localVarOptionals *NvmeServiceCollectionGetOpts) (NvmeServiceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NvmeServiceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nvme/services"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarQueryParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NvmeServiceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NVMeApiService
Creates an NVMe service. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - The existing SVM in which to create the NVMe service. ### Related ONTAP commands * &#x60;vserver nvme create&#x60; ### Learn more * [&#x60;DOC /protocols/nvme/services&#x60;](#docs-NVMe-protocols_nvme_services) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info The property values for the new NVMe service. 

@return NvmeServiceResponse
*/
func (a *NVMeApiService) NvmeServiceCreate(ctx context.Context, info NvmeService) (NvmeServiceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NvmeServiceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nvme/services"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v NvmeServiceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NVMeApiService
Deletes an NVMe service. An NVMe service must be disabled before it can be deleted. In addition, all NVMe interfaces, subsystems, and subsystem maps associated with the SVM must first be deleted. ### Related ONTAP commands * &#x60;vserver nvme delete&#x60; ### Learn more * [&#x60;DOC /protocols/nvme/services&#x60;](#docs-NVMe-protocols_nvme_services) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid The unique identifier of the SVM whose NVMe service is to be deleted. 


*/
func (a *NVMeApiService) NvmeServiceDelete(ctx context.Context, svmUuid string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nvme/services/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NVMeApiService
Retrieves an NVMe service. ### Related ONTAP commands * &#x60;vserver nvme show&#x60; ### Learn more * [&#x60;DOC /protocols/nvme/services&#x60;](#docs-NVMe-protocols_nvme_services) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid The unique identifier of the SVM whose NVMe service is to be retrieved. 
 * @param optional nil or *NvmeServiceGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return NvmeService
*/

type NvmeServiceGetOpts struct { 
	Fields optional.Interface
}

func (a *NVMeApiService) NvmeServiceGet(ctx context.Context, svmUuid string, localVarOptionals *NvmeServiceGetOpts) (NvmeService, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NvmeService
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nvme/services/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NvmeService
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NVMeApiService
Updates an NVMe service. ### Related ONTAP commands * &#x60;vserver nvme modify&#x60; ### Learn more * [&#x60;DOC /protocols/nvme/services&#x60;](#docs-NVMe-protocols_nvme_services) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid The unique identifier of the SVM whose NVMe service is to be updated. 
 * @param info The new property values for the NVMe service. 


*/
func (a *NVMeApiService) NvmeServiceModify(ctx context.Context, svmUuid string, info NvmeService) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nvme/services/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NVMeApiService
Retrieves NVMe subsystems. ### Related ONTAP commands * &#x60;vserver nvme subsystem host show&#x60; * &#x60;vserver nvme subsystem map show&#x60; * &#x60;vserver nvme subsystem show&#x60; ### Learn more * [&#x60;DOC /protocols/nvme/subsystems&#x60;](#docs-NVMe-protocols_nvme_subsystems) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *NvmeSubsystemCollectionGetOpts - Optional Parameters:
     * @param "Comment" (optional.String) -  Filter by comment
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "Name" (optional.String) -  Filter by name
     * @param "IoQueueDefaultCount" (optional.Int32) -  Filter by io_queue.default.count
     * @param "IoQueueDefaultDepth" (optional.Int32) -  Filter by io_queue.default.depth
     * @param "OsType" (optional.String) -  Filter by os_type
     * @param "SerialNumber" (optional.String) -  Filter by serial_number
     * @param "Uuid" (optional.String) -  Filter by uuid
     * @param "HostsNqn" (optional.String) -  Filter by hosts.nqn
     * @param "SubsystemMapsNamespaceName" (optional.String) -  Filter by subsystem_maps.namespace.name
     * @param "SubsystemMapsNamespaceUuid" (optional.String) -  Filter by subsystem_maps.namespace.uuid
     * @param "SubsystemMapsAnagrpid" (optional.String) -  Filter by subsystem_maps.anagrpid
     * @param "SubsystemMapsNsid" (optional.String) -  Filter by subsystem_maps.nsid
     * @param "TargetNqn" (optional.String) -  Filter by target_nqn
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return NvmeSubsystemResponse
*/

type NvmeSubsystemCollectionGetOpts struct { 
	Comment optional.String
	SvmUuid optional.String
	SvmName optional.String
	Name optional.String
	IoQueueDefaultCount optional.Int32
	IoQueueDefaultDepth optional.Int32
	OsType optional.String
	SerialNumber optional.String
	Uuid optional.String
	HostsNqn optional.String
	SubsystemMapsNamespaceName optional.String
	SubsystemMapsNamespaceUuid optional.String
	SubsystemMapsAnagrpid optional.String
	SubsystemMapsNsid optional.String
	TargetNqn optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NVMeApiService) NvmeSubsystemCollectionGet(ctx context.Context, localVarOptionals *NvmeSubsystemCollectionGetOpts) (NvmeSubsystemResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NvmeSubsystemResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nvme/subsystems"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Comment.IsSet() {
		localVarQueryParams.Add("comment", parameterToString(localVarOptionals.Comment.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IoQueueDefaultCount.IsSet() {
		localVarQueryParams.Add("io_queue.default.count", parameterToString(localVarOptionals.IoQueueDefaultCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IoQueueDefaultDepth.IsSet() {
		localVarQueryParams.Add("io_queue.default.depth", parameterToString(localVarOptionals.IoQueueDefaultDepth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OsType.IsSet() {
		localVarQueryParams.Add("os_type", parameterToString(localVarOptionals.OsType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SerialNumber.IsSet() {
		localVarQueryParams.Add("serial_number", parameterToString(localVarOptionals.SerialNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HostsNqn.IsSet() {
		localVarQueryParams.Add("hosts.nqn", parameterToString(localVarOptionals.HostsNqn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubsystemMapsNamespaceName.IsSet() {
		localVarQueryParams.Add("subsystem_maps.namespace.name", parameterToString(localVarOptionals.SubsystemMapsNamespaceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubsystemMapsNamespaceUuid.IsSet() {
		localVarQueryParams.Add("subsystem_maps.namespace.uuid", parameterToString(localVarOptionals.SubsystemMapsNamespaceUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubsystemMapsAnagrpid.IsSet() {
		localVarQueryParams.Add("subsystem_maps.anagrpid", parameterToString(localVarOptionals.SubsystemMapsAnagrpid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubsystemMapsNsid.IsSet() {
		localVarQueryParams.Add("subsystem_maps.nsid", parameterToString(localVarOptionals.SubsystemMapsNsid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TargetNqn.IsSet() {
		localVarQueryParams.Add("target_nqn", parameterToString(localVarOptionals.TargetNqn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NvmeSubsystemResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NVMeApiService
Retrieves NVMe subsystem controllers. ### Related ONTAP commands * &#x60;vserver nvme subsystem controller show&#x60; ### Learn more * [&#x60;DOC /protocols/nvme/subsystem-controllers&#x60;](#docs-NVMe-protocols_nvme_subsystem-controllers) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *NvmeSubsystemControllerCollectionGetOpts - Optional Parameters:
     * @param "InterfaceUuid" (optional.String) -  Filter by interface.uuid
     * @param "InterfaceName" (optional.String) -  Filter by interface.name
     * @param "InterfaceTransportAddress" (optional.String) -  Filter by interface.transport_address
     * @param "Id" (optional.String) -  Filter by id
     * @param "AdminQueueDepth" (optional.Int32) -  Filter by admin_queue.depth
     * @param "HostId" (optional.String) -  Filter by host.id
     * @param "HostTransportAddress" (optional.String) -  Filter by host.transport_address
     * @param "HostNqn" (optional.String) -  Filter by host.nqn
     * @param "IoQueueCount" (optional.Int32) -  Filter by io_queue.count
     * @param "IoQueueDepth" (optional.Int32) -  Filter by io_queue.depth
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "NodeUuid" (optional.String) -  Filter by node.uuid
     * @param "NodeName" (optional.String) -  Filter by node.name
     * @param "SubsystemName" (optional.String) -  Filter by subsystem.name
     * @param "SubsystemUuid" (optional.String) -  Filter by subsystem.uuid
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return NvmeSubsystemControllerResponse
*/

type NvmeSubsystemControllerCollectionGetOpts struct { 
	InterfaceUuid optional.String
	InterfaceName optional.String
	InterfaceTransportAddress optional.String
	Id optional.String
	AdminQueueDepth optional.Int32
	HostId optional.String
	HostTransportAddress optional.String
	HostNqn optional.String
	IoQueueCount optional.Int32
	IoQueueDepth optional.Int32
	SvmUuid optional.String
	SvmName optional.String
	NodeUuid optional.String
	NodeName optional.String
	SubsystemName optional.String
	SubsystemUuid optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NVMeApiService) NvmeSubsystemControllerCollectionGet(ctx context.Context, localVarOptionals *NvmeSubsystemControllerCollectionGetOpts) (NvmeSubsystemControllerResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NvmeSubsystemControllerResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nvme/subsystem-controllers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.InterfaceUuid.IsSet() {
		localVarQueryParams.Add("interface.uuid", parameterToString(localVarOptionals.InterfaceUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InterfaceName.IsSet() {
		localVarQueryParams.Add("interface.name", parameterToString(localVarOptionals.InterfaceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InterfaceTransportAddress.IsSet() {
		localVarQueryParams.Add("interface.transport_address", parameterToString(localVarOptionals.InterfaceTransportAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AdminQueueDepth.IsSet() {
		localVarQueryParams.Add("admin_queue.depth", parameterToString(localVarOptionals.AdminQueueDepth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HostId.IsSet() {
		localVarQueryParams.Add("host.id", parameterToString(localVarOptionals.HostId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HostTransportAddress.IsSet() {
		localVarQueryParams.Add("host.transport_address", parameterToString(localVarOptionals.HostTransportAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HostNqn.IsSet() {
		localVarQueryParams.Add("host.nqn", parameterToString(localVarOptionals.HostNqn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IoQueueCount.IsSet() {
		localVarQueryParams.Add("io_queue.count", parameterToString(localVarOptionals.IoQueueCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IoQueueDepth.IsSet() {
		localVarQueryParams.Add("io_queue.depth", parameterToString(localVarOptionals.IoQueueDepth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NodeUuid.IsSet() {
		localVarQueryParams.Add("node.uuid", parameterToString(localVarOptionals.NodeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NodeName.IsSet() {
		localVarQueryParams.Add("node.name", parameterToString(localVarOptionals.NodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubsystemName.IsSet() {
		localVarQueryParams.Add("subsystem.name", parameterToString(localVarOptionals.SubsystemName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubsystemUuid.IsSet() {
		localVarQueryParams.Add("subsystem.uuid", parameterToString(localVarOptionals.SubsystemUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NvmeSubsystemControllerResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NVMeApiService
Retrieves an NVMe subsystem controller. ### Related ONTAP commands * &#x60;vserver nvme subsystem controller show&#x60; ### Learn more * [&#x60;DOC /protocols/nvme/subsystem-controllers&#x60;](#docs-NVMe-protocols_nvme_subsystem-controllers) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param subsystemUuid The unique identifier of the NVMe subsystem. 
 * @param id The unique identifier of the NVMe subsystem controller. 
 * @param optional nil or *NvmeSubsystemControllerGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return NvmeSubsystemController
*/

type NvmeSubsystemControllerGetOpts struct { 
	Fields optional.Interface
}

func (a *NVMeApiService) NvmeSubsystemControllerGet(ctx context.Context, subsystemUuid string, id string, localVarOptionals *NvmeSubsystemControllerGetOpts) (NvmeSubsystemController, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NvmeSubsystemController
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nvme/subsystem-controllers/{subsystem.uuid}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"subsystem.uuid"+"}", fmt.Sprintf("%v", subsystemUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NvmeSubsystemController
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NVMeApiService
Creates an NVMe subsystem. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the NVMe subsystem. * &#x60;name&#x60; - Name for NVMe subsystem. Once created, an NVMe subsytem cannot be renamed. * &#x60;os_type&#x60; - Operating system of the NVMe subsystem&#39;s hosts. ### Related ONTAP commands * &#x60;vserver nvme subsystem create&#x60; ### Learn more * [&#x60;DOC /protocols/nvme/subsystems&#x60;](#docs-NVMe-protocols_nvme_subsystems) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info The property values for the new NVMe subsystem. 

@return NvmeSubsystemResponse
*/
func (a *NVMeApiService) NvmeSubsystemCreate(ctx context.Context, info NvmeSubsystem) (NvmeSubsystemResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NvmeSubsystemResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nvme/subsystems"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v NvmeSubsystemResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NVMeApiService
Removes an NVMe subsystem. ### Related ONTAP commands * &#x60;vserver nvme subsystem delete&#x60; ### Learn more * [&#x60;DOC /protocols/nvme/subsystems&#x60;](#docs-NVMe-protocols_nvme_subsystems) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid The unique identifier of the NVMe subsystem. 
 * @param optional nil or *NvmeSubsystemDeleteOpts - Optional Parameters:
     * @param "AllowDeleteWhileMapped" (optional.Bool) -  Allows for the deletion of a mapped NVMe subsystem. 
     * @param "AllowDeleteWithHosts" (optional.Bool) -  Allows for the deletion of an NVMe subsystem with NVMe hosts. 


*/

type NvmeSubsystemDeleteOpts struct { 
	AllowDeleteWhileMapped optional.Bool
	AllowDeleteWithHosts optional.Bool
}

func (a *NVMeApiService) NvmeSubsystemDelete(ctx context.Context, uuid string, localVarOptionals *NvmeSubsystemDeleteOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nvme/subsystems/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AllowDeleteWhileMapped.IsSet() {
		localVarQueryParams.Add("allow_delete_while_mapped", parameterToString(localVarOptionals.AllowDeleteWhileMapped.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AllowDeleteWithHosts.IsSet() {
		localVarQueryParams.Add("allow_delete_with_hosts", parameterToString(localVarOptionals.AllowDeleteWithHosts.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NVMeApiService
Retrieves an NVMe subsystem. ### Expensive properties There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the &#x60;fields&#x60; query parameter. See [&#x60;DOC Requesting specific fields&#x60;](#docs-docs-Requesting-specific-fields) to learn more. * &#x60;subsystem_maps.*&#x60; ### Related ONTAP commands * &#x60;vserver nvme subsystem host show&#x60; * &#x60;vserver nvme subsystem map show&#x60; * &#x60;vserver nvme subsystem show&#x60; ### Learn more * [&#x60;DOC /protocols/nvme/subsystems&#x60;](#docs-NVMe-protocols_nvme_subsystems) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid The unique identifier of the NVMe subsystem. 
 * @param optional nil or *NvmeSubsystemGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return NvmeSubsystem
*/

type NvmeSubsystemGetOpts struct { 
	Fields optional.Interface
}

func (a *NVMeApiService) NvmeSubsystemGet(ctx context.Context, uuid string, localVarOptionals *NvmeSubsystemGetOpts) (NvmeSubsystem, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NvmeSubsystem
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nvme/subsystems/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NvmeSubsystem
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NVMeApiService
Retrieves the NVMe subsystem hosts of an NVMe subsystem. ### Expensive properties There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the &#x60;fields&#x60; query parameter. See [&#x60;DOC Requesting specific fields&#x60;](#docs-docs-Requesting-specific-fields) to learn more. * &#x60;subsystem_maps.*&#x60; ### Related ONTAP commands * &#x60;vserver nvme subsystem map show&#x60; * &#x60;vserver nvme subsystem show&#x60; ### Learn more * [&#x60;DOC /protocols/nvme/subsystems&#x60;](#docs-NVMe-protocols_nvme_subsystems) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param subsystemUuid The unique identifier of the NVMe subsystem. 
 * @param optional nil or *NvmeSubsystemHostCollectionGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return NvmeSubsystemHostResponse
*/

type NvmeSubsystemHostCollectionGetOpts struct { 
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NVMeApiService) NvmeSubsystemHostCollectionGet(ctx context.Context, subsystemUuid string, localVarOptionals *NvmeSubsystemHostCollectionGetOpts) (NvmeSubsystemHostResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NvmeSubsystemHostResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nvme/subsystems/{subsystem.uuid}/hosts"
	localVarPath = strings.Replace(localVarPath, "{"+"subsystem.uuid"+"}", fmt.Sprintf("%v", subsystemUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NvmeSubsystemHostResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NVMeApiService
Adds NVMe subsystem host(s) to an NVMe subsystem. ### Required properties * &#x60;nqn&#x60; or &#x60;records.nqn&#x60; - NVMe host(s) NQN(s) to add to the NVMe subsystem. ### Related ONTAP commands * &#x60;vserver nvme subsystem host add&#x60; ### Learn more * [&#x60;DOC /protocols/nvme/subsystems&#x60;](#docs-NVMe-protocols_nvme_subsystems) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param subsystemUuid The unique identifier of the NVMe subsystem. 
 * @param info The property values for the NVMe subsystem host to add to the NVMe subsystem. 

@return NvmeSubsystemHostResponse
*/
func (a *NVMeApiService) NvmeSubsystemHostCreate(ctx context.Context, subsystemUuid string, info NvmeSubsystemHost) (NvmeSubsystemHostResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NvmeSubsystemHostResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nvme/subsystems/{subsystem.uuid}/hosts"
	localVarPath = strings.Replace(localVarPath, "{"+"subsystem.uuid"+"}", fmt.Sprintf("%v", subsystemUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v NvmeSubsystemHostResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NVMeApiService
Deletes an NVMe subsystem host from an NVMe subsystem. ### Related ONTAP commands * &#x60;vserver nvme subsystem host remove&#x60; ### Learn more * [&#x60;DOC /protocols/nvme/subsystems&#x60;](#docs-NVMe-protocols_nvme_subsystems) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param subsystemUuid The unique identifier of the NVMe subsystem. 
 * @param nqn The NVMe qualified name (NQN) used to identify the NVMe subsystem host. 


*/
func (a *NVMeApiService) NvmeSubsystemHostDelete(ctx context.Context, subsystemUuid string, nqn string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nvme/subsystems/{subsystem.uuid}/hosts/{nqn}"
	localVarPath = strings.Replace(localVarPath, "{"+"subsystem.uuid"+"}", fmt.Sprintf("%v", subsystemUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nqn"+"}", fmt.Sprintf("%v", nqn), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NVMeApiService
Retrieves an NVMe subsystem host of an NVMe subsystem. ### Related ONTAP commands * &#x60;vserver nvme subsystem host show&#x60; ### Learn more * [&#x60;DOC /protocols/nvme/subsystems&#x60;](#docs-NVMe-protocols_nvme_subsystems) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param subsystemUuid The unique identifier of the NVMe subsystem. 
 * @param nqn The NVMe qualified name (NQN) used to identify the NVMe subsystem host. 
 * @param optional nil or *NvmeSubsystemHostGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return NvmeSubsystemHost
*/

type NvmeSubsystemHostGetOpts struct { 
	Fields optional.Interface
}

func (a *NVMeApiService) NvmeSubsystemHostGet(ctx context.Context, subsystemUuid string, nqn string, localVarOptionals *NvmeSubsystemHostGetOpts) (NvmeSubsystemHost, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NvmeSubsystemHost
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nvme/subsystems/{subsystem.uuid}/hosts/{nqn}"
	localVarPath = strings.Replace(localVarPath, "{"+"subsystem.uuid"+"}", fmt.Sprintf("%v", subsystemUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nqn"+"}", fmt.Sprintf("%v", nqn), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NvmeSubsystemHost
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NVMeApiService
Retrieves NVMe subsystem maps. ### Expensive properties There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the &#x60;fields&#x60; query parameter. See [&#x60;DOC Requesting specific fields&#x60;](#docs-docs-Requesting-specific-fields) to learn more. * &#x60;anagrpid&#x60; ### Related ONTAP commands * &#x60;vserver nvme subsystem map show&#x60; ### Learn more * [&#x60;DOC /protocols/nvme/subsystem-maps&#x60;](#docs-NVMe-protocols_nvme_subsystem-maps) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *NvmeSubsystemMapCollectionGetOpts - Optional Parameters:
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "Nsid" (optional.String) -  Filter by nsid
     * @param "NamespaceName" (optional.String) -  Filter by namespace.name
     * @param "NamespaceUuid" (optional.String) -  Filter by namespace.uuid
     * @param "NamespaceNodeUuid" (optional.String) -  Filter by namespace.node.uuid
     * @param "NamespaceNodeName" (optional.String) -  Filter by namespace.node.name
     * @param "SubsystemName" (optional.String) -  Filter by subsystem.name
     * @param "SubsystemUuid" (optional.String) -  Filter by subsystem.uuid
     * @param "Anagrpid" (optional.String) -  Filter by anagrpid
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return NvmeSubsystemMapResponse
*/

type NvmeSubsystemMapCollectionGetOpts struct { 
	SvmUuid optional.String
	SvmName optional.String
	Nsid optional.String
	NamespaceName optional.String
	NamespaceUuid optional.String
	NamespaceNodeUuid optional.String
	NamespaceNodeName optional.String
	SubsystemName optional.String
	SubsystemUuid optional.String
	Anagrpid optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NVMeApiService) NvmeSubsystemMapCollectionGet(ctx context.Context, localVarOptionals *NvmeSubsystemMapCollectionGetOpts) (NvmeSubsystemMapResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NvmeSubsystemMapResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nvme/subsystem-maps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Nsid.IsSet() {
		localVarQueryParams.Add("nsid", parameterToString(localVarOptionals.Nsid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NamespaceName.IsSet() {
		localVarQueryParams.Add("namespace.name", parameterToString(localVarOptionals.NamespaceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NamespaceUuid.IsSet() {
		localVarQueryParams.Add("namespace.uuid", parameterToString(localVarOptionals.NamespaceUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NamespaceNodeUuid.IsSet() {
		localVarQueryParams.Add("namespace.node.uuid", parameterToString(localVarOptionals.NamespaceNodeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NamespaceNodeName.IsSet() {
		localVarQueryParams.Add("namespace.node.name", parameterToString(localVarOptionals.NamespaceNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubsystemName.IsSet() {
		localVarQueryParams.Add("subsystem.name", parameterToString(localVarOptionals.SubsystemName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubsystemUuid.IsSet() {
		localVarQueryParams.Add("subsystem.uuid", parameterToString(localVarOptionals.SubsystemUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Anagrpid.IsSet() {
		localVarQueryParams.Add("anagrpid", parameterToString(localVarOptionals.Anagrpid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NvmeSubsystemMapResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NVMeApiService
Creates an NVMe subsystem map. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the NVMe subsystem map. * &#x60;namespace.uuid&#x60; or &#x60;namespace.name&#x60; - Existing NVMe namespace to map to the specified NVme subsystem. * &#x60;subsystem.uuid&#x60; or &#x60;subsystem.name&#x60; - Existing NVMe subsystem to map to the specified NVMe namespace. ### Related ONTAP commands * &#x60;vserver nvme subsystem map create&#x60; ### Learn more * [&#x60;DOC /protocols/nvme/subsystem-maps&#x60;](#docs-NVMe-protocols_nvme_subsystem-maps) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info The property values for the new NVMe subsystem map. 

@return NvmeSubsystemMapResponse
*/
func (a *NVMeApiService) NvmeSubsystemMapCreate(ctx context.Context, info NvmeSubsystemMap) (NvmeSubsystemMapResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NvmeSubsystemMapResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nvme/subsystem-maps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v NvmeSubsystemMapResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NVMeApiService
Deletes an NVMe subsystem map. ### Related ONTAP commands * &#x60;vserver nvme subsystem map delete&#x60; ### Learn more * [&#x60;DOC /protocols/nvme/subsystem-maps&#x60;](#docs-NVMe-protocols_nvme_subsystem-maps) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param subsystemUuid The unique identifier of the NVMe subsystem. 
 * @param namespaceUuid The unique identifier of the NVMe namespace. 

@return NvmeSubsystemMapResponse
*/
func (a *NVMeApiService) NvmeSubsystemMapDelete(ctx context.Context, subsystemUuid string, namespaceUuid string) (NvmeSubsystemMapResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NvmeSubsystemMapResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nvme/subsystem-maps/{subsystem.uuid}/{namespace.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"subsystem.uuid"+"}", fmt.Sprintf("%v", subsystemUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace.uuid"+"}", fmt.Sprintf("%v", namespaceUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NvmeSubsystemMapResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NVMeApiService
Retrieves an NVMe subsystem map. ### Expensive properties There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the &#x60;fields&#x60; query parameter. See [&#x60;DOC Requesting specific fields&#x60;](#docs-docs-Requesting-specific-fields) to learn more. * &#x60;anagrpid&#x60; ### Related ONTAP commands * &#x60;vserver nvme subsystem map show&#x60; ### Learn more * [&#x60;DOC /protocols/nvme/subsystem-maps&#x60;](#docs-NVMe-protocols_nvme_subsystem-maps) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param subsystemUuid The unique identifier of the NVMe subsystem. 
 * @param namespaceUuid The unique identifier of the NVMe namespace. 
 * @param optional nil or *NvmeSubsystemMapGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return NvmeSubsystemMap
*/

type NvmeSubsystemMapGetOpts struct { 
	Fields optional.Interface
}

func (a *NVMeApiService) NvmeSubsystemMapGet(ctx context.Context, subsystemUuid string, namespaceUuid string, localVarOptionals *NvmeSubsystemMapGetOpts) (NvmeSubsystemMap, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NvmeSubsystemMap
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nvme/subsystem-maps/{subsystem.uuid}/{namespace.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"subsystem.uuid"+"}", fmt.Sprintf("%v", subsystemUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace.uuid"+"}", fmt.Sprintf("%v", namespaceUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NvmeSubsystemMap
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NVMeApiService
Updates an NVMe subsystem. ### Related ONTAP commands * &#x60;vserver nvme subsystem modify&#x60; ### Learn more * [&#x60;DOC /protocols/nvme/subsystems&#x60;](#docs-NVMe-protocols_nvme_subsystems) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid The unique identifier of the NVMe subsystem. 
 * @param info The new property values for the NVMe subsystem. 


*/
func (a *NVMeApiService) NvmeSubsystemModify(ctx context.Context, uuid string, info NvmeSubsystem) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nvme/subsystems/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
