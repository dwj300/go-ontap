/*
 * ONTAP REST API
 *
 * ONTAP 9.6 adds support for an expansive RESTful API. The documentation below provides information about the types of API calls available to you, as well as details about using each API endpoint. You can learn more about the ONTAP REST API and ONTAP in the ONTAP 9 Documentation Center:  http://docs.netapp.com/ontap-9/topic/com.netapp.doc.dot-rest-api/home.html. NetApp welcomes your comments and suggestions about the ONTAP REST API and the documentation for its use.</br> **Using the ONTAP 9.6 REST API online documentation** Each API method includes usage examples, as well as a model that displays all the required and optional properties supported by the method. Click the _Model_ link, available with each API method, to see all the required and optional properties supported by each method. 
 *
 * API version: v1
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type NetworkingApiService service

/* 
NetworkingApiService
Retrieves FC interfaces. ### Related ONTAP commands * &#x60;network interface show&#x60; * &#x60;vserver fcp interface show&#x60; ### Learn more * [&#x60;DOC /network/fc/interfaces&#x60;](#docs-networking-network_fc_interfaces) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *FcInterfaceCollectionGetOpts - Optional Parameters:
     * @param "Uuid" (optional.String) -  Filter by uuid
     * @param "DataProtocol" (optional.String) -  Filter by data_protocol
     * @param "Name" (optional.String) -  Filter by name
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "Comment" (optional.String) -  Filter by comment
     * @param "Enabled" (optional.Bool) -  Filter by enabled
     * @param "PortAddress" (optional.String) -  Filter by port_address
     * @param "State" (optional.String) -  Filter by state
     * @param "Wwpn" (optional.String) -  Filter by wwpn
     * @param "LocationPortName" (optional.String) -  Filter by location.port.name
     * @param "LocationPortNodeName" (optional.String) -  Filter by location.port.node.name
     * @param "LocationPortUuid" (optional.String) -  Filter by location.port.uuid
     * @param "LocationNodeUuid" (optional.String) -  Filter by location.node.uuid
     * @param "LocationNodeName" (optional.String) -  Filter by location.node.name
     * @param "Wwnn" (optional.String) -  Filter by wwnn
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return FcInterfaceResponse
*/

type FcInterfaceCollectionGetOpts struct { 
	Uuid optional.String
	DataProtocol optional.String
	Name optional.String
	SvmUuid optional.String
	SvmName optional.String
	Comment optional.String
	Enabled optional.Bool
	PortAddress optional.String
	State optional.String
	Wwpn optional.String
	LocationPortName optional.String
	LocationPortNodeName optional.String
	LocationPortUuid optional.String
	LocationNodeUuid optional.String
	LocationNodeName optional.String
	Wwnn optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NetworkingApiService) FcInterfaceCollectionGet(ctx context.Context, localVarOptionals *FcInterfaceCollectionGetOpts) (FcInterfaceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FcInterfaceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/fc/interfaces"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DataProtocol.IsSet() {
		localVarQueryParams.Add("data_protocol", parameterToString(localVarOptionals.DataProtocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Comment.IsSet() {
		localVarQueryParams.Add("comment", parameterToString(localVarOptionals.Comment.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarQueryParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortAddress.IsSet() {
		localVarQueryParams.Add("port_address", parameterToString(localVarOptionals.PortAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Wwpn.IsSet() {
		localVarQueryParams.Add("wwpn", parameterToString(localVarOptionals.Wwpn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationPortName.IsSet() {
		localVarQueryParams.Add("location.port.name", parameterToString(localVarOptionals.LocationPortName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationPortNodeName.IsSet() {
		localVarQueryParams.Add("location.port.node.name", parameterToString(localVarOptionals.LocationPortNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationPortUuid.IsSet() {
		localVarQueryParams.Add("location.port.uuid", parameterToString(localVarOptionals.LocationPortUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationNodeUuid.IsSet() {
		localVarQueryParams.Add("location.node.uuid", parameterToString(localVarOptionals.LocationNodeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationNodeName.IsSet() {
		localVarQueryParams.Add("location.node.name", parameterToString(localVarOptionals.LocationNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Wwnn.IsSet() {
		localVarQueryParams.Add("wwnn", parameterToString(localVarOptionals.Wwnn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FcInterfaceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NetworkingApiService
Creates an FC interface. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the FC interface. * &#x60;name&#x60; - Name of the FC interface. * &#x60;location.port.uuid&#x60; or both &#x60;location.port.name&#x60; and &#x60;location.port.node.name&#x60; - FC port on which to create the FC interface. * &#x60;data_protocol&#x60; - Data protocol for the FC interface. ### Default property values If not specified in POST, the following default property values are assigned. * &#x60;enabled&#x60; - _true_ ### Related ONTAP commands * &#x60;network interface create&#x60; ### Learn more * [&#x60;DOC /network/fc/interfaces&#x60;](#docs-networking-network_fc_interfaces) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info The property values for the new FC interface. 

@return FcInterfaceResponse
*/
func (a *NetworkingApiService) FcInterfaceCreate(ctx context.Context, info FcInterface) (FcInterfaceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FcInterfaceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/fc/interfaces"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v FcInterfaceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NetworkingApiService
Deletes an FC interface. ### Related ONTAP commands * &#x60;network interface delete&#x60; ### Learn more * [&#x60;DOC /network/fc/interfaces&#x60;](#docs-networking-network_fc_interfaces) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid The unique identifier for the FC interface. 


*/
func (a *NetworkingApiService) FcInterfaceDelete(ctx context.Context, uuid string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/fc/interfaces/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NetworkingApiService
Retrieves a Fibre Channel interface. ### Related ONTAP commands * &#x60;network interface show&#x60; * &#x60;vserver fcp interface show&#x60; ### Learn more * [&#x60;DOC /network/fc/interfaces&#x60;](#docs-networking-network_fc_interfaces) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid The unique identifier for the FC interface. 
 * @param optional nil or *FcInterfaceGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return FcInterface
*/

type FcInterfaceGetOpts struct { 
	Fields optional.Interface
}

func (a *NetworkingApiService) FcInterfaceGet(ctx context.Context, uuid string, localVarOptionals *FcInterfaceGetOpts) (FcInterface, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FcInterface
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/fc/interfaces/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FcInterface
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NetworkingApiService
Updates an FC interface. ### Related ONTAP commands * &#x60;network interface modify&#x60; ### Learn more * [&#x60;DOC /network/fc/interfaces&#x60;](#docs-networking-network_fc_interfaces) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid The unique identifier for the FC interface. 
 * @param info The new property values for the FC interface. 


*/
func (a *NetworkingApiService) FcInterfaceModify(ctx context.Context, uuid string, info FcInterface) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/fc/interfaces/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NetworkingApiService
Retrieves FC ports.&lt;br/&gt; ### Expensive properties There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the &#x60;fields&#x60; query parameter. See [&#x60;DOC Requesting specific fields&#x60;](#docs-docs-Requesting-specific-fields) to learn more. * &#x60;fabric.name&#x60; ### Related ONTAP commands * &#x60;network fcp adapter show&#x60; ### Learn more * [&#x60;DOC /network/fc/ports&#x60;](#docs-networking-network_fc_ports) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *FcPortCollectionGetOpts - Optional Parameters:
     * @param "Name" (optional.String) -  Filter by name
     * @param "Enabled" (optional.Bool) -  Filter by enabled
     * @param "TransceiverManufacturer" (optional.String) -  Filter by transceiver.manufacturer
     * @param "TransceiverCapabilities" (optional.Int32) -  Filter by transceiver.capabilities
     * @param "TransceiverFormFactor" (optional.String) -  Filter by transceiver.form-factor
     * @param "TransceiverPartNumber" (optional.String) -  Filter by transceiver.part_number
     * @param "NodeUuid" (optional.String) -  Filter by node.uuid
     * @param "NodeName" (optional.String) -  Filter by node.name
     * @param "Description" (optional.String) -  Filter by description
     * @param "Uuid" (optional.String) -  Filter by uuid
     * @param "SupportedProtocols" (optional.String) -  Filter by supported_protocols
     * @param "Wwpn" (optional.String) -  Filter by wwpn
     * @param "Wwnn" (optional.String) -  Filter by wwnn
     * @param "PhysicalProtocol" (optional.String) -  Filter by physical_protocol
     * @param "FabricConnected" (optional.Bool) -  Filter by fabric.connected
     * @param "FabricPortAddress" (optional.String) -  Filter by fabric.port_address
     * @param "FabricConnectedSpeed" (optional.Int32) -  Filter by fabric.connected_speed
     * @param "FabricSwitchPort" (optional.String) -  Filter by fabric.switch_port
     * @param "FabricName" (optional.String) -  Filter by fabric.name
     * @param "State" (optional.String) -  Filter by state
     * @param "SpeedConfigured" (optional.String) -  Filter by speed.configured
     * @param "SpeedMaximum" (optional.String) -  Filter by speed.maximum
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return FcPortResponse
*/

type FcPortCollectionGetOpts struct { 
	Name optional.String
	Enabled optional.Bool
	TransceiverManufacturer optional.String
	TransceiverCapabilities optional.Int32
	TransceiverFormFactor optional.String
	TransceiverPartNumber optional.String
	NodeUuid optional.String
	NodeName optional.String
	Description optional.String
	Uuid optional.String
	SupportedProtocols optional.String
	Wwpn optional.String
	Wwnn optional.String
	PhysicalProtocol optional.String
	FabricConnected optional.Bool
	FabricPortAddress optional.String
	FabricConnectedSpeed optional.Int32
	FabricSwitchPort optional.String
	FabricName optional.String
	State optional.String
	SpeedConfigured optional.String
	SpeedMaximum optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NetworkingApiService) FcPortCollectionGet(ctx context.Context, localVarOptionals *FcPortCollectionGetOpts) (FcPortResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FcPortResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/fc/ports"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarQueryParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransceiverManufacturer.IsSet() {
		localVarQueryParams.Add("transceiver.manufacturer", parameterToString(localVarOptionals.TransceiverManufacturer.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransceiverCapabilities.IsSet() {
		localVarQueryParams.Add("transceiver.capabilities", parameterToString(localVarOptionals.TransceiverCapabilities.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransceiverFormFactor.IsSet() {
		localVarQueryParams.Add("transceiver.form-factor", parameterToString(localVarOptionals.TransceiverFormFactor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransceiverPartNumber.IsSet() {
		localVarQueryParams.Add("transceiver.part_number", parameterToString(localVarOptionals.TransceiverPartNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NodeUuid.IsSet() {
		localVarQueryParams.Add("node.uuid", parameterToString(localVarOptionals.NodeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NodeName.IsSet() {
		localVarQueryParams.Add("node.name", parameterToString(localVarOptionals.NodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SupportedProtocols.IsSet() {
		localVarQueryParams.Add("supported_protocols", parameterToString(localVarOptionals.SupportedProtocols.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Wwpn.IsSet() {
		localVarQueryParams.Add("wwpn", parameterToString(localVarOptionals.Wwpn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Wwnn.IsSet() {
		localVarQueryParams.Add("wwnn", parameterToString(localVarOptionals.Wwnn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PhysicalProtocol.IsSet() {
		localVarQueryParams.Add("physical_protocol", parameterToString(localVarOptionals.PhysicalProtocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FabricConnected.IsSet() {
		localVarQueryParams.Add("fabric.connected", parameterToString(localVarOptionals.FabricConnected.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FabricPortAddress.IsSet() {
		localVarQueryParams.Add("fabric.port_address", parameterToString(localVarOptionals.FabricPortAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FabricConnectedSpeed.IsSet() {
		localVarQueryParams.Add("fabric.connected_speed", parameterToString(localVarOptionals.FabricConnectedSpeed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FabricSwitchPort.IsSet() {
		localVarQueryParams.Add("fabric.switch_port", parameterToString(localVarOptionals.FabricSwitchPort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FabricName.IsSet() {
		localVarQueryParams.Add("fabric.name", parameterToString(localVarOptionals.FabricName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpeedConfigured.IsSet() {
		localVarQueryParams.Add("speed.configured", parameterToString(localVarOptionals.SpeedConfigured.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpeedMaximum.IsSet() {
		localVarQueryParams.Add("speed.maximum", parameterToString(localVarOptionals.SpeedMaximum.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FcPortResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NetworkingApiService
Retrieves an FC port. ### Expensive properties There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the &#x60;fields&#x60; query parameter. See [&#x60;DOC Requesting specific fields&#x60;](#docs-docs-Requesting-specific-fields) to learn more. * &#x60;fabric.name&#x60; ### Related ONTAP commands * &#x60;network fcp adapter show&#x60; ### Learn more * [&#x60;DOC /network/fc/ports&#x60;](#docs-networking-network_fc_ports) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid The unique identifier for the FC port. 
 * @param optional nil or *FcPortGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return FcPort
*/

type FcPortGetOpts struct { 
	Fields optional.Interface
}

func (a *NetworkingApiService) FcPortGet(ctx context.Context, uuid string, localVarOptionals *FcPortGetOpts) (FcPort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FcPort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/fc/ports/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FcPort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NetworkingApiService
Updates an FC port. ### Related ONTAP commands * &#x60;network fcp adapter modify&#x60; ### Learn more * [&#x60;DOC /network/fc/ports&#x60;](#docs-networking-network_fc_ports) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid The unique identifier for the FC port. 
 * @param info The new property values for the FC port. 


*/
func (a *NetworkingApiService) FcPortModify(ctx context.Context, uuid string, info FcPort) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/fc/ports/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NetworkingApiService
Deletes an IPspace object. ### Related ONTAP commands * &#x60;network ipspace delete&#x60;  ### Learn more * [&#x60;DOC /network/ipspaces&#x60;](#docs-networking-network_ipspaces)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid IPspace UUID


*/
func (a *NetworkingApiService) IpspaceDelete(ctx context.Context, uuid string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ipspaces/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NetworkingApiService
Retrieves information about a specific IPspace. ### Related ONTAP commands * &#x60;network ipspace show&#x60;  ### Learn more * [&#x60;DOC /network/ipspaces&#x60;](#docs-networking-network_ipspaces)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid IPspace UUID
 * @param optional nil or *IpspaceGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return Ipspace
*/

type IpspaceGetOpts struct { 
	Fields optional.Interface
}

func (a *NetworkingApiService) IpspaceGet(ctx context.Context, uuid string, localVarOptionals *IpspaceGetOpts) (Ipspace, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Ipspace
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ipspaces/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Ipspace
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NetworkingApiService
Updates an IPspace object. ### Related ONTAP commands * &#x60;network ipspace rename&#x60;  ### Learn more * [&#x60;DOC /network/ipspaces&#x60;](#docs-networking-network_ipspaces)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid IPspace UUID
 * @param optional nil or *IpspaceModifyOpts - Optional Parameters:
     * @param "IpspaceInfo" (optional.Interface of Ipspace) - 


*/

type IpspaceModifyOpts struct { 
	IpspaceInfo optional.Interface
}

func (a *NetworkingApiService) IpspaceModify(ctx context.Context, uuid string, localVarOptionals *IpspaceModifyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ipspaces/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.IpspaceInfo.IsSet() {
		
		localVarOptionalIpspaceInfo, localVarOptionalIpspaceInfook := localVarOptionals.IpspaceInfo.Value().(Ipspace)
		if !localVarOptionalIpspaceInfook {
				return nil, reportError("ipspaceInfo should be Ipspace")
		}
		localVarPostBody = &localVarOptionalIpspaceInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NetworkingApiService
Creates a new domain within which IP addresses are unique. SVMs, ports, and networks are scoped within a single IPspace. ### Required properties * &#x60;name&#x60; - Name of the ipspace to create. ### Related ONTAP commands * &#x60;network ipspace create&#x60;  ### Learn more * [&#x60;DOC /network/ipspaces&#x60;](#docs-networking-network_ipspaces)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param ipspace IPspace identifiers


*/
func (a *NetworkingApiService) IpspacesCreate(ctx context.Context, ipspace Ipspace) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ipspaces"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &ipspace
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NetworkingApiService
Retrieves a collection of IPspaces for the entire cluster. ### Related ONTAP commands * &#x60;network ipspace show&#x60;  ### Learn more * [&#x60;DOC /network/ipspaces&#x60;](#docs-networking-network_ipspaces)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *IpspacesGetOpts - Optional Parameters:
     * @param "Name" (optional.String) -  Filter by name
     * @param "Uuid" (optional.String) -  Filter by uuid
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return IpspaceResponse
*/

type IpspacesGetOpts struct { 
	Name optional.String
	Uuid optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NetworkingApiService) IpspacesGet(ctx context.Context, localVarOptionals *IpspacesGetOpts) (IpspaceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue IpspaceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ipspaces"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v IpspaceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NetworkingApiService
Deletes a broadcast domain. ### Related ONTAP commands * &#x60;network port broadcast-domain delete&#x60;  ### Learn more * [&#x60;DOC /network/ethernet/broadcast-domains&#x60;](#docs-networking-network_ethernet_broadcast-domains)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Broadcast domain UUID


*/
func (a *NetworkingApiService) NetworkEthernetBroadcastDomainDelete(ctx context.Context, uuid string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ethernet/broadcast-domains/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NetworkingApiService
Retrieves details of a broadcast domain. ### Related ONTAP commands * &#x60;network port broadcast-domain show&#x60;  ### Learn more * [&#x60;DOC /network/ethernet/broadcast-domains&#x60;](#docs-networking-network_ethernet_broadcast-domains)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Broadcast domain UUID
 * @param optional nil or *NetworkEthernetBroadcastDomainGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return BroadcastDomain
*/

type NetworkEthernetBroadcastDomainGetOpts struct { 
	Fields optional.Interface
}

func (a *NetworkingApiService) NetworkEthernetBroadcastDomainGet(ctx context.Context, uuid string, localVarOptionals *NetworkEthernetBroadcastDomainGetOpts) (BroadcastDomain, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue BroadcastDomain
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ethernet/broadcast-domains/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v BroadcastDomain
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NetworkingApiService
Updates the properties of a broadcast domain. ### Related ONTAP commands * &#x60;network port broadcast-domain modify&#x60; * &#x60;network port broadcast-domain rename&#x60;  ### Learn more * [&#x60;DOC /network/ethernet/broadcast-domains&#x60;](#docs-networking-network_ethernet_broadcast-domains)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Broadcast domain UUID
 * @param optional nil or *NetworkEthernetBroadcastDomainModifyOpts - Optional Parameters:
     * @param "DomainInfo" (optional.Interface of BroadcastDomain) - 


*/

type NetworkEthernetBroadcastDomainModifyOpts struct { 
	DomainInfo optional.Interface
}

func (a *NetworkingApiService) NetworkEthernetBroadcastDomainModify(ctx context.Context, uuid string, localVarOptionals *NetworkEthernetBroadcastDomainModifyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ethernet/broadcast-domains/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.DomainInfo.IsSet() {
		
		localVarOptionalDomainInfo, localVarOptionalDomainInfook := localVarOptionals.DomainInfo.Value().(BroadcastDomain)
		if !localVarOptionalDomainInfook {
				return nil, reportError("domainInfo should be BroadcastDomain")
		}
		localVarPostBody = &localVarOptionalDomainInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NetworkingApiService
Creates a new broadcast domain.&lt;br/&gt; ### Required properties * &#x60;name&#x60; - Name of the broadcast-domain to create. * &#x60;mtu&#x60; - Maximum transmission unit of the broadcast domain. ### Recommended optional properties * &#x60;ipspace.name&#x60; or &#x60;ipspace.uuid&#x60; - IPspace the broadcast domain belongs to. ### Default property values If not specified in POST, the following default property values are assigned: * &#x60;ipspace&#x60; - _Default_ ### Related ONTAP commands * &#x60;network port broadcast-domain create&#x60;  ### Learn more * [&#x60;DOC /network/ethernet/broadcast-domains&#x60;](#docs-networking-network_ethernet_broadcast-domains)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param broadcastDomain Broadcast_domain parameters


*/
func (a *NetworkingApiService) NetworkEthernetBroadcastDomainsCreate(ctx context.Context, broadcastDomain BroadcastDomain) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ethernet/broadcast-domains"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &broadcastDomain
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NetworkingApiService
Retrieves a collection of broadcast domains for the entire cluster. ### Related ONTAP commands * &#x60;network port broadcast-domain show&#x60;  ### Learn more * [&#x60;DOC /network/ethernet/broadcast-domains&#x60;](#docs-networking-network_ethernet_broadcast-domains)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *NetworkEthernetBroadcastDomainsGetOpts - Optional Parameters:
     * @param "IpspaceUuid" (optional.String) -  Filter by ipspace.uuid
     * @param "IpspaceName" (optional.String) -  Filter by ipspace.name
     * @param "Name" (optional.String) -  Filter by name
     * @param "PortsUuid" (optional.String) -  Filter by ports.uuid
     * @param "PortsNodeName" (optional.String) -  Filter by ports.node.name
     * @param "PortsName" (optional.String) -  Filter by ports.name
     * @param "Mtu" (optional.Int32) -  Filter by mtu
     * @param "Uuid" (optional.String) -  Filter by uuid
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return BroadcastDomainResponse
*/

type NetworkEthernetBroadcastDomainsGetOpts struct { 
	IpspaceUuid optional.String
	IpspaceName optional.String
	Name optional.String
	PortsUuid optional.String
	PortsNodeName optional.String
	PortsName optional.String
	Mtu optional.Int32
	Uuid optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NetworkingApiService) NetworkEthernetBroadcastDomainsGet(ctx context.Context, localVarOptionals *NetworkEthernetBroadcastDomainsGetOpts) (BroadcastDomainResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue BroadcastDomainResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ethernet/broadcast-domains"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.IpspaceUuid.IsSet() {
		localVarQueryParams.Add("ipspace.uuid", parameterToString(localVarOptionals.IpspaceUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IpspaceName.IsSet() {
		localVarQueryParams.Add("ipspace.name", parameterToString(localVarOptionals.IpspaceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortsUuid.IsSet() {
		localVarQueryParams.Add("ports.uuid", parameterToString(localVarOptionals.PortsUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortsNodeName.IsSet() {
		localVarQueryParams.Add("ports.node.name", parameterToString(localVarOptionals.PortsNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortsName.IsSet() {
		localVarQueryParams.Add("ports.name", parameterToString(localVarOptionals.PortsName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Mtu.IsSet() {
		localVarQueryParams.Add("mtu", parameterToString(localVarOptionals.Mtu.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v BroadcastDomainResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NetworkingApiService
Deletes a VLAN or LAG (ifgrp). ### Related ONTAP commands * &#x60;network port ifgrp delete&#x60; * &#x60;network port vlan delete&#x60;  ### Learn more * [&#x60;DOC /network/ethernet/ports&#x60;](#docs-networking-network_ethernet_ports)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Port UUID


*/
func (a *NetworkingApiService) NetworkEthernetPortDelete(ctx context.Context, uuid string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ethernet/ports/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NetworkingApiService
Retrieves the details of a physical port, VLAN, or LAG. ### Related ONTAP commands * &#x60;network port show&#x60; * &#x60;network port ifgrp show&#x60; * &#x60;network port vlan show&#x60;  ### Learn more * [&#x60;DOC /network/ethernet/ports&#x60;](#docs-networking-network_ethernet_ports)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Port UUID
 * @param optional nil or *NetworkEthernetPortGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return Port
*/

type NetworkEthernetPortGetOpts struct { 
	Fields optional.Interface
}

func (a *NetworkingApiService) NetworkEthernetPortGet(ctx context.Context, uuid string, localVarOptionals *NetworkEthernetPortGetOpts) (Port, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Port
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ethernet/ports/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Port
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NetworkingApiService
Updates a port. ### Related ONTAP commands * &#x60;network port broadcast-domain add-ports&#x60; * &#x60;network port broadcast-domain remove-ports&#x60; * &#x60;network port ifgrp modify&#x60; * &#x60;network port modify&#x60; * &#x60;network port vlan modify&#x60;  ### Learn more * [&#x60;DOC /network/ethernet/ports&#x60;](#docs-networking-network_ethernet_ports)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Port UUID
 * @param optional nil or *NetworkEthernetPortModifyOpts - Optional Parameters:
     * @param "PortInfo" (optional.Interface of Port) - 


*/

type NetworkEthernetPortModifyOpts struct { 
	PortInfo optional.Interface
}

func (a *NetworkingApiService) NetworkEthernetPortModify(ctx context.Context, uuid string, localVarOptionals *NetworkEthernetPortModifyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ethernet/ports/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.PortInfo.IsSet() {
		
		localVarOptionalPortInfo, localVarOptionalPortInfook := localVarOptionals.PortInfo.Value().(Port)
		if !localVarOptionalPortInfook {
				return nil, reportError("portInfo should be Port")
		}
		localVarPostBody = &localVarOptionalPortInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NetworkingApiService
Creates a new VLAN (such as node1:e0a-100) or LAG (ifgrp, such as node2:a0a). ### Required properties * &#x60;node&#x60; - Node the port will be created on. * &#x60;broadcast_domain&#x60; - Broadcast domain the port is associated with. * &#x60;type&#x60; - Defines if a VLAN or LAG will be created:   * VLAN     * &#x60;vlan.base_port&#x60; - Physical port or LAG the VLAN will be created on.     * &#x60;vlan.tag&#x60; - Tag used to identify VLAN on the base port.   * LAG     * &#x60;lag.mode&#x60; - Policy for the LAG that will be created.     * &#x60;lag.distribution_policy&#x60; - Indicates how the packets are distributed between ports.     * &#x60;lag.member_ports&#x60; - Set of ports the LAG consists of. ### Related ONTAP commands * &#x60;network port ifgrp create&#x60; * &#x60;network port vlan create&#x60;  ### Learn more * [&#x60;DOC /network/ethernet/ports&#x60;](#docs-networking-network_ethernet_ports)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param port Port parameters

@return PortResponse
*/
func (a *NetworkingApiService) NetworkEthernetPortsCreate(ctx context.Context, port Port) (PortResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PortResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ethernet/ports"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &port
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v PortResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NetworkingApiService
Retrieves a collection of ports (physical, VLAN and LAG) for an entire cluster. ### Related ONTAP commands * &#x60;network port show&#x60; * &#x60;network port ifgrp show&#x60; * &#x60;network port vlan show&#x60;  ### Learn more * [&#x60;DOC /network/ethernet/ports&#x60;](#docs-networking-network_ethernet_ports)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *NetworkEthernetPortsGetOpts - Optional Parameters:
     * @param "Uuid" (optional.String) -  Filter by uuid
     * @param "MacAddress" (optional.String) -  Filter by mac_address
     * @param "NodeUuid" (optional.String) -  Filter by node.uuid
     * @param "NodeName" (optional.String) -  Filter by node.name
     * @param "Name" (optional.String) -  Filter by name
     * @param "LagDistributionPolicy" (optional.String) -  Filter by lag.distribution_policy
     * @param "LagActivePortsUuid" (optional.String) -  Filter by lag.active_ports.uuid
     * @param "LagActivePortsNodeName" (optional.String) -  Filter by lag.active_ports.node.name
     * @param "LagActivePortsName" (optional.String) -  Filter by lag.active_ports.name
     * @param "LagMode" (optional.String) -  Filter by lag.mode
     * @param "LagMemberPortsUuid" (optional.String) -  Filter by lag.member_ports.uuid
     * @param "LagMemberPortsNodeName" (optional.String) -  Filter by lag.member_ports.node.name
     * @param "LagMemberPortsName" (optional.String) -  Filter by lag.member_ports.name
     * @param "Enabled" (optional.Bool) -  Filter by enabled
     * @param "Speed" (optional.Int32) -  Filter by speed
     * @param "BroadcastDomainUuid" (optional.String) -  Filter by broadcast_domain.uuid
     * @param "BroadcastDomainIpspaceName" (optional.String) -  Filter by broadcast_domain.ipspace.name
     * @param "BroadcastDomainName" (optional.String) -  Filter by broadcast_domain.name
     * @param "Mtu" (optional.Int32) -  Filter by mtu
     * @param "State" (optional.String) -  Filter by state
     * @param "VlanBasePortUuid" (optional.String) -  Filter by vlan.base_port.uuid
     * @param "VlanBasePortNodeName" (optional.String) -  Filter by vlan.base_port.node.name
     * @param "VlanBasePortName" (optional.String) -  Filter by vlan.base_port.name
     * @param "VlanTag" (optional.Int32) -  Filter by vlan.tag
     * @param "Type_" (optional.String) -  Filter by type
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return PortResponse
*/

type NetworkEthernetPortsGetOpts struct { 
	Uuid optional.String
	MacAddress optional.String
	NodeUuid optional.String
	NodeName optional.String
	Name optional.String
	LagDistributionPolicy optional.String
	LagActivePortsUuid optional.String
	LagActivePortsNodeName optional.String
	LagActivePortsName optional.String
	LagMode optional.String
	LagMemberPortsUuid optional.String
	LagMemberPortsNodeName optional.String
	LagMemberPortsName optional.String
	Enabled optional.Bool
	Speed optional.Int32
	BroadcastDomainUuid optional.String
	BroadcastDomainIpspaceName optional.String
	BroadcastDomainName optional.String
	Mtu optional.Int32
	State optional.String
	VlanBasePortUuid optional.String
	VlanBasePortNodeName optional.String
	VlanBasePortName optional.String
	VlanTag optional.Int32
	Type_ optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NetworkingApiService) NetworkEthernetPortsGet(ctx context.Context, localVarOptionals *NetworkEthernetPortsGetOpts) (PortResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PortResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ethernet/ports"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddress.IsSet() {
		localVarQueryParams.Add("mac_address", parameterToString(localVarOptionals.MacAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NodeUuid.IsSet() {
		localVarQueryParams.Add("node.uuid", parameterToString(localVarOptionals.NodeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NodeName.IsSet() {
		localVarQueryParams.Add("node.name", parameterToString(localVarOptionals.NodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LagDistributionPolicy.IsSet() {
		localVarQueryParams.Add("lag.distribution_policy", parameterToString(localVarOptionals.LagDistributionPolicy.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LagActivePortsUuid.IsSet() {
		localVarQueryParams.Add("lag.active_ports.uuid", parameterToString(localVarOptionals.LagActivePortsUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LagActivePortsNodeName.IsSet() {
		localVarQueryParams.Add("lag.active_ports.node.name", parameterToString(localVarOptionals.LagActivePortsNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LagActivePortsName.IsSet() {
		localVarQueryParams.Add("lag.active_ports.name", parameterToString(localVarOptionals.LagActivePortsName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LagMode.IsSet() {
		localVarQueryParams.Add("lag.mode", parameterToString(localVarOptionals.LagMode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LagMemberPortsUuid.IsSet() {
		localVarQueryParams.Add("lag.member_ports.uuid", parameterToString(localVarOptionals.LagMemberPortsUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LagMemberPortsNodeName.IsSet() {
		localVarQueryParams.Add("lag.member_ports.node.name", parameterToString(localVarOptionals.LagMemberPortsNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LagMemberPortsName.IsSet() {
		localVarQueryParams.Add("lag.member_ports.name", parameterToString(localVarOptionals.LagMemberPortsName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarQueryParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Speed.IsSet() {
		localVarQueryParams.Add("speed", parameterToString(localVarOptionals.Speed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BroadcastDomainUuid.IsSet() {
		localVarQueryParams.Add("broadcast_domain.uuid", parameterToString(localVarOptionals.BroadcastDomainUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BroadcastDomainIpspaceName.IsSet() {
		localVarQueryParams.Add("broadcast_domain.ipspace.name", parameterToString(localVarOptionals.BroadcastDomainIpspaceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BroadcastDomainName.IsSet() {
		localVarQueryParams.Add("broadcast_domain.name", parameterToString(localVarOptionals.BroadcastDomainName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Mtu.IsSet() {
		localVarQueryParams.Add("mtu", parameterToString(localVarOptionals.Mtu.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VlanBasePortUuid.IsSet() {
		localVarQueryParams.Add("vlan.base_port.uuid", parameterToString(localVarOptionals.VlanBasePortUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VlanBasePortNodeName.IsSet() {
		localVarQueryParams.Add("vlan.base_port.node.name", parameterToString(localVarOptionals.VlanBasePortNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VlanBasePortName.IsSet() {
		localVarQueryParams.Add("vlan.base_port.name", parameterToString(localVarOptionals.VlanBasePortName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VlanTag.IsSet() {
		localVarQueryParams.Add("vlan.tag", parameterToString(localVarOptionals.VlanTag.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v PortResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NetworkingApiService
Deletes an IP interface. ### Related ONTAP commands * &#x60;network interface delete&#x60;  ### Learn more * [&#x60;DOC /network/ip/interfaces&#x60;](#docs-networking-network_ip_interfaces)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid IP interface UUID


*/
func (a *NetworkingApiService) NetworkIpInterfaceDelete(ctx context.Context, uuid string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ip/interfaces/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NetworkingApiService
Retrieves details for a specific IP interface. ### Related ONTAP commands * &#x60;network interface show&#x60;  ### Learn more * [&#x60;DOC /network/ip/interfaces&#x60;](#docs-networking-network_ip_interfaces)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid IP interface UUID
 * @param optional nil or *NetworkIpInterfaceGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return IpInterface
*/

type NetworkIpInterfaceGetOpts struct { 
	Fields optional.Interface
}

func (a *NetworkingApiService) NetworkIpInterfaceGet(ctx context.Context, uuid string, localVarOptionals *NetworkIpInterfaceGetOpts) (IpInterface, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue IpInterface
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ip/interfaces/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v IpInterface
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NetworkingApiService
Updates an IP interface. ### Related ONTAP commands * &#x60;network interface migrate&#x60; * &#x60;network interface modify&#x60; * &#x60;network interface rename&#x60; * &#x60;network interface revert&#x60;  ### Learn more * [&#x60;DOC /network/ip/interfaces&#x60;](#docs-networking-network_ip_interfaces)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid IP interface UUID
 * @param optional nil or *NetworkIpInterfaceModifyOpts - Optional Parameters:
     * @param "InterfaceParameters" (optional.Interface of IpInterface) - 


*/

type NetworkIpInterfaceModifyOpts struct { 
	InterfaceParameters optional.Interface
}

func (a *NetworkingApiService) NetworkIpInterfaceModify(ctx context.Context, uuid string, localVarOptionals *NetworkIpInterfaceModifyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ip/interfaces/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.InterfaceParameters.IsSet() {
		
		localVarOptionalInterfaceParameters, localVarOptionalInterfaceParametersok := localVarOptionals.InterfaceParameters.Value().(IpInterface)
		if !localVarOptionalInterfaceParametersok {
				return nil, reportError("interfaceParameters should be IpInterface")
		}
		localVarPostBody = &localVarOptionalInterfaceParameters
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NetworkingApiService
Creates a new cluster-scoped or svm-scoped interface.&lt;br/&gt; ### Required properties * &#x60;name&#x60; - Name of the interface to create. * &#x60;ip.address&#x60; - IP address for the interface. * &#x60;ip.netmask&#x60; - IP subnet of the interface. * &#x60;ipspace.name&#x60; or &#x60;ipspace.uuid&#x60;   * Required for cluster-scoped interfaces.   * Optional for svm-scoped interfaces. * &#x60;svm.name&#x60; or &#x60;svm.uuid&#x60;   * Required for a svm-scoped interface.   * Invalid for a cluster-scoped interface. * &#x60;location.home_port&#x60; or &#x60;location.home_node&#x60; or &#x60;location.broadcast_domain&#x60; - One of these properties must be set to a value to define where the interface will be located. ### Default property values If not specified in POST, the following default property values are assigned: * &#x60;scope&#x60;   * _svm_ if svm parameter is specified.   * _cluster_ if svm parameter is not specified * &#x60;enabled&#x60; - _true_ * &#x60;location.auto_revert&#x60; - _true_ * &#x60;service_policy&#x60;   * _default-data-files_ if scope is &#x60;svm&#x60;   * _default-management_ if scope is &#x60;cluster&#x60; and IPspace is not &#x60;Cluster&#x60;   * _default-cluster_ if scope is &#x60;svm&#x60; and IPspace is &#x60;Cluster&#x60; * &#x60;failover&#x60; - Selects the least restrictive failover policy supported by all the services in the service policy. ### Related ONTAP commands * &#x60;network interface create&#x60;  ### Learn more * [&#x60;DOC /network/ip/interfaces&#x60;](#docs-networking-network_ip_interfaces)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param interface_ IP interface parameters


*/
func (a *NetworkingApiService) NetworkIpInterfacesCreate(ctx context.Context, interface_ IpInterface) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ip/interfaces"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &interface_
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NetworkingApiService
Retrieves the details of all IP interfaces. ### Related ONTAP Commands * &#x60;network interface show&#x60;  ### Learn more * [&#x60;DOC /network/ip/interfaces&#x60;](#docs-networking-network_ip_interfaces)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *NetworkIpInterfacesGetOpts - Optional Parameters:
     * @param "Uuid" (optional.String) -  Filter by uuid
     * @param "Services" (optional.String) -  Filter by services
     * @param "ServicePolicyName" (optional.String) -  Filter by service_policy.name
     * @param "ServicePolicyUuid" (optional.String) -  Filter by service_policy.uuid
     * @param "Scope" (optional.String) -  Filter by scope
     * @param "Enabled" (optional.Bool) -  Filter by enabled
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "Vip" (optional.Bool) -  Filter by vip
     * @param "Name" (optional.String) -  Filter by name
     * @param "State" (optional.String) -  Filter by state
     * @param "IpAddress" (optional.String) -  Filter by ip.address
     * @param "IpNetmask" (optional.String) -  Filter by ip.netmask
     * @param "IpFamily" (optional.String) -  Filter by ip.family
     * @param "IpspaceUuid" (optional.String) -  Filter by ipspace.uuid
     * @param "IpspaceName" (optional.String) -  Filter by ipspace.name
     * @param "LocationAutoRevert" (optional.Bool) -  Filter by location.auto_revert
     * @param "LocationIsHome" (optional.Bool) -  Filter by location.is_home
     * @param "LocationFailover" (optional.String) -  Filter by location.failover
     * @param "LocationPortUuid" (optional.String) -  Filter by location.port.uuid
     * @param "LocationPortNodeName" (optional.String) -  Filter by location.port.node.name
     * @param "LocationPortName" (optional.String) -  Filter by location.port.name
     * @param "LocationNodeUuid" (optional.String) -  Filter by location.node.uuid
     * @param "LocationNodeName" (optional.String) -  Filter by location.node.name
     * @param "LocationHomePortUuid" (optional.String) -  Filter by location.home_port.uuid
     * @param "LocationHomePortNodeName" (optional.String) -  Filter by location.home_port.node.name
     * @param "LocationHomePortName" (optional.String) -  Filter by location.home_port.name
     * @param "LocationHomeNodeUuid" (optional.String) -  Filter by location.home_node.uuid
     * @param "LocationHomeNodeName" (optional.String) -  Filter by location.home_node.name
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return IpInterfaceResponse
*/

type NetworkIpInterfacesGetOpts struct { 
	Uuid optional.String
	Services optional.String
	ServicePolicyName optional.String
	ServicePolicyUuid optional.String
	Scope optional.String
	Enabled optional.Bool
	SvmUuid optional.String
	SvmName optional.String
	Vip optional.Bool
	Name optional.String
	State optional.String
	IpAddress optional.String
	IpNetmask optional.String
	IpFamily optional.String
	IpspaceUuid optional.String
	IpspaceName optional.String
	LocationAutoRevert optional.Bool
	LocationIsHome optional.Bool
	LocationFailover optional.String
	LocationPortUuid optional.String
	LocationPortNodeName optional.String
	LocationPortName optional.String
	LocationNodeUuid optional.String
	LocationNodeName optional.String
	LocationHomePortUuid optional.String
	LocationHomePortNodeName optional.String
	LocationHomePortName optional.String
	LocationHomeNodeUuid optional.String
	LocationHomeNodeName optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NetworkingApiService) NetworkIpInterfacesGet(ctx context.Context, localVarOptionals *NetworkIpInterfacesGetOpts) (IpInterfaceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue IpInterfaceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ip/interfaces"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Services.IsSet() {
		localVarQueryParams.Add("services", parameterToString(localVarOptionals.Services.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServicePolicyName.IsSet() {
		localVarQueryParams.Add("service_policy.name", parameterToString(localVarOptionals.ServicePolicyName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServicePolicyUuid.IsSet() {
		localVarQueryParams.Add("service_policy.uuid", parameterToString(localVarOptionals.ServicePolicyUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Scope.IsSet() {
		localVarQueryParams.Add("scope", parameterToString(localVarOptionals.Scope.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarQueryParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Vip.IsSet() {
		localVarQueryParams.Add("vip", parameterToString(localVarOptionals.Vip.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IpAddress.IsSet() {
		localVarQueryParams.Add("ip.address", parameterToString(localVarOptionals.IpAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IpNetmask.IsSet() {
		localVarQueryParams.Add("ip.netmask", parameterToString(localVarOptionals.IpNetmask.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IpFamily.IsSet() {
		localVarQueryParams.Add("ip.family", parameterToString(localVarOptionals.IpFamily.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IpspaceUuid.IsSet() {
		localVarQueryParams.Add("ipspace.uuid", parameterToString(localVarOptionals.IpspaceUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IpspaceName.IsSet() {
		localVarQueryParams.Add("ipspace.name", parameterToString(localVarOptionals.IpspaceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationAutoRevert.IsSet() {
		localVarQueryParams.Add("location.auto_revert", parameterToString(localVarOptionals.LocationAutoRevert.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationIsHome.IsSet() {
		localVarQueryParams.Add("location.is_home", parameterToString(localVarOptionals.LocationIsHome.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationFailover.IsSet() {
		localVarQueryParams.Add("location.failover", parameterToString(localVarOptionals.LocationFailover.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationPortUuid.IsSet() {
		localVarQueryParams.Add("location.port.uuid", parameterToString(localVarOptionals.LocationPortUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationPortNodeName.IsSet() {
		localVarQueryParams.Add("location.port.node.name", parameterToString(localVarOptionals.LocationPortNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationPortName.IsSet() {
		localVarQueryParams.Add("location.port.name", parameterToString(localVarOptionals.LocationPortName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationNodeUuid.IsSet() {
		localVarQueryParams.Add("location.node.uuid", parameterToString(localVarOptionals.LocationNodeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationNodeName.IsSet() {
		localVarQueryParams.Add("location.node.name", parameterToString(localVarOptionals.LocationNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationHomePortUuid.IsSet() {
		localVarQueryParams.Add("location.home_port.uuid", parameterToString(localVarOptionals.LocationHomePortUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationHomePortNodeName.IsSet() {
		localVarQueryParams.Add("location.home_port.node.name", parameterToString(localVarOptionals.LocationHomePortNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationHomePortName.IsSet() {
		localVarQueryParams.Add("location.home_port.name", parameterToString(localVarOptionals.LocationHomePortName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationHomeNodeUuid.IsSet() {
		localVarQueryParams.Add("location.home_node.uuid", parameterToString(localVarOptionals.LocationHomeNodeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationHomeNodeName.IsSet() {
		localVarQueryParams.Add("location.home_node.name", parameterToString(localVarOptionals.LocationHomeNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v IpInterfaceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NetworkingApiService
Deletes a specific IP route. ### Related ONTAP commands * &#x60;network route delete&#x60;  ### Learn more * [&#x60;DOC /network/ip/routes&#x60;](#docs-networking-network_ip_routes)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Route UUID


*/
func (a *NetworkingApiService) NetworkIpRouteDelete(ctx context.Context, uuid string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ip/routes/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NetworkingApiService
Retrieves the details of a specific IP route. ### Related ONTAP commands * &#x60;network route show&#x60;  ### Learn more * [&#x60;DOC /network/ip/routes&#x60;](#docs-networking-network_ip_routes)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Route UUID
 * @param optional nil or *NetworkIpRouteGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return NetworkRoute
*/

type NetworkIpRouteGetOpts struct { 
	Fields optional.Interface
}

func (a *NetworkingApiService) NetworkIpRouteGet(ctx context.Context, uuid string, localVarOptionals *NetworkIpRouteGetOpts) (NetworkRoute, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NetworkRoute
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ip/routes/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NetworkRoute
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NetworkingApiService
Creates a cluster-scoped or SVM-scoped static route. ### Required properties * &#x60;gateway&#x60; - IP address to route packets to. * SVM-scoped routes   * &#x60;svm.name&#x60; or &#x60;svm.uuid&#x60; - SVM that route is applied to. * cluster-scoped routes   * There are no additional required fields for cluster-scoped routes. ### Default property values If not specified in POST, the following default property values are assigned: * &#x60;destination&#x60; - _0.0.0.0/0_ for IPv4 or _::/0_ for IPv6. * &#x60;ipspace.name&#x60;   * _Default_ for cluster-scoped routes.   * Name of the SVM&#39;s IPspace for SVM-scoped routes. ### Related ONTAP commands * &#x60;network route create&#x60;  ### Learn more * [&#x60;DOC /network/ip/routes&#x60;](#docs-networking-network_ip_routes)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param route Route parameters

@return NetworkRouteResponse
*/
func (a *NetworkingApiService) NetworkIpRoutesCreate(ctx context.Context, route NetworkRoute) (NetworkRouteResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NetworkRouteResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ip/routes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &route
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v NetworkRouteResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NetworkingApiService
Retrieves the collection of IP routes. ### Related ONTAP commands * &#x60;network route show&#x60;  ### Learn more * [&#x60;DOC /network/ip/routes&#x60;](#docs-networking-network_ip_routes)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *NetworkIpRoutesGetOpts - Optional Parameters:
     * @param "IpspaceUuid" (optional.String) -  Filter by ipspace.uuid
     * @param "IpspaceName" (optional.String) -  Filter by ipspace.name
     * @param "Scope" (optional.String) -  Filter by scope
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "DestinationAddress" (optional.String) -  Filter by destination.address
     * @param "DestinationNetmask" (optional.String) -  Filter by destination.netmask
     * @param "DestinationFamily" (optional.String) -  Filter by destination.family
     * @param "Uuid" (optional.String) -  Filter by uuid
     * @param "Gateway" (optional.String) -  Filter by gateway
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return NetworkRouteResponse
*/

type NetworkIpRoutesGetOpts struct { 
	IpspaceUuid optional.String
	IpspaceName optional.String
	Scope optional.String
	SvmUuid optional.String
	SvmName optional.String
	DestinationAddress optional.String
	DestinationNetmask optional.String
	DestinationFamily optional.String
	Uuid optional.String
	Gateway optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NetworkingApiService) NetworkIpRoutesGet(ctx context.Context, localVarOptionals *NetworkIpRoutesGetOpts) (NetworkRouteResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NetworkRouteResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ip/routes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.IpspaceUuid.IsSet() {
		localVarQueryParams.Add("ipspace.uuid", parameterToString(localVarOptionals.IpspaceUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IpspaceName.IsSet() {
		localVarQueryParams.Add("ipspace.name", parameterToString(localVarOptionals.IpspaceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Scope.IsSet() {
		localVarQueryParams.Add("scope", parameterToString(localVarOptionals.Scope.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationAddress.IsSet() {
		localVarQueryParams.Add("destination.address", parameterToString(localVarOptionals.DestinationAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationNetmask.IsSet() {
		localVarQueryParams.Add("destination.netmask", parameterToString(localVarOptionals.DestinationNetmask.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationFamily.IsSet() {
		localVarQueryParams.Add("destination.family", parameterToString(localVarOptionals.DestinationFamily.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Gateway.IsSet() {
		localVarQueryParams.Add("gateway", parameterToString(localVarOptionals.Gateway.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NetworkRouteResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NetworkingApiService
Retrieves a collection of service policies. ### Related ONTAP commands * &#x60;network interface service-policy show&#x60;  ### Learn more * [&#x60;DOC /network/ip/service-policies&#x60;](#docs-networking-network_ip_service-policies)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *NetworkIpServicePoliciesGetOpts - Optional Parameters:
     * @param "Scope" (optional.String) -  Filter by scope
     * @param "IpspaceUuid" (optional.String) -  Filter by ipspace.uuid
     * @param "IpspaceName" (optional.String) -  Filter by ipspace.name
     * @param "Name" (optional.String) -  Filter by name
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "Uuid" (optional.String) -  Filter by uuid
     * @param "Services" (optional.String) -  Filter by services
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return IpServicePolicyResponse
*/

type NetworkIpServicePoliciesGetOpts struct { 
	Scope optional.String
	IpspaceUuid optional.String
	IpspaceName optional.String
	Name optional.String
	SvmUuid optional.String
	SvmName optional.String
	Uuid optional.String
	Services optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NetworkingApiService) NetworkIpServicePoliciesGet(ctx context.Context, localVarOptionals *NetworkIpServicePoliciesGetOpts) (IpServicePolicyResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue IpServicePolicyResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ip/service-policies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Scope.IsSet() {
		localVarQueryParams.Add("scope", parameterToString(localVarOptionals.Scope.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IpspaceUuid.IsSet() {
		localVarQueryParams.Add("ipspace.uuid", parameterToString(localVarOptionals.IpspaceUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IpspaceName.IsSet() {
		localVarQueryParams.Add("ipspace.name", parameterToString(localVarOptionals.IpspaceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Services.IsSet() {
		localVarQueryParams.Add("services", parameterToString(localVarOptionals.Services.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v IpServicePolicyResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NetworkingApiService
Retrieves a specific service policy. ### Related ONTAP commands * &#x60;network interface service-policy show&#x60;  ### Learn more * [&#x60;DOC /network/ip/service-policies&#x60;](#docs-networking-network_ip_service-policies)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Service policy UUID
 * @param optional nil or *NetworkIpServicePolicyGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return IpServicePolicy
*/

type NetworkIpServicePolicyGetOpts struct { 
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NetworkingApiService) NetworkIpServicePolicyGet(ctx context.Context, uuid string, localVarOptionals *NetworkIpServicePolicyGetOpts) (IpServicePolicy, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue IpServicePolicy
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ip/service-policies/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v IpServicePolicy
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
