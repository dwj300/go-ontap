/*
 * ONTAP REST API
 *
 * ONTAP 9.6 adds support for an expansive RESTful API. The documentation below provides information about the types of API calls available to you, as well as details about using each API endpoint. You can learn more about the ONTAP REST API and ONTAP in the ONTAP 9 Documentation Center:  http://docs.netapp.com/ontap-9/topic/com.netapp.doc.dot-rest-api/home.html. NetApp welcomes your comments and suggestions about the ONTAP REST API and the documentation for its use.</br> **Using the ONTAP 9.6 REST API online documentation** Each API method includes usage examples, as well as a model that displays all the required and optional properties supported by the method. Click the _Model_ link, available with each API method, to see all the required and optional properties supported by each method. 
 *
 * API version: v1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package ontap

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// NetworkingApiService NetworkingApi service
type NetworkingApiService service

// FcInterfaceCollectionGetOpts Optional parameters for the method 'FcInterfaceCollectionGet'
type FcInterfaceCollectionGetOpts struct {
    Uuid optional.String
    DataProtocol optional.String
    Name optional.String
    SvmUuid optional.String
    SvmName optional.String
    Comment optional.String
    Enabled optional.Bool
    PortAddress optional.String
    State optional.String
    Wwpn optional.String
    LocationPortName optional.String
    LocationPortNodeName optional.String
    LocationPortUuid optional.String
    LocationNodeUuid optional.String
    LocationNodeName optional.String
    Wwnn optional.String
    Fields optional.Interface
    MaxRecords optional.Int32
    ReturnRecords optional.Bool
    ReturnTimeout optional.Int32
    OrderBy optional.Interface
}

/*
FcInterfaceCollectionGet Method for FcInterfaceCollectionGet
Retrieves FC interfaces. ### Related ONTAP commands * &#x60;network interface show&#x60; * &#x60;vserver fcp interface show&#x60; ### Learn more * [&#x60;DOC /network/fc/interfaces&#x60;](#docs-networking-network_fc_interfaces) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *FcInterfaceCollectionGetOpts - Optional Parameters:
 * @param "Uuid" (optional.String) -  Filter by uuid
 * @param "DataProtocol" (optional.String) -  Filter by data_protocol
 * @param "Name" (optional.String) -  Filter by name
 * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
 * @param "SvmName" (optional.String) -  Filter by svm.name
 * @param "Comment" (optional.String) -  Filter by comment
 * @param "Enabled" (optional.Bool) -  Filter by enabled
 * @param "PortAddress" (optional.String) -  Filter by port_address
 * @param "State" (optional.String) -  Filter by state
 * @param "Wwpn" (optional.String) -  Filter by wwpn
 * @param "LocationPortName" (optional.String) -  Filter by location.port.name
 * @param "LocationPortNodeName" (optional.String) -  Filter by location.port.node.name
 * @param "LocationPortUuid" (optional.String) -  Filter by location.port.uuid
 * @param "LocationNodeUuid" (optional.String) -  Filter by location.node.uuid
 * @param "LocationNodeName" (optional.String) -  Filter by location.node.name
 * @param "Wwnn" (optional.String) -  Filter by wwnn
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return FcInterfaceResponse
*/
func (a *NetworkingApiService) FcInterfaceCollectionGet(ctx _context.Context, localVarOptionals *FcInterfaceCollectionGetOpts) (FcInterfaceResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FcInterfaceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/fc/interfaces"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DataProtocol.IsSet() {
		localVarQueryParams.Add("data_protocol", parameterToString(localVarOptionals.DataProtocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Comment.IsSet() {
		localVarQueryParams.Add("comment", parameterToString(localVarOptionals.Comment.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarQueryParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortAddress.IsSet() {
		localVarQueryParams.Add("port_address", parameterToString(localVarOptionals.PortAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Wwpn.IsSet() {
		localVarQueryParams.Add("wwpn", parameterToString(localVarOptionals.Wwpn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationPortName.IsSet() {
		localVarQueryParams.Add("location.port.name", parameterToString(localVarOptionals.LocationPortName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationPortNodeName.IsSet() {
		localVarQueryParams.Add("location.port.node.name", parameterToString(localVarOptionals.LocationPortNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationPortUuid.IsSet() {
		localVarQueryParams.Add("location.port.uuid", parameterToString(localVarOptionals.LocationPortUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationNodeUuid.IsSet() {
		localVarQueryParams.Add("location.node.uuid", parameterToString(localVarOptionals.LocationNodeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationNodeName.IsSet() {
		localVarQueryParams.Add("location.node.name", parameterToString(localVarOptionals.LocationNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Wwnn.IsSet() {
		localVarQueryParams.Add("wwnn", parameterToString(localVarOptionals.Wwnn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v FcInterfaceResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
FcInterfaceCreate Method for FcInterfaceCreate
Creates an FC interface. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the FC interface. * &#x60;name&#x60; - Name of the FC interface. * &#x60;location.port.uuid&#x60; or both &#x60;location.port.name&#x60; and &#x60;location.port.node.name&#x60; - FC port on which to create the FC interface. * &#x60;data_protocol&#x60; - Data protocol for the FC interface. ### Default property values If not specified in POST, the following default property values are assigned. * &#x60;enabled&#x60; - _true_ ### Related ONTAP commands * &#x60;network interface create&#x60; ### Learn more * [&#x60;DOC /network/fc/interfaces&#x60;](#docs-networking-network_fc_interfaces) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info The property values for the new FC interface. 
@return FcInterfaceResponse
*/
func (a *NetworkingApiService) FcInterfaceCreate(ctx _context.Context, info FcInterface) (FcInterfaceResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FcInterfaceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/fc/interfaces"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 201 {
			var v FcInterfaceResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
FcInterfaceDelete Method for FcInterfaceDelete
Deletes an FC interface. ### Related ONTAP commands * &#x60;network interface delete&#x60; ### Learn more * [&#x60;DOC /network/fc/interfaces&#x60;](#docs-networking-network_fc_interfaces) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid The unique identifier for the FC interface. 
*/
func (a *NetworkingApiService) FcInterfaceDelete(ctx _context.Context, uuid string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/fc/interfaces/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// FcInterfaceGetOpts Optional parameters for the method 'FcInterfaceGet'
type FcInterfaceGetOpts struct {
    Fields optional.Interface
}

/*
FcInterfaceGet Method for FcInterfaceGet
Retrieves a Fibre Channel interface. ### Related ONTAP commands * &#x60;network interface show&#x60; * &#x60;vserver fcp interface show&#x60; ### Learn more * [&#x60;DOC /network/fc/interfaces&#x60;](#docs-networking-network_fc_interfaces) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid The unique identifier for the FC interface. 
 * @param optional nil or *FcInterfaceGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return FcInterface
*/
func (a *NetworkingApiService) FcInterfaceGet(ctx _context.Context, uuid string, localVarOptionals *FcInterfaceGetOpts) (FcInterface, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FcInterface
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/fc/interfaces/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v FcInterface
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
FcInterfaceModify Method for FcInterfaceModify
Updates an FC interface. ### Related ONTAP commands * &#x60;network interface modify&#x60; ### Learn more * [&#x60;DOC /network/fc/interfaces&#x60;](#docs-networking-network_fc_interfaces) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid The unique identifier for the FC interface. 
 * @param info The new property values for the FC interface. 
*/
func (a *NetworkingApiService) FcInterfaceModify(ctx _context.Context, uuid string, info FcInterface) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/fc/interfaces/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// FcPortCollectionGetOpts Optional parameters for the method 'FcPortCollectionGet'
type FcPortCollectionGetOpts struct {
    Name optional.String
    Enabled optional.Bool
    TransceiverManufacturer optional.String
    TransceiverCapabilities optional.Int32
    TransceiverFormFactor optional.String
    TransceiverPartNumber optional.String
    NodeUuid optional.String
    NodeName optional.String
    Description optional.String
    Uuid optional.String
    SupportedProtocols optional.String
    Wwpn optional.String
    Wwnn optional.String
    PhysicalProtocol optional.String
    FabricConnected optional.Bool
    FabricPortAddress optional.String
    FabricConnectedSpeed optional.Int32
    FabricSwitchPort optional.String
    FabricName optional.String
    State optional.String
    SpeedConfigured optional.String
    SpeedMaximum optional.String
    Fields optional.Interface
    MaxRecords optional.Int32
    ReturnRecords optional.Bool
    ReturnTimeout optional.Int32
    OrderBy optional.Interface
}

/*
FcPortCollectionGet Method for FcPortCollectionGet
Retrieves FC ports.&lt;br/&gt; ### Expensive properties There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the &#x60;fields&#x60; query parameter. See [&#x60;DOC Requesting specific fields&#x60;](#docs-docs-Requesting-specific-fields) to learn more. * &#x60;fabric.name&#x60; ### Related ONTAP commands * &#x60;network fcp adapter show&#x60; ### Learn more * [&#x60;DOC /network/fc/ports&#x60;](#docs-networking-network_fc_ports) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *FcPortCollectionGetOpts - Optional Parameters:
 * @param "Name" (optional.String) -  Filter by name
 * @param "Enabled" (optional.Bool) -  Filter by enabled
 * @param "TransceiverManufacturer" (optional.String) -  Filter by transceiver.manufacturer
 * @param "TransceiverCapabilities" (optional.Int32) -  Filter by transceiver.capabilities
 * @param "TransceiverFormFactor" (optional.String) -  Filter by transceiver.form-factor
 * @param "TransceiverPartNumber" (optional.String) -  Filter by transceiver.part_number
 * @param "NodeUuid" (optional.String) -  Filter by node.uuid
 * @param "NodeName" (optional.String) -  Filter by node.name
 * @param "Description" (optional.String) -  Filter by description
 * @param "Uuid" (optional.String) -  Filter by uuid
 * @param "SupportedProtocols" (optional.String) -  Filter by supported_protocols
 * @param "Wwpn" (optional.String) -  Filter by wwpn
 * @param "Wwnn" (optional.String) -  Filter by wwnn
 * @param "PhysicalProtocol" (optional.String) -  Filter by physical_protocol
 * @param "FabricConnected" (optional.Bool) -  Filter by fabric.connected
 * @param "FabricPortAddress" (optional.String) -  Filter by fabric.port_address
 * @param "FabricConnectedSpeed" (optional.Int32) -  Filter by fabric.connected_speed
 * @param "FabricSwitchPort" (optional.String) -  Filter by fabric.switch_port
 * @param "FabricName" (optional.String) -  Filter by fabric.name
 * @param "State" (optional.String) -  Filter by state
 * @param "SpeedConfigured" (optional.String) -  Filter by speed.configured
 * @param "SpeedMaximum" (optional.String) -  Filter by speed.maximum
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return FcPortResponse
*/
func (a *NetworkingApiService) FcPortCollectionGet(ctx _context.Context, localVarOptionals *FcPortCollectionGetOpts) (FcPortResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FcPortResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/fc/ports"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarQueryParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransceiverManufacturer.IsSet() {
		localVarQueryParams.Add("transceiver.manufacturer", parameterToString(localVarOptionals.TransceiverManufacturer.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransceiverCapabilities.IsSet() {
		localVarQueryParams.Add("transceiver.capabilities", parameterToString(localVarOptionals.TransceiverCapabilities.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransceiverFormFactor.IsSet() {
		localVarQueryParams.Add("transceiver.form-factor", parameterToString(localVarOptionals.TransceiverFormFactor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransceiverPartNumber.IsSet() {
		localVarQueryParams.Add("transceiver.part_number", parameterToString(localVarOptionals.TransceiverPartNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NodeUuid.IsSet() {
		localVarQueryParams.Add("node.uuid", parameterToString(localVarOptionals.NodeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NodeName.IsSet() {
		localVarQueryParams.Add("node.name", parameterToString(localVarOptionals.NodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SupportedProtocols.IsSet() {
		localVarQueryParams.Add("supported_protocols", parameterToString(localVarOptionals.SupportedProtocols.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Wwpn.IsSet() {
		localVarQueryParams.Add("wwpn", parameterToString(localVarOptionals.Wwpn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Wwnn.IsSet() {
		localVarQueryParams.Add("wwnn", parameterToString(localVarOptionals.Wwnn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PhysicalProtocol.IsSet() {
		localVarQueryParams.Add("physical_protocol", parameterToString(localVarOptionals.PhysicalProtocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FabricConnected.IsSet() {
		localVarQueryParams.Add("fabric.connected", parameterToString(localVarOptionals.FabricConnected.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FabricPortAddress.IsSet() {
		localVarQueryParams.Add("fabric.port_address", parameterToString(localVarOptionals.FabricPortAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FabricConnectedSpeed.IsSet() {
		localVarQueryParams.Add("fabric.connected_speed", parameterToString(localVarOptionals.FabricConnectedSpeed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FabricSwitchPort.IsSet() {
		localVarQueryParams.Add("fabric.switch_port", parameterToString(localVarOptionals.FabricSwitchPort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FabricName.IsSet() {
		localVarQueryParams.Add("fabric.name", parameterToString(localVarOptionals.FabricName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpeedConfigured.IsSet() {
		localVarQueryParams.Add("speed.configured", parameterToString(localVarOptionals.SpeedConfigured.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpeedMaximum.IsSet() {
		localVarQueryParams.Add("speed.maximum", parameterToString(localVarOptionals.SpeedMaximum.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v FcPortResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// FcPortGetOpts Optional parameters for the method 'FcPortGet'
type FcPortGetOpts struct {
    Fields optional.Interface
}

/*
FcPortGet Method for FcPortGet
Retrieves an FC port. ### Expensive properties There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the &#x60;fields&#x60; query parameter. See [&#x60;DOC Requesting specific fields&#x60;](#docs-docs-Requesting-specific-fields) to learn more. * &#x60;fabric.name&#x60; ### Related ONTAP commands * &#x60;network fcp adapter show&#x60; ### Learn more * [&#x60;DOC /network/fc/ports&#x60;](#docs-networking-network_fc_ports) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid The unique identifier for the FC port. 
 * @param optional nil or *FcPortGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return FcPort
*/
func (a *NetworkingApiService) FcPortGet(ctx _context.Context, uuid string, localVarOptionals *FcPortGetOpts) (FcPort, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FcPort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/fc/ports/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v FcPort
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
FcPortModify Method for FcPortModify
Updates an FC port. ### Related ONTAP commands * &#x60;network fcp adapter modify&#x60; ### Learn more * [&#x60;DOC /network/fc/ports&#x60;](#docs-networking-network_fc_ports) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid The unique identifier for the FC port. 
 * @param info The new property values for the FC port. 
*/
func (a *NetworkingApiService) FcPortModify(ctx _context.Context, uuid string, info FcPort) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/fc/ports/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
IpspaceDelete Method for IpspaceDelete
Deletes an IPspace object. ### Related ONTAP commands * &#x60;network ipspace delete&#x60;  ### Learn more * [&#x60;DOC /network/ipspaces&#x60;](#docs-networking-network_ipspaces)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid IPspace UUID
*/
func (a *NetworkingApiService) IpspaceDelete(ctx _context.Context, uuid string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ipspaces/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// IpspaceGetOpts Optional parameters for the method 'IpspaceGet'
type IpspaceGetOpts struct {
    Fields optional.Interface
}

/*
IpspaceGet Method for IpspaceGet
Retrieves information about a specific IPspace. ### Related ONTAP commands * &#x60;network ipspace show&#x60;  ### Learn more * [&#x60;DOC /network/ipspaces&#x60;](#docs-networking-network_ipspaces)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid IPspace UUID
 * @param optional nil or *IpspaceGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return Ipspace
*/
func (a *NetworkingApiService) IpspaceGet(ctx _context.Context, uuid string, localVarOptionals *IpspaceGetOpts) (Ipspace, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Ipspace
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ipspaces/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Ipspace
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// IpspaceModifyOpts Optional parameters for the method 'IpspaceModify'
type IpspaceModifyOpts struct {
    IpspaceInfo optional.Interface
}

/*
IpspaceModify Method for IpspaceModify
Updates an IPspace object. ### Related ONTAP commands * &#x60;network ipspace rename&#x60;  ### Learn more * [&#x60;DOC /network/ipspaces&#x60;](#docs-networking-network_ipspaces)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid IPspace UUID
 * @param optional nil or *IpspaceModifyOpts - Optional Parameters:
 * @param "IpspaceInfo" (optional.Interface of Ipspace) - 
*/
func (a *NetworkingApiService) IpspaceModify(ctx _context.Context, uuid string, localVarOptionals *IpspaceModifyOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ipspaces/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.IpspaceInfo.IsSet() {
		localVarOptionalIpspaceInfo, localVarOptionalIpspaceInfook := localVarOptionals.IpspaceInfo.Value().(Ipspace)
		if !localVarOptionalIpspaceInfook {
			return nil, reportError("ipspaceInfo should be Ipspace")
		}
		localVarPostBody = &localVarOptionalIpspaceInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
IpspacesCreate Method for IpspacesCreate
Creates a new domain within which IP addresses are unique. SVMs, ports, and networks are scoped within a single IPspace. ### Required properties * &#x60;name&#x60; - Name of the ipspace to create. ### Related ONTAP commands * &#x60;network ipspace create&#x60;  ### Learn more * [&#x60;DOC /network/ipspaces&#x60;](#docs-networking-network_ipspaces)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param ipspace IPspace identifiers
*/
func (a *NetworkingApiService) IpspacesCreate(ctx _context.Context, ipspace Ipspace) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ipspaces"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &ipspace
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// IpspacesGetOpts Optional parameters for the method 'IpspacesGet'
type IpspacesGetOpts struct {
    Name optional.String
    Uuid optional.String
    Fields optional.Interface
    MaxRecords optional.Int32
    ReturnRecords optional.Bool
    ReturnTimeout optional.Int32
    OrderBy optional.Interface
}

/*
IpspacesGet Method for IpspacesGet
Retrieves a collection of IPspaces for the entire cluster. ### Related ONTAP commands * &#x60;network ipspace show&#x60;  ### Learn more * [&#x60;DOC /network/ipspaces&#x60;](#docs-networking-network_ipspaces)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *IpspacesGetOpts - Optional Parameters:
 * @param "Name" (optional.String) -  Filter by name
 * @param "Uuid" (optional.String) -  Filter by uuid
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return IpspaceResponse
*/
func (a *NetworkingApiService) IpspacesGet(ctx _context.Context, localVarOptionals *IpspacesGetOpts) (IpspaceResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IpspaceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ipspaces"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v IpspaceResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
NetworkEthernetBroadcastDomainDelete Method for NetworkEthernetBroadcastDomainDelete
Deletes a broadcast domain. ### Related ONTAP commands * &#x60;network port broadcast-domain delete&#x60;  ### Learn more * [&#x60;DOC /network/ethernet/broadcast-domains&#x60;](#docs-networking-network_ethernet_broadcast-domains)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Broadcast domain UUID
*/
func (a *NetworkingApiService) NetworkEthernetBroadcastDomainDelete(ctx _context.Context, uuid string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ethernet/broadcast-domains/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// NetworkEthernetBroadcastDomainGetOpts Optional parameters for the method 'NetworkEthernetBroadcastDomainGet'
type NetworkEthernetBroadcastDomainGetOpts struct {
    Fields optional.Interface
}

/*
NetworkEthernetBroadcastDomainGet Method for NetworkEthernetBroadcastDomainGet
Retrieves details of a broadcast domain. ### Related ONTAP commands * &#x60;network port broadcast-domain show&#x60;  ### Learn more * [&#x60;DOC /network/ethernet/broadcast-domains&#x60;](#docs-networking-network_ethernet_broadcast-domains)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Broadcast domain UUID
 * @param optional nil or *NetworkEthernetBroadcastDomainGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return BroadcastDomain
*/
func (a *NetworkingApiService) NetworkEthernetBroadcastDomainGet(ctx _context.Context, uuid string, localVarOptionals *NetworkEthernetBroadcastDomainGetOpts) (BroadcastDomain, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BroadcastDomain
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ethernet/broadcast-domains/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v BroadcastDomain
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// NetworkEthernetBroadcastDomainModifyOpts Optional parameters for the method 'NetworkEthernetBroadcastDomainModify'
type NetworkEthernetBroadcastDomainModifyOpts struct {
    DomainInfo optional.Interface
}

/*
NetworkEthernetBroadcastDomainModify Method for NetworkEthernetBroadcastDomainModify
Updates the properties of a broadcast domain. ### Related ONTAP commands * &#x60;network port broadcast-domain modify&#x60; * &#x60;network port broadcast-domain rename&#x60;  ### Learn more * [&#x60;DOC /network/ethernet/broadcast-domains&#x60;](#docs-networking-network_ethernet_broadcast-domains)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Broadcast domain UUID
 * @param optional nil or *NetworkEthernetBroadcastDomainModifyOpts - Optional Parameters:
 * @param "DomainInfo" (optional.Interface of BroadcastDomain) - 
*/
func (a *NetworkingApiService) NetworkEthernetBroadcastDomainModify(ctx _context.Context, uuid string, localVarOptionals *NetworkEthernetBroadcastDomainModifyOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ethernet/broadcast-domains/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.DomainInfo.IsSet() {
		localVarOptionalDomainInfo, localVarOptionalDomainInfook := localVarOptionals.DomainInfo.Value().(BroadcastDomain)
		if !localVarOptionalDomainInfook {
			return nil, reportError("domainInfo should be BroadcastDomain")
		}
		localVarPostBody = &localVarOptionalDomainInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
NetworkEthernetBroadcastDomainsCreate Method for NetworkEthernetBroadcastDomainsCreate
Creates a new broadcast domain.&lt;br/&gt; ### Required properties * &#x60;name&#x60; - Name of the broadcast-domain to create. * &#x60;mtu&#x60; - Maximum transmission unit of the broadcast domain. ### Recommended optional properties * &#x60;ipspace.name&#x60; or &#x60;ipspace.uuid&#x60; - IPspace the broadcast domain belongs to. ### Default property values If not specified in POST, the following default property values are assigned: * &#x60;ipspace&#x60; - _Default_ ### Related ONTAP commands * &#x60;network port broadcast-domain create&#x60;  ### Learn more * [&#x60;DOC /network/ethernet/broadcast-domains&#x60;](#docs-networking-network_ethernet_broadcast-domains)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param broadcastDomain Broadcast_domain parameters
*/
func (a *NetworkingApiService) NetworkEthernetBroadcastDomainsCreate(ctx _context.Context, broadcastDomain BroadcastDomain) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ethernet/broadcast-domains"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &broadcastDomain
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// NetworkEthernetBroadcastDomainsGetOpts Optional parameters for the method 'NetworkEthernetBroadcastDomainsGet'
type NetworkEthernetBroadcastDomainsGetOpts struct {
    IpspaceUuid optional.String
    IpspaceName optional.String
    Name optional.String
    PortsUuid optional.String
    PortsNodeName optional.String
    PortsName optional.String
    Mtu optional.Int32
    Uuid optional.String
    Fields optional.Interface
    MaxRecords optional.Int32
    ReturnRecords optional.Bool
    ReturnTimeout optional.Int32
    OrderBy optional.Interface
}

/*
NetworkEthernetBroadcastDomainsGet Method for NetworkEthernetBroadcastDomainsGet
Retrieves a collection of broadcast domains for the entire cluster. ### Related ONTAP commands * &#x60;network port broadcast-domain show&#x60;  ### Learn more * [&#x60;DOC /network/ethernet/broadcast-domains&#x60;](#docs-networking-network_ethernet_broadcast-domains)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *NetworkEthernetBroadcastDomainsGetOpts - Optional Parameters:
 * @param "IpspaceUuid" (optional.String) -  Filter by ipspace.uuid
 * @param "IpspaceName" (optional.String) -  Filter by ipspace.name
 * @param "Name" (optional.String) -  Filter by name
 * @param "PortsUuid" (optional.String) -  Filter by ports.uuid
 * @param "PortsNodeName" (optional.String) -  Filter by ports.node.name
 * @param "PortsName" (optional.String) -  Filter by ports.name
 * @param "Mtu" (optional.Int32) -  Filter by mtu
 * @param "Uuid" (optional.String) -  Filter by uuid
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return BroadcastDomainResponse
*/
func (a *NetworkingApiService) NetworkEthernetBroadcastDomainsGet(ctx _context.Context, localVarOptionals *NetworkEthernetBroadcastDomainsGetOpts) (BroadcastDomainResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BroadcastDomainResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ethernet/broadcast-domains"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IpspaceUuid.IsSet() {
		localVarQueryParams.Add("ipspace.uuid", parameterToString(localVarOptionals.IpspaceUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IpspaceName.IsSet() {
		localVarQueryParams.Add("ipspace.name", parameterToString(localVarOptionals.IpspaceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortsUuid.IsSet() {
		localVarQueryParams.Add("ports.uuid", parameterToString(localVarOptionals.PortsUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortsNodeName.IsSet() {
		localVarQueryParams.Add("ports.node.name", parameterToString(localVarOptionals.PortsNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortsName.IsSet() {
		localVarQueryParams.Add("ports.name", parameterToString(localVarOptionals.PortsName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Mtu.IsSet() {
		localVarQueryParams.Add("mtu", parameterToString(localVarOptionals.Mtu.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v BroadcastDomainResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
NetworkEthernetPortDelete Method for NetworkEthernetPortDelete
Deletes a VLAN or LAG (ifgrp). ### Related ONTAP commands * &#x60;network port ifgrp delete&#x60; * &#x60;network port vlan delete&#x60;  ### Learn more * [&#x60;DOC /network/ethernet/ports&#x60;](#docs-networking-network_ethernet_ports)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Port UUID
*/
func (a *NetworkingApiService) NetworkEthernetPortDelete(ctx _context.Context, uuid string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ethernet/ports/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// NetworkEthernetPortGetOpts Optional parameters for the method 'NetworkEthernetPortGet'
type NetworkEthernetPortGetOpts struct {
    Fields optional.Interface
}

/*
NetworkEthernetPortGet Method for NetworkEthernetPortGet
Retrieves the details of a physical port, VLAN, or LAG. ### Related ONTAP commands * &#x60;network port show&#x60; * &#x60;network port ifgrp show&#x60; * &#x60;network port vlan show&#x60;  ### Learn more * [&#x60;DOC /network/ethernet/ports&#x60;](#docs-networking-network_ethernet_ports)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Port UUID
 * @param optional nil or *NetworkEthernetPortGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return Port
*/
func (a *NetworkingApiService) NetworkEthernetPortGet(ctx _context.Context, uuid string, localVarOptionals *NetworkEthernetPortGetOpts) (Port, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Port
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ethernet/ports/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Port
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// NetworkEthernetPortModifyOpts Optional parameters for the method 'NetworkEthernetPortModify'
type NetworkEthernetPortModifyOpts struct {
    PortInfo optional.Interface
}

/*
NetworkEthernetPortModify Method for NetworkEthernetPortModify
Updates a port. ### Related ONTAP commands * &#x60;network port broadcast-domain add-ports&#x60; * &#x60;network port broadcast-domain remove-ports&#x60; * &#x60;network port ifgrp modify&#x60; * &#x60;network port modify&#x60; * &#x60;network port vlan modify&#x60;  ### Learn more * [&#x60;DOC /network/ethernet/ports&#x60;](#docs-networking-network_ethernet_ports)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Port UUID
 * @param optional nil or *NetworkEthernetPortModifyOpts - Optional Parameters:
 * @param "PortInfo" (optional.Interface of Port) - 
*/
func (a *NetworkingApiService) NetworkEthernetPortModify(ctx _context.Context, uuid string, localVarOptionals *NetworkEthernetPortModifyOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ethernet/ports/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.PortInfo.IsSet() {
		localVarOptionalPortInfo, localVarOptionalPortInfook := localVarOptionals.PortInfo.Value().(Port)
		if !localVarOptionalPortInfook {
			return nil, reportError("portInfo should be Port")
		}
		localVarPostBody = &localVarOptionalPortInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
NetworkEthernetPortsCreate Method for NetworkEthernetPortsCreate
Creates a new VLAN (such as node1:e0a-100) or LAG (ifgrp, such as node2:a0a). ### Required properties * &#x60;node&#x60; - Node the port will be created on. * &#x60;broadcast_domain&#x60; - Broadcast domain the port is associated with. * &#x60;type&#x60; - Defines if a VLAN or LAG will be created:   * VLAN     * &#x60;vlan.base_port&#x60; - Physical port or LAG the VLAN will be created on.     * &#x60;vlan.tag&#x60; - Tag used to identify VLAN on the base port.   * LAG     * &#x60;lag.mode&#x60; - Policy for the LAG that will be created.     * &#x60;lag.distribution_policy&#x60; - Indicates how the packets are distributed between ports.     * &#x60;lag.member_ports&#x60; - Set of ports the LAG consists of. ### Related ONTAP commands * &#x60;network port ifgrp create&#x60; * &#x60;network port vlan create&#x60;  ### Learn more * [&#x60;DOC /network/ethernet/ports&#x60;](#docs-networking-network_ethernet_ports)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param port Port parameters
@return PortResponse
*/
func (a *NetworkingApiService) NetworkEthernetPortsCreate(ctx _context.Context, port Port) (PortResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PortResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ethernet/ports"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &port
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 201 {
			var v PortResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// NetworkEthernetPortsGetOpts Optional parameters for the method 'NetworkEthernetPortsGet'
type NetworkEthernetPortsGetOpts struct {
    Uuid optional.String
    MacAddress optional.String
    NodeUuid optional.String
    NodeName optional.String
    Name optional.String
    LagDistributionPolicy optional.String
    LagActivePortsUuid optional.String
    LagActivePortsNodeName optional.String
    LagActivePortsName optional.String
    LagMode optional.String
    LagMemberPortsUuid optional.String
    LagMemberPortsNodeName optional.String
    LagMemberPortsName optional.String
    Enabled optional.Bool
    Speed optional.Int32
    BroadcastDomainUuid optional.String
    BroadcastDomainIpspaceName optional.String
    BroadcastDomainName optional.String
    Mtu optional.Int32
    State optional.String
    VlanBasePortUuid optional.String
    VlanBasePortNodeName optional.String
    VlanBasePortName optional.String
    VlanTag optional.Int32
    Type_ optional.String
    Fields optional.Interface
    MaxRecords optional.Int32
    ReturnRecords optional.Bool
    ReturnTimeout optional.Int32
    OrderBy optional.Interface
}

/*
NetworkEthernetPortsGet Method for NetworkEthernetPortsGet
Retrieves a collection of ports (physical, VLAN and LAG) for an entire cluster. ### Related ONTAP commands * &#x60;network port show&#x60; * &#x60;network port ifgrp show&#x60; * &#x60;network port vlan show&#x60;  ### Learn more * [&#x60;DOC /network/ethernet/ports&#x60;](#docs-networking-network_ethernet_ports)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *NetworkEthernetPortsGetOpts - Optional Parameters:
 * @param "Uuid" (optional.String) -  Filter by uuid
 * @param "MacAddress" (optional.String) -  Filter by mac_address
 * @param "NodeUuid" (optional.String) -  Filter by node.uuid
 * @param "NodeName" (optional.String) -  Filter by node.name
 * @param "Name" (optional.String) -  Filter by name
 * @param "LagDistributionPolicy" (optional.String) -  Filter by lag.distribution_policy
 * @param "LagActivePortsUuid" (optional.String) -  Filter by lag.active_ports.uuid
 * @param "LagActivePortsNodeName" (optional.String) -  Filter by lag.active_ports.node.name
 * @param "LagActivePortsName" (optional.String) -  Filter by lag.active_ports.name
 * @param "LagMode" (optional.String) -  Filter by lag.mode
 * @param "LagMemberPortsUuid" (optional.String) -  Filter by lag.member_ports.uuid
 * @param "LagMemberPortsNodeName" (optional.String) -  Filter by lag.member_ports.node.name
 * @param "LagMemberPortsName" (optional.String) -  Filter by lag.member_ports.name
 * @param "Enabled" (optional.Bool) -  Filter by enabled
 * @param "Speed" (optional.Int32) -  Filter by speed
 * @param "BroadcastDomainUuid" (optional.String) -  Filter by broadcast_domain.uuid
 * @param "BroadcastDomainIpspaceName" (optional.String) -  Filter by broadcast_domain.ipspace.name
 * @param "BroadcastDomainName" (optional.String) -  Filter by broadcast_domain.name
 * @param "Mtu" (optional.Int32) -  Filter by mtu
 * @param "State" (optional.String) -  Filter by state
 * @param "VlanBasePortUuid" (optional.String) -  Filter by vlan.base_port.uuid
 * @param "VlanBasePortNodeName" (optional.String) -  Filter by vlan.base_port.node.name
 * @param "VlanBasePortName" (optional.String) -  Filter by vlan.base_port.name
 * @param "VlanTag" (optional.Int32) -  Filter by vlan.tag
 * @param "Type_" (optional.String) -  Filter by type
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return PortResponse
*/
func (a *NetworkingApiService) NetworkEthernetPortsGet(ctx _context.Context, localVarOptionals *NetworkEthernetPortsGetOpts) (PortResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PortResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ethernet/ports"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddress.IsSet() {
		localVarQueryParams.Add("mac_address", parameterToString(localVarOptionals.MacAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NodeUuid.IsSet() {
		localVarQueryParams.Add("node.uuid", parameterToString(localVarOptionals.NodeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NodeName.IsSet() {
		localVarQueryParams.Add("node.name", parameterToString(localVarOptionals.NodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LagDistributionPolicy.IsSet() {
		localVarQueryParams.Add("lag.distribution_policy", parameterToString(localVarOptionals.LagDistributionPolicy.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LagActivePortsUuid.IsSet() {
		localVarQueryParams.Add("lag.active_ports.uuid", parameterToString(localVarOptionals.LagActivePortsUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LagActivePortsNodeName.IsSet() {
		localVarQueryParams.Add("lag.active_ports.node.name", parameterToString(localVarOptionals.LagActivePortsNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LagActivePortsName.IsSet() {
		localVarQueryParams.Add("lag.active_ports.name", parameterToString(localVarOptionals.LagActivePortsName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LagMode.IsSet() {
		localVarQueryParams.Add("lag.mode", parameterToString(localVarOptionals.LagMode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LagMemberPortsUuid.IsSet() {
		localVarQueryParams.Add("lag.member_ports.uuid", parameterToString(localVarOptionals.LagMemberPortsUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LagMemberPortsNodeName.IsSet() {
		localVarQueryParams.Add("lag.member_ports.node.name", parameterToString(localVarOptionals.LagMemberPortsNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LagMemberPortsName.IsSet() {
		localVarQueryParams.Add("lag.member_ports.name", parameterToString(localVarOptionals.LagMemberPortsName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarQueryParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Speed.IsSet() {
		localVarQueryParams.Add("speed", parameterToString(localVarOptionals.Speed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BroadcastDomainUuid.IsSet() {
		localVarQueryParams.Add("broadcast_domain.uuid", parameterToString(localVarOptionals.BroadcastDomainUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BroadcastDomainIpspaceName.IsSet() {
		localVarQueryParams.Add("broadcast_domain.ipspace.name", parameterToString(localVarOptionals.BroadcastDomainIpspaceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BroadcastDomainName.IsSet() {
		localVarQueryParams.Add("broadcast_domain.name", parameterToString(localVarOptionals.BroadcastDomainName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Mtu.IsSet() {
		localVarQueryParams.Add("mtu", parameterToString(localVarOptionals.Mtu.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VlanBasePortUuid.IsSet() {
		localVarQueryParams.Add("vlan.base_port.uuid", parameterToString(localVarOptionals.VlanBasePortUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VlanBasePortNodeName.IsSet() {
		localVarQueryParams.Add("vlan.base_port.node.name", parameterToString(localVarOptionals.VlanBasePortNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VlanBasePortName.IsSet() {
		localVarQueryParams.Add("vlan.base_port.name", parameterToString(localVarOptionals.VlanBasePortName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VlanTag.IsSet() {
		localVarQueryParams.Add("vlan.tag", parameterToString(localVarOptionals.VlanTag.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v PortResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
NetworkIpInterfaceDelete Method for NetworkIpInterfaceDelete
Deletes an IP interface. ### Related ONTAP commands * &#x60;network interface delete&#x60;  ### Learn more * [&#x60;DOC /network/ip/interfaces&#x60;](#docs-networking-network_ip_interfaces)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid IP interface UUID
*/
func (a *NetworkingApiService) NetworkIpInterfaceDelete(ctx _context.Context, uuid string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ip/interfaces/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// NetworkIpInterfaceGetOpts Optional parameters for the method 'NetworkIpInterfaceGet'
type NetworkIpInterfaceGetOpts struct {
    Fields optional.Interface
}

/*
NetworkIpInterfaceGet Method for NetworkIpInterfaceGet
Retrieves details for a specific IP interface. ### Related ONTAP commands * &#x60;network interface show&#x60;  ### Learn more * [&#x60;DOC /network/ip/interfaces&#x60;](#docs-networking-network_ip_interfaces)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid IP interface UUID
 * @param optional nil or *NetworkIpInterfaceGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return IpInterface
*/
func (a *NetworkingApiService) NetworkIpInterfaceGet(ctx _context.Context, uuid string, localVarOptionals *NetworkIpInterfaceGetOpts) (IpInterface, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IpInterface
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ip/interfaces/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v IpInterface
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// NetworkIpInterfaceModifyOpts Optional parameters for the method 'NetworkIpInterfaceModify'
type NetworkIpInterfaceModifyOpts struct {
    InterfaceParameters optional.Interface
}

/*
NetworkIpInterfaceModify Method for NetworkIpInterfaceModify
Updates an IP interface. ### Related ONTAP commands * &#x60;network interface migrate&#x60; * &#x60;network interface modify&#x60; * &#x60;network interface rename&#x60; * &#x60;network interface revert&#x60;  ### Learn more * [&#x60;DOC /network/ip/interfaces&#x60;](#docs-networking-network_ip_interfaces)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid IP interface UUID
 * @param optional nil or *NetworkIpInterfaceModifyOpts - Optional Parameters:
 * @param "InterfaceParameters" (optional.Interface of IpInterface) - 
*/
func (a *NetworkingApiService) NetworkIpInterfaceModify(ctx _context.Context, uuid string, localVarOptionals *NetworkIpInterfaceModifyOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ip/interfaces/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.InterfaceParameters.IsSet() {
		localVarOptionalInterfaceParameters, localVarOptionalInterfaceParametersok := localVarOptionals.InterfaceParameters.Value().(IpInterface)
		if !localVarOptionalInterfaceParametersok {
			return nil, reportError("interfaceParameters should be IpInterface")
		}
		localVarPostBody = &localVarOptionalInterfaceParameters
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
NetworkIpInterfacesCreate Method for NetworkIpInterfacesCreate
Creates a new cluster-scoped or svm-scoped interface.&lt;br/&gt; ### Required properties * &#x60;name&#x60; - Name of the interface to create. * &#x60;ip.address&#x60; - IP address for the interface. * &#x60;ip.netmask&#x60; - IP subnet of the interface. * &#x60;ipspace.name&#x60; or &#x60;ipspace.uuid&#x60;   * Required for cluster-scoped interfaces.   * Optional for svm-scoped interfaces. * &#x60;svm.name&#x60; or &#x60;svm.uuid&#x60;   * Required for a svm-scoped interface.   * Invalid for a cluster-scoped interface. * &#x60;location.home_port&#x60; or &#x60;location.home_node&#x60; or &#x60;location.broadcast_domain&#x60; - One of these properties must be set to a value to define where the interface will be located. ### Default property values If not specified in POST, the following default property values are assigned: * &#x60;scope&#x60;   * _svm_ if svm parameter is specified.   * _cluster_ if svm parameter is not specified * &#x60;enabled&#x60; - _true_ * &#x60;location.auto_revert&#x60; - _true_ * &#x60;service_policy&#x60;   * _default-data-files_ if scope is &#x60;svm&#x60;   * _default-management_ if scope is &#x60;cluster&#x60; and IPspace is not &#x60;Cluster&#x60;   * _default-cluster_ if scope is &#x60;svm&#x60; and IPspace is &#x60;Cluster&#x60; * &#x60;failover&#x60; - Selects the least restrictive failover policy supported by all the services in the service policy. ### Related ONTAP commands * &#x60;network interface create&#x60;  ### Learn more * [&#x60;DOC /network/ip/interfaces&#x60;](#docs-networking-network_ip_interfaces)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param interface_ IP interface parameters
*/
func (a *NetworkingApiService) NetworkIpInterfacesCreate(ctx _context.Context, interface_ IpInterface) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ip/interfaces"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &interface_
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// NetworkIpInterfacesGetOpts Optional parameters for the method 'NetworkIpInterfacesGet'
type NetworkIpInterfacesGetOpts struct {
    Uuid optional.String
    Services optional.String
    ServicePolicyName optional.String
    ServicePolicyUuid optional.String
    Scope optional.String
    Enabled optional.Bool
    SvmUuid optional.String
    SvmName optional.String
    Vip optional.Bool
    Name optional.String
    State optional.String
    IpAddress optional.String
    IpNetmask optional.String
    IpFamily optional.String
    IpspaceUuid optional.String
    IpspaceName optional.String
    LocationAutoRevert optional.Bool
    LocationIsHome optional.Bool
    LocationFailover optional.String
    LocationPortUuid optional.String
    LocationPortNodeName optional.String
    LocationPortName optional.String
    LocationNodeUuid optional.String
    LocationNodeName optional.String
    LocationHomePortUuid optional.String
    LocationHomePortNodeName optional.String
    LocationHomePortName optional.String
    LocationHomeNodeUuid optional.String
    LocationHomeNodeName optional.String
    Fields optional.Interface
    MaxRecords optional.Int32
    ReturnRecords optional.Bool
    ReturnTimeout optional.Int32
    OrderBy optional.Interface
}

/*
NetworkIpInterfacesGet Method for NetworkIpInterfacesGet
Retrieves the details of all IP interfaces. ### Related ONTAP Commands * &#x60;network interface show&#x60;  ### Learn more * [&#x60;DOC /network/ip/interfaces&#x60;](#docs-networking-network_ip_interfaces)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *NetworkIpInterfacesGetOpts - Optional Parameters:
 * @param "Uuid" (optional.String) -  Filter by uuid
 * @param "Services" (optional.String) -  Filter by services
 * @param "ServicePolicyName" (optional.String) -  Filter by service_policy.name
 * @param "ServicePolicyUuid" (optional.String) -  Filter by service_policy.uuid
 * @param "Scope" (optional.String) -  Filter by scope
 * @param "Enabled" (optional.Bool) -  Filter by enabled
 * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
 * @param "SvmName" (optional.String) -  Filter by svm.name
 * @param "Vip" (optional.Bool) -  Filter by vip
 * @param "Name" (optional.String) -  Filter by name
 * @param "State" (optional.String) -  Filter by state
 * @param "IpAddress" (optional.String) -  Filter by ip.address
 * @param "IpNetmask" (optional.String) -  Filter by ip.netmask
 * @param "IpFamily" (optional.String) -  Filter by ip.family
 * @param "IpspaceUuid" (optional.String) -  Filter by ipspace.uuid
 * @param "IpspaceName" (optional.String) -  Filter by ipspace.name
 * @param "LocationAutoRevert" (optional.Bool) -  Filter by location.auto_revert
 * @param "LocationIsHome" (optional.Bool) -  Filter by location.is_home
 * @param "LocationFailover" (optional.String) -  Filter by location.failover
 * @param "LocationPortUuid" (optional.String) -  Filter by location.port.uuid
 * @param "LocationPortNodeName" (optional.String) -  Filter by location.port.node.name
 * @param "LocationPortName" (optional.String) -  Filter by location.port.name
 * @param "LocationNodeUuid" (optional.String) -  Filter by location.node.uuid
 * @param "LocationNodeName" (optional.String) -  Filter by location.node.name
 * @param "LocationHomePortUuid" (optional.String) -  Filter by location.home_port.uuid
 * @param "LocationHomePortNodeName" (optional.String) -  Filter by location.home_port.node.name
 * @param "LocationHomePortName" (optional.String) -  Filter by location.home_port.name
 * @param "LocationHomeNodeUuid" (optional.String) -  Filter by location.home_node.uuid
 * @param "LocationHomeNodeName" (optional.String) -  Filter by location.home_node.name
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return IpInterfaceResponse
*/
func (a *NetworkingApiService) NetworkIpInterfacesGet(ctx _context.Context, localVarOptionals *NetworkIpInterfacesGetOpts) (IpInterfaceResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IpInterfaceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ip/interfaces"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Services.IsSet() {
		localVarQueryParams.Add("services", parameterToString(localVarOptionals.Services.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServicePolicyName.IsSet() {
		localVarQueryParams.Add("service_policy.name", parameterToString(localVarOptionals.ServicePolicyName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServicePolicyUuid.IsSet() {
		localVarQueryParams.Add("service_policy.uuid", parameterToString(localVarOptionals.ServicePolicyUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Scope.IsSet() {
		localVarQueryParams.Add("scope", parameterToString(localVarOptionals.Scope.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarQueryParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Vip.IsSet() {
		localVarQueryParams.Add("vip", parameterToString(localVarOptionals.Vip.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IpAddress.IsSet() {
		localVarQueryParams.Add("ip.address", parameterToString(localVarOptionals.IpAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IpNetmask.IsSet() {
		localVarQueryParams.Add("ip.netmask", parameterToString(localVarOptionals.IpNetmask.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IpFamily.IsSet() {
		localVarQueryParams.Add("ip.family", parameterToString(localVarOptionals.IpFamily.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IpspaceUuid.IsSet() {
		localVarQueryParams.Add("ipspace.uuid", parameterToString(localVarOptionals.IpspaceUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IpspaceName.IsSet() {
		localVarQueryParams.Add("ipspace.name", parameterToString(localVarOptionals.IpspaceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationAutoRevert.IsSet() {
		localVarQueryParams.Add("location.auto_revert", parameterToString(localVarOptionals.LocationAutoRevert.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationIsHome.IsSet() {
		localVarQueryParams.Add("location.is_home", parameterToString(localVarOptionals.LocationIsHome.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationFailover.IsSet() {
		localVarQueryParams.Add("location.failover", parameterToString(localVarOptionals.LocationFailover.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationPortUuid.IsSet() {
		localVarQueryParams.Add("location.port.uuid", parameterToString(localVarOptionals.LocationPortUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationPortNodeName.IsSet() {
		localVarQueryParams.Add("location.port.node.name", parameterToString(localVarOptionals.LocationPortNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationPortName.IsSet() {
		localVarQueryParams.Add("location.port.name", parameterToString(localVarOptionals.LocationPortName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationNodeUuid.IsSet() {
		localVarQueryParams.Add("location.node.uuid", parameterToString(localVarOptionals.LocationNodeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationNodeName.IsSet() {
		localVarQueryParams.Add("location.node.name", parameterToString(localVarOptionals.LocationNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationHomePortUuid.IsSet() {
		localVarQueryParams.Add("location.home_port.uuid", parameterToString(localVarOptionals.LocationHomePortUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationHomePortNodeName.IsSet() {
		localVarQueryParams.Add("location.home_port.node.name", parameterToString(localVarOptionals.LocationHomePortNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationHomePortName.IsSet() {
		localVarQueryParams.Add("location.home_port.name", parameterToString(localVarOptionals.LocationHomePortName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationHomeNodeUuid.IsSet() {
		localVarQueryParams.Add("location.home_node.uuid", parameterToString(localVarOptionals.LocationHomeNodeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationHomeNodeName.IsSet() {
		localVarQueryParams.Add("location.home_node.name", parameterToString(localVarOptionals.LocationHomeNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v IpInterfaceResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
NetworkIpRouteDelete Method for NetworkIpRouteDelete
Deletes a specific IP route. ### Related ONTAP commands * &#x60;network route delete&#x60;  ### Learn more * [&#x60;DOC /network/ip/routes&#x60;](#docs-networking-network_ip_routes)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Route UUID
*/
func (a *NetworkingApiService) NetworkIpRouteDelete(ctx _context.Context, uuid string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ip/routes/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// NetworkIpRouteGetOpts Optional parameters for the method 'NetworkIpRouteGet'
type NetworkIpRouteGetOpts struct {
    Fields optional.Interface
}

/*
NetworkIpRouteGet Method for NetworkIpRouteGet
Retrieves the details of a specific IP route. ### Related ONTAP commands * &#x60;network route show&#x60;  ### Learn more * [&#x60;DOC /network/ip/routes&#x60;](#docs-networking-network_ip_routes)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Route UUID
 * @param optional nil or *NetworkIpRouteGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return NetworkRoute
*/
func (a *NetworkingApiService) NetworkIpRouteGet(ctx _context.Context, uuid string, localVarOptionals *NetworkIpRouteGetOpts) (NetworkRoute, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NetworkRoute
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ip/routes/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v NetworkRoute
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
NetworkIpRoutesCreate Method for NetworkIpRoutesCreate
Creates a cluster-scoped or SVM-scoped static route. ### Required properties * &#x60;gateway&#x60; - IP address to route packets to. * SVM-scoped routes   * &#x60;svm.name&#x60; or &#x60;svm.uuid&#x60; - SVM that route is applied to. * cluster-scoped routes   * There are no additional required fields for cluster-scoped routes. ### Default property values If not specified in POST, the following default property values are assigned: * &#x60;destination&#x60; - _0.0.0.0/0_ for IPv4 or _::/0_ for IPv6. * &#x60;ipspace.name&#x60;   * _Default_ for cluster-scoped routes.   * Name of the SVM&#39;s IPspace for SVM-scoped routes. ### Related ONTAP commands * &#x60;network route create&#x60;  ### Learn more * [&#x60;DOC /network/ip/routes&#x60;](#docs-networking-network_ip_routes)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param route Route parameters
@return NetworkRouteResponse
*/
func (a *NetworkingApiService) NetworkIpRoutesCreate(ctx _context.Context, route NetworkRoute) (NetworkRouteResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NetworkRouteResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ip/routes"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &route
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 201 {
			var v NetworkRouteResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// NetworkIpRoutesGetOpts Optional parameters for the method 'NetworkIpRoutesGet'
type NetworkIpRoutesGetOpts struct {
    IpspaceUuid optional.String
    IpspaceName optional.String
    Scope optional.String
    SvmUuid optional.String
    SvmName optional.String
    DestinationAddress optional.String
    DestinationNetmask optional.String
    DestinationFamily optional.String
    Uuid optional.String
    Gateway optional.String
    Fields optional.Interface
    MaxRecords optional.Int32
    ReturnRecords optional.Bool
    ReturnTimeout optional.Int32
    OrderBy optional.Interface
}

/*
NetworkIpRoutesGet Method for NetworkIpRoutesGet
Retrieves the collection of IP routes. ### Related ONTAP commands * &#x60;network route show&#x60;  ### Learn more * [&#x60;DOC /network/ip/routes&#x60;](#docs-networking-network_ip_routes)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *NetworkIpRoutesGetOpts - Optional Parameters:
 * @param "IpspaceUuid" (optional.String) -  Filter by ipspace.uuid
 * @param "IpspaceName" (optional.String) -  Filter by ipspace.name
 * @param "Scope" (optional.String) -  Filter by scope
 * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
 * @param "SvmName" (optional.String) -  Filter by svm.name
 * @param "DestinationAddress" (optional.String) -  Filter by destination.address
 * @param "DestinationNetmask" (optional.String) -  Filter by destination.netmask
 * @param "DestinationFamily" (optional.String) -  Filter by destination.family
 * @param "Uuid" (optional.String) -  Filter by uuid
 * @param "Gateway" (optional.String) -  Filter by gateway
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return NetworkRouteResponse
*/
func (a *NetworkingApiService) NetworkIpRoutesGet(ctx _context.Context, localVarOptionals *NetworkIpRoutesGetOpts) (NetworkRouteResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NetworkRouteResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ip/routes"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IpspaceUuid.IsSet() {
		localVarQueryParams.Add("ipspace.uuid", parameterToString(localVarOptionals.IpspaceUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IpspaceName.IsSet() {
		localVarQueryParams.Add("ipspace.name", parameterToString(localVarOptionals.IpspaceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Scope.IsSet() {
		localVarQueryParams.Add("scope", parameterToString(localVarOptionals.Scope.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationAddress.IsSet() {
		localVarQueryParams.Add("destination.address", parameterToString(localVarOptionals.DestinationAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationNetmask.IsSet() {
		localVarQueryParams.Add("destination.netmask", parameterToString(localVarOptionals.DestinationNetmask.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationFamily.IsSet() {
		localVarQueryParams.Add("destination.family", parameterToString(localVarOptionals.DestinationFamily.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Gateway.IsSet() {
		localVarQueryParams.Add("gateway", parameterToString(localVarOptionals.Gateway.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v NetworkRouteResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// NetworkIpServicePoliciesGetOpts Optional parameters for the method 'NetworkIpServicePoliciesGet'
type NetworkIpServicePoliciesGetOpts struct {
    Scope optional.String
    IpspaceUuid optional.String
    IpspaceName optional.String
    Name optional.String
    SvmUuid optional.String
    SvmName optional.String
    Uuid optional.String
    Services optional.String
    Fields optional.Interface
    MaxRecords optional.Int32
    ReturnRecords optional.Bool
    ReturnTimeout optional.Int32
    OrderBy optional.Interface
}

/*
NetworkIpServicePoliciesGet Method for NetworkIpServicePoliciesGet
Retrieves a collection of service policies. ### Related ONTAP commands * &#x60;network interface service-policy show&#x60;  ### Learn more * [&#x60;DOC /network/ip/service-policies&#x60;](#docs-networking-network_ip_service-policies)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *NetworkIpServicePoliciesGetOpts - Optional Parameters:
 * @param "Scope" (optional.String) -  Filter by scope
 * @param "IpspaceUuid" (optional.String) -  Filter by ipspace.uuid
 * @param "IpspaceName" (optional.String) -  Filter by ipspace.name
 * @param "Name" (optional.String) -  Filter by name
 * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
 * @param "SvmName" (optional.String) -  Filter by svm.name
 * @param "Uuid" (optional.String) -  Filter by uuid
 * @param "Services" (optional.String) -  Filter by services
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return IpServicePolicyResponse
*/
func (a *NetworkingApiService) NetworkIpServicePoliciesGet(ctx _context.Context, localVarOptionals *NetworkIpServicePoliciesGetOpts) (IpServicePolicyResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IpServicePolicyResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ip/service-policies"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Scope.IsSet() {
		localVarQueryParams.Add("scope", parameterToString(localVarOptionals.Scope.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IpspaceUuid.IsSet() {
		localVarQueryParams.Add("ipspace.uuid", parameterToString(localVarOptionals.IpspaceUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IpspaceName.IsSet() {
		localVarQueryParams.Add("ipspace.name", parameterToString(localVarOptionals.IpspaceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Services.IsSet() {
		localVarQueryParams.Add("services", parameterToString(localVarOptionals.Services.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v IpServicePolicyResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// NetworkIpServicePolicyGetOpts Optional parameters for the method 'NetworkIpServicePolicyGet'
type NetworkIpServicePolicyGetOpts struct {
    Fields optional.Interface
    MaxRecords optional.Int32
    ReturnRecords optional.Bool
    ReturnTimeout optional.Int32
    OrderBy optional.Interface
}

/*
NetworkIpServicePolicyGet Method for NetworkIpServicePolicyGet
Retrieves a specific service policy. ### Related ONTAP commands * &#x60;network interface service-policy show&#x60;  ### Learn more * [&#x60;DOC /network/ip/service-policies&#x60;](#docs-networking-network_ip_service-policies)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Service policy UUID
 * @param optional nil or *NetworkIpServicePolicyGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return IpServicePolicy
*/
func (a *NetworkingApiService) NetworkIpServicePolicyGet(ctx _context.Context, uuid string, localVarOptionals *NetworkIpServicePolicyGetOpts) (IpServicePolicy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IpServicePolicy
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/ip/service-policies/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v IpServicePolicy
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
