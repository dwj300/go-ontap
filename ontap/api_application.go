/*
 * ONTAP REST API
 *
 * ONTAP 9.6 adds support for an expansive RESTful API. The documentation below provides information about the types of API calls available to you, as well as details about using each API endpoint. You can learn more about the ONTAP REST API and ONTAP in the ONTAP 9 Documentation Center:  http://docs.netapp.com/ontap-9/topic/com.netapp.doc.dot-rest-api/home.html. NetApp welcomes your comments and suggestions about the ONTAP REST API and the documentation for its use.</br> **Using the ONTAP 9.6 REST API online documentation** Each API method includes usage examples, as well as a model that displays all the required and optional properties supported by the method. Click the _Model_ link, available with each API method, to see all the required and optional properties supported by each method.
 *
 * API version: v1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package ontap

import (
	_context "context"
	"github.com/antihax/optional"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// ApplicationApiService ApplicationApi service
type ApplicationApiService service

// ApplicationCollectionGetOpts Optional parameters for the method 'ApplicationCollectionGet'
type ApplicationCollectionGetOpts struct {
	Uuid                                           optional.String
	Name                                           optional.String
	SvmName                                        optional.String
	SvmUuid                                        optional.String
	TemplateName                                   optional.String
	TemplateVersion                                optional.String
	TemplateProtocol                               optional.String
	Generation                                     optional.String
	State                                          optional.String
	ProtectionGranularity                          optional.String
	RpoIsSupported                                 optional.String
	RpoLocalName                                   optional.String
	RpoLocalDescription                            optional.String
	RpoRemoteName                                  optional.String
	RpoRemoteDescription                           optional.String
	RpoComponentsName                              optional.String
	RpoComponentsUuid                              optional.String
	RpoComponentsLocalName                         optional.String
	RpoComponentsRpoLocalDescription               optional.String
	RpoComponentsRpoRemoteName                     optional.String
	RpoComponentsRpoRemoteDescription              optional.String
	StatisticsSpaceProvisioned                     optional.String
	StatisticsSpaceUsed                            optional.String
	StatisticsSpaceUsedPercent                     optional.String
	StatisticsSpaceUsedExcludingReserves           optional.String
	StatisticsSpaceLogicalUsed                     optional.String
	StatisticsSpaceReservedUnused                  optional.String
	StatisticsSpaceAvailable                       optional.String
	StatisticsSpaceSavings                         optional.String
	StatisticsIopsTotal                            optional.String
	StatisticsIopsPerTb                            optional.String
	StatisticsSnapshotReserve                      optional.String
	StatisticsSnapshotUsed                         optional.String
	StatisticsLatencyRaw                           optional.String
	StatisticsLatencyAverage                       optional.String
	StatisticsStatisticsIncomplete                 optional.String
	StatisticsSharedStoragePool                    optional.String
	StatisticsComponentsName                       optional.String
	StatisticsComponentsUuid                       optional.String
	StatisticsComponentsStorageServiceName         optional.String
	StatisticsComponentsSpaceProvisioned           optional.String
	StatisticsComponentsSpaceUsed                  optional.String
	StatisticsComponentsSpaceUsedPercent           optional.String
	StatisticsComponentsSpaceUsedExcludingReserves optional.String
	StatisticsComponentsSpaceLogicalUsed           optional.String
	StatisticsComponentsSpaceReservedUnused        optional.String
	StatisticsComponentsSpaceAvailable             optional.String
	StatisticsComponentsSpaceSavings               optional.String
	StatisticsComponentsIopsTotal                  optional.String
	StatisticsComponentsIopsPerTb                  optional.String
	StatisticsComponentsSnapshotReserve            optional.String
	StatisticsComponentsSnapshotUsed               optional.String
	StatisticsComponentsLatencyRaw                 optional.String
	StatisticsComponentsLatencyAverage             optional.String
	StatisticsComponentsStatisticsIncomplete       optional.String
	StatisticsComponentsSharedStoragePool          optional.String
	Fields                                         optional.Interface
	MaxRecords                                     optional.Int32
	ReturnTimeout                                  optional.Int32
	ReturnRecords                                  optional.Bool
	OrderBy                                        optional.Interface
}

/*
ApplicationCollectionGet Method for ApplicationCollectionGet
Retrieves applications. ### Expensive properties There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the &#x60;fields&#x60; query parameter. See [&#x60;DOC Requesting specific fields&#x60;](#docs-docs-Requesting-specific-fields) to learn more. * &#x60;&lt;template&gt;&#x60; the property corresponding to the &#x60;template.name&#x60; of the application ### Query examples Numerous queries are available for classifying and sorting applications: 1. Return a list of applications sorted by name.     &#x60;&#x60;&#x60;     GET /application/applications?order_by&#x3D;name     &#x60;&#x60;&#x60;     &lt;br/&gt; 2. Return a list of applications for a specific SVM.     &#x60;&#x60;&#x60;     GET /application/applications?svm.name&#x3D;&lt;name&gt;     &#x60;&#x60;&#x60;     &lt;br/&gt; 3. Return a list of all SQL applications.     &#x60;&#x60;&#x60;     GET /application/applications?template.name&#x3D;sql*     &#x60;&#x60;&#x60;     &lt;br/&gt; 4. Return a list of all applications that can be accessed via SAN.&lt;br/&gt;     &#x60;&#x60;&#x60;     GET /application/applications?template.protocol&#x3D;san     &#x60;&#x60;&#x60;     &lt;br/&gt; 5. Return the top five applications consuming the most IOPS.&lt;br/&gt;     &#x60;&#x60;&#x60;     GET /application/applications?order_by&#x3D;statistics.iops.total desc&amp;max_records&#x3D;5     &#x60;&#x60;&#x60; &lt;br/&gt;The above examples are not comprehensive. There are many more properties available for queries. Also, multiple queries can be mixed and matched with other query parameters for a large variety of requests. See the per-property documentation below for the full list of supported query parameters. ### Learn more * [&#x60;DOC /application&#x60;](#docs-application-overview)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ApplicationCollectionGetOpts - Optional Parameters:
 * @param "Uuid" (optional.String) -  Filter by UUID
 * @param "Name" (optional.String) -  Filter by name
 * @param "SvmName" (optional.String) -  Filter by svm.name
 * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
 * @param "TemplateName" (optional.String) -  Filter by template.name
 * @param "TemplateVersion" (optional.String) -  Filter by template.version
 * @param "TemplateProtocol" (optional.String) -  Filter by template.protocol
 * @param "Generation" (optional.String) -  Filter by generation
 * @param "State" (optional.String) -  Filter by state
 * @param "ProtectionGranularity" (optional.String) -  Filter by protection granularity
 * @param "RpoIsSupported" (optional.String) -  Filter by rpo.is_supported
 * @param "RpoLocalName" (optional.String) -  Filter by rpo.local.name
 * @param "RpoLocalDescription" (optional.String) -  Filter by rpo.local.description
 * @param "RpoRemoteName" (optional.String) -  Filter by rpo.remote.name
 * @param "RpoRemoteDescription" (optional.String) -  Filter by rpo.remote.description
 * @param "RpoComponentsName" (optional.String) -  Filter by rpo.components.name
 * @param "RpoComponentsUuid" (optional.String) -  Filter by rpo.components.uuid
 * @param "RpoComponentsLocalName" (optional.String) -  Filter by rpo.components.rpo.local.name
 * @param "RpoComponentsRpoLocalDescription" (optional.String) -  Filter by rpo.components.rpo.local.description
 * @param "RpoComponentsRpoRemoteName" (optional.String) -  Filter by rpo.components.rpo.remote.name
 * @param "RpoComponentsRpoRemoteDescription" (optional.String) -  Filter by rpo.components.rpo.remote.description
 * @param "StatisticsSpaceProvisioned" (optional.String) -  Filter by statistics.space.provisioned
 * @param "StatisticsSpaceUsed" (optional.String) -  Filter by statistics.space.used
 * @param "StatisticsSpaceUsedPercent" (optional.String) -  Filter by statistics.space.used_percent
 * @param "StatisticsSpaceUsedExcludingReserves" (optional.String) -  Filter by statistics.space.used_excluding_reserves
 * @param "StatisticsSpaceLogicalUsed" (optional.String) -  Filter by statistics.space.logical_used
 * @param "StatisticsSpaceReservedUnused" (optional.String) -  Filter by statistics.space.reserved_unused
 * @param "StatisticsSpaceAvailable" (optional.String) -  Filter by statistics.space.available
 * @param "StatisticsSpaceSavings" (optional.String) -  Filter by statistics.space.savings
 * @param "StatisticsIopsTotal" (optional.String) -  Filter by statistics.iops.total
 * @param "StatisticsIopsPerTb" (optional.String) -  Filter by statistics.iops.per_tb
 * @param "StatisticsSnapshotReserve" (optional.String) -  Filter by statistics.snapshot.reserve
 * @param "StatisticsSnapshotUsed" (optional.String) -  Filter by statistics.snapshot.used
 * @param "StatisticsLatencyRaw" (optional.String) -  Filter by statistics.latency.raw
 * @param "StatisticsLatencyAverage" (optional.String) -  Filter by statistics.latency.average
 * @param "StatisticsStatisticsIncomplete" (optional.String) -  Filter by statistics.statistics_incomplete
 * @param "StatisticsSharedStoragePool" (optional.String) -  Filter by statistics.shared_storage_pool
 * @param "StatisticsComponentsName" (optional.String) -  Filter by statistics.components.name
 * @param "StatisticsComponentsUuid" (optional.String) -  Filter by statistics.components.uuid
 * @param "StatisticsComponentsStorageServiceName" (optional.String) -  Filter by statistics.components.storage_service.name
 * @param "StatisticsComponentsSpaceProvisioned" (optional.String) -  Filter by statistics.components.space.provisioned
 * @param "StatisticsComponentsSpaceUsed" (optional.String) -  Filter by statistics.components.space.used
 * @param "StatisticsComponentsSpaceUsedPercent" (optional.String) -  Filter by statistics.components.space.used_percent
 * @param "StatisticsComponentsSpaceUsedExcludingReserves" (optional.String) -  Filter by statistics.components.space.used_excluding_reserves
 * @param "StatisticsComponentsSpaceLogicalUsed" (optional.String) -  Filter by statistics.components.space.logical_used
 * @param "StatisticsComponentsSpaceReservedUnused" (optional.String) -  Filter by statistics.components.space.reserved_unused
 * @param "StatisticsComponentsSpaceAvailable" (optional.String) -  Filter by statistics.components.space.available
 * @param "StatisticsComponentsSpaceSavings" (optional.String) -  Filter by statistics.components.space.savings
 * @param "StatisticsComponentsIopsTotal" (optional.String) -  Filter by statistics.components.iops.total
 * @param "StatisticsComponentsIopsPerTb" (optional.String) -  Filter by statistics.components.iops.per_tb
 * @param "StatisticsComponentsSnapshotReserve" (optional.String) -  Filter by statistics.components.snapshot.reserve
 * @param "StatisticsComponentsSnapshotUsed" (optional.String) -  Filter by statistics.components.snapshot.used
 * @param "StatisticsComponentsLatencyRaw" (optional.String) -  Filter by statistics.components.latency.raw
 * @param "StatisticsComponentsLatencyAverage" (optional.String) -  Filter by statistics.components.latency.average
 * @param "StatisticsComponentsStatisticsIncomplete" (optional.String) -  Filter by statistics.components.statistics_incomplete
 * @param "StatisticsComponentsSharedStoragePool" (optional.String) -  Filter by statistics.components.shared_storage_pool
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return ApplicationResponse
*/
func (a *ApplicationApiService) ApplicationCollectionGet(ctx _context.Context, localVarOptionals *ApplicationCollectionGetOpts) (ApplicationResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ApplicationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/application/applications"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TemplateName.IsSet() {
		localVarQueryParams.Add("template.name", parameterToString(localVarOptionals.TemplateName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TemplateVersion.IsSet() {
		localVarQueryParams.Add("template.version", parameterToString(localVarOptionals.TemplateVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TemplateProtocol.IsSet() {
		localVarQueryParams.Add("template.protocol", parameterToString(localVarOptionals.TemplateProtocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Generation.IsSet() {
		localVarQueryParams.Add("generation", parameterToString(localVarOptionals.Generation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProtectionGranularity.IsSet() {
		localVarQueryParams.Add("protection_granularity", parameterToString(localVarOptionals.ProtectionGranularity.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RpoIsSupported.IsSet() {
		localVarQueryParams.Add("rpo.is_supported", parameterToString(localVarOptionals.RpoIsSupported.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RpoLocalName.IsSet() {
		localVarQueryParams.Add("rpo.local.name", parameterToString(localVarOptionals.RpoLocalName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RpoLocalDescription.IsSet() {
		localVarQueryParams.Add("rpo.local.description", parameterToString(localVarOptionals.RpoLocalDescription.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RpoRemoteName.IsSet() {
		localVarQueryParams.Add("rpo.remote.name", parameterToString(localVarOptionals.RpoRemoteName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RpoRemoteDescription.IsSet() {
		localVarQueryParams.Add("rpo.remote.description", parameterToString(localVarOptionals.RpoRemoteDescription.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RpoComponentsName.IsSet() {
		localVarQueryParams.Add("rpo.components.name", parameterToString(localVarOptionals.RpoComponentsName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RpoComponentsUuid.IsSet() {
		localVarQueryParams.Add("rpo.components.uuid", parameterToString(localVarOptionals.RpoComponentsUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RpoComponentsLocalName.IsSet() {
		localVarQueryParams.Add("rpo.components.local.name", parameterToString(localVarOptionals.RpoComponentsLocalName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RpoComponentsRpoLocalDescription.IsSet() {
		localVarQueryParams.Add("rpo.components.rpo.local.description", parameterToString(localVarOptionals.RpoComponentsRpoLocalDescription.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RpoComponentsRpoRemoteName.IsSet() {
		localVarQueryParams.Add("rpo.components.rpo.remote.name", parameterToString(localVarOptionals.RpoComponentsRpoRemoteName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RpoComponentsRpoRemoteDescription.IsSet() {
		localVarQueryParams.Add("rpo.components.rpo.remote.description", parameterToString(localVarOptionals.RpoComponentsRpoRemoteDescription.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsSpaceProvisioned.IsSet() {
		localVarQueryParams.Add("statistics.space.provisioned", parameterToString(localVarOptionals.StatisticsSpaceProvisioned.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsSpaceUsed.IsSet() {
		localVarQueryParams.Add("statistics.space.used", parameterToString(localVarOptionals.StatisticsSpaceUsed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsSpaceUsedPercent.IsSet() {
		localVarQueryParams.Add("statistics.space.used_percent", parameterToString(localVarOptionals.StatisticsSpaceUsedPercent.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsSpaceUsedExcludingReserves.IsSet() {
		localVarQueryParams.Add("statistics.space.used_excluding_reserves", parameterToString(localVarOptionals.StatisticsSpaceUsedExcludingReserves.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsSpaceLogicalUsed.IsSet() {
		localVarQueryParams.Add("statistics.space.logical_used", parameterToString(localVarOptionals.StatisticsSpaceLogicalUsed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsSpaceReservedUnused.IsSet() {
		localVarQueryParams.Add("statistics.space.reserved_unused", parameterToString(localVarOptionals.StatisticsSpaceReservedUnused.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsSpaceAvailable.IsSet() {
		localVarQueryParams.Add("statistics.space.available", parameterToString(localVarOptionals.StatisticsSpaceAvailable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsSpaceSavings.IsSet() {
		localVarQueryParams.Add("statistics.space.savings", parameterToString(localVarOptionals.StatisticsSpaceSavings.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsIopsTotal.IsSet() {
		localVarQueryParams.Add("statistics.iops.total", parameterToString(localVarOptionals.StatisticsIopsTotal.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsIopsPerTb.IsSet() {
		localVarQueryParams.Add("statistics.iops.per_tb", parameterToString(localVarOptionals.StatisticsIopsPerTb.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsSnapshotReserve.IsSet() {
		localVarQueryParams.Add("statistics.snapshot.reserve", parameterToString(localVarOptionals.StatisticsSnapshotReserve.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsSnapshotUsed.IsSet() {
		localVarQueryParams.Add("statistics.snapshot.used", parameterToString(localVarOptionals.StatisticsSnapshotUsed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsLatencyRaw.IsSet() {
		localVarQueryParams.Add("statistics.latency.raw", parameterToString(localVarOptionals.StatisticsLatencyRaw.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsLatencyAverage.IsSet() {
		localVarQueryParams.Add("statistics.latency.average", parameterToString(localVarOptionals.StatisticsLatencyAverage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsStatisticsIncomplete.IsSet() {
		localVarQueryParams.Add("statistics.statistics_incomplete", parameterToString(localVarOptionals.StatisticsStatisticsIncomplete.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsSharedStoragePool.IsSet() {
		localVarQueryParams.Add("statistics.shared_storage_pool", parameterToString(localVarOptionals.StatisticsSharedStoragePool.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsComponentsName.IsSet() {
		localVarQueryParams.Add("statistics.components.name", parameterToString(localVarOptionals.StatisticsComponentsName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsComponentsUuid.IsSet() {
		localVarQueryParams.Add("statistics.components.uuid", parameterToString(localVarOptionals.StatisticsComponentsUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsComponentsStorageServiceName.IsSet() {
		localVarQueryParams.Add("statistics.components.storage_service.name", parameterToString(localVarOptionals.StatisticsComponentsStorageServiceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsComponentsSpaceProvisioned.IsSet() {
		localVarQueryParams.Add("statistics.components.space.provisioned", parameterToString(localVarOptionals.StatisticsComponentsSpaceProvisioned.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsComponentsSpaceUsed.IsSet() {
		localVarQueryParams.Add("statistics.components.space.used", parameterToString(localVarOptionals.StatisticsComponentsSpaceUsed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsComponentsSpaceUsedPercent.IsSet() {
		localVarQueryParams.Add("statistics.components.space.used_percent", parameterToString(localVarOptionals.StatisticsComponentsSpaceUsedPercent.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsComponentsSpaceUsedExcludingReserves.IsSet() {
		localVarQueryParams.Add("statistics.components.space.used_excluding_reserves", parameterToString(localVarOptionals.StatisticsComponentsSpaceUsedExcludingReserves.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsComponentsSpaceLogicalUsed.IsSet() {
		localVarQueryParams.Add("statistics.components.space.logical_used", parameterToString(localVarOptionals.StatisticsComponentsSpaceLogicalUsed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsComponentsSpaceReservedUnused.IsSet() {
		localVarQueryParams.Add("statistics.components.space.reserved_unused", parameterToString(localVarOptionals.StatisticsComponentsSpaceReservedUnused.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsComponentsSpaceAvailable.IsSet() {
		localVarQueryParams.Add("statistics.components.space.available", parameterToString(localVarOptionals.StatisticsComponentsSpaceAvailable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsComponentsSpaceSavings.IsSet() {
		localVarQueryParams.Add("statistics.components.space.savings", parameterToString(localVarOptionals.StatisticsComponentsSpaceSavings.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsComponentsIopsTotal.IsSet() {
		localVarQueryParams.Add("statistics.components.iops.total", parameterToString(localVarOptionals.StatisticsComponentsIopsTotal.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsComponentsIopsPerTb.IsSet() {
		localVarQueryParams.Add("statistics.components.iops.per_tb", parameterToString(localVarOptionals.StatisticsComponentsIopsPerTb.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsComponentsSnapshotReserve.IsSet() {
		localVarQueryParams.Add("statistics.components.snapshot.reserve", parameterToString(localVarOptionals.StatisticsComponentsSnapshotReserve.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsComponentsSnapshotUsed.IsSet() {
		localVarQueryParams.Add("statistics.components.snapshot.used", parameterToString(localVarOptionals.StatisticsComponentsSnapshotUsed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsComponentsLatencyRaw.IsSet() {
		localVarQueryParams.Add("statistics.components.latency.raw", parameterToString(localVarOptionals.StatisticsComponentsLatencyRaw.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsComponentsLatencyAverage.IsSet() {
		localVarQueryParams.Add("statistics.components.latency.average", parameterToString(localVarOptionals.StatisticsComponentsLatencyAverage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsComponentsStatisticsIncomplete.IsSet() {
		localVarQueryParams.Add("statistics.components.statistics_incomplete", parameterToString(localVarOptionals.StatisticsComponentsStatisticsIncomplete.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatisticsComponentsSharedStoragePool.IsSet() {
		localVarQueryParams.Add("statistics.components.shared_storage_pool", parameterToString(localVarOptionals.StatisticsComponentsSharedStoragePool.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ApplicationResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ApplicationComponentCollectionGetOpts Optional parameters for the method 'ApplicationComponentCollectionGet'
type ApplicationComponentCollectionGetOpts struct {
	Uuid               optional.String
	Name               optional.String
	StorageServiceName optional.String
	StorageServiceUuid optional.String
	Fields             optional.Interface
	MaxRecords         optional.Int32
	ReturnTimeout      optional.Int32
	ReturnRecords      optional.Bool
	OrderBy            optional.Interface
}

/*
ApplicationComponentCollectionGet Method for ApplicationComponentCollectionGet
Retrieves application components. ### Overview The application component object exposes how to access an application. Most application interfaces abstract away the underlying ONTAP storage elements, but this interface exposes what is necessary to connect to and uses the storage that is provisioned for an application. See the application component model for a detailed description of each property. ### Query examples Queries are limited on this API. Most of the details are nested under the &#x60;nfs_access&#x60;, &#x60;cifs_access&#x60;, or &#x60;san_access&#x60; properties, but those properties do not support queries, and properties nested under those properties cannot be requested individually in the current release.&lt;br/&gt; The following query returns all application components with names beginning in _secondary_.&lt;br/&gt;&lt;br/&gt; &#x60;&#x60;&#x60; GET /application/applications/{application.uuid}/components?name&#x3D;secondary* &#x60;&#x60;&#x60; &lt;br/&gt;The following query returns all application components at the _extreme_ storage service.&lt;br/&gt;&lt;br/&gt; &#x60;&#x60;&#x60; GET /application/applications/{application.uuid}/components?storage_service.name&#x3D;extreme &#x60;&#x60;&#x60; ### Learn more * [&#x60;DOC /application&#x60;](#docs-application-overview)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationUuid Application UUID
 * @param optional nil or *ApplicationComponentCollectionGetOpts - Optional Parameters:
 * @param "Uuid" (optional.String) -  Filter by UUID
 * @param "Name" (optional.String) -  Filter by name
 * @param "StorageServiceName" (optional.String) -  Filter by storage_service.name
 * @param "StorageServiceUuid" (optional.String) -  Filter by storage_service.uuid
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return ApplicationComponentResponse
*/
func (a *ApplicationApiService) ApplicationComponentCollectionGet(ctx _context.Context, applicationUuid string, localVarOptionals *ApplicationComponentCollectionGetOpts) (ApplicationComponentResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ApplicationComponentResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/application/applications/{application.uuid}/components"
	localVarPath = strings.Replace(localVarPath, "{"+"application.uuid"+"}", _neturl.QueryEscape(parameterToString(applicationUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StorageServiceName.IsSet() {
		localVarQueryParams.Add("storage_service.name", parameterToString(localVarOptionals.StorageServiceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StorageServiceUuid.IsSet() {
		localVarQueryParams.Add("storage_service.uuid", parameterToString(localVarOptionals.StorageServiceUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ApplicationComponentResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ApplicationComponentGetOpts Optional parameters for the method 'ApplicationComponentGet'
type ApplicationComponentGetOpts struct {
	Fields optional.Interface
}

/*
ApplicationComponentGet Method for ApplicationComponentGet
Retrieves an application component. ### Overview The application component object exposes how to access an application. Most application interfaces abstract away the underlying ONTAP storage elements, but this interface exposes what is necessary to connect to and uses the storage that is provisioned for an application. See the application component model for a detailed description of each property. ### Access Each application component can be accessed via NFS, CIFS, or SAN. NFS and CIFS access can be enabled simultaneously. Each access section includes a &#x60;backing_storage&#x60; property. This property is used to correlate the storage elements with the access elements of the application. The &#x60;backing_storage&#x60; portion of the access section provides the &#x60;type&#x60; and &#x60;uuid&#x60; of the backing storage. There is another &#x60;backing_storage&#x60; property at the same level as the access properties which contains lists of backing storage elements corresponding to the types listed in the access section. ### Learn more * [&#x60;DOC /application&#x60;](#docs-application-overview)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationUuid Application UUID
 * @param uuid Application component UUID
 * @param optional nil or *ApplicationComponentGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return ApplicationComponent
*/
func (a *ApplicationApiService) ApplicationComponentGet(ctx _context.Context, applicationUuid string, uuid string, localVarOptionals *ApplicationComponentGetOpts) (ApplicationComponent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ApplicationComponent
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/application/applications/{application.uuid}/components/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"application.uuid"+"}", _neturl.QueryEscape(parameterToString(applicationUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ApplicationComponent
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ApplicationComponentSnapshotCollectionGetOpts Optional parameters for the method 'ApplicationComponentSnapshotCollectionGet'
type ApplicationComponentSnapshotCollectionGetOpts struct {
	ComponentName   optional.String
	Uuid            optional.String
	Name            optional.String
	ConsistencyType optional.String
	Comment         optional.String
	CreateTime      optional.String
	IsPartial       optional.String
	Fields          optional.Interface
	MaxRecords      optional.Int32
	ReturnTimeout   optional.Int32
	ReturnRecords   optional.Bool
	OrderBy         optional.Interface
}

/*
ApplicationComponentSnapshotCollectionGet Method for ApplicationComponentSnapshotCollectionGet
Retrieves Snapshot copies of an application component.&lt;br/&gt; This endpoint is only supported for Maxdata template applications.&lt;br/&gt; Component Snapshot copies are essentially more granular application Snapshot copies. There is no difference beyond the scope of the operation. ### Learn more * [&#x60;DOC /application/applications/{application.uuid}/snapshots&#x60;](#docs-application-application_applications_{application.uuid}_snapshots) * [&#x60;GET /application/applications/{uuid}/snapshots&#x60;](#operations-application-application_snapshot_collection_get) * [&#x60;DOC /application&#x60;](#docs-application-overview)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationUuid Application UUID
 * @param componentUuid Application Component UUID
 * @param optional nil or *ApplicationComponentSnapshotCollectionGetOpts - Optional Parameters:
 * @param "ComponentName" (optional.String) -  Filter by Application Component Name
 * @param "Uuid" (optional.String) -  Filter by uuid
 * @param "Name" (optional.String) -  Filter by name
 * @param "ConsistencyType" (optional.String) -  Filter by consistency_type
 * @param "Comment" (optional.String) -  Filter by comment
 * @param "CreateTime" (optional.String) -  Filter by create_time
 * @param "IsPartial" (optional.String) -  Filter by is_partial
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return ApplicationComponentSnapshotResponse
*/
func (a *ApplicationApiService) ApplicationComponentSnapshotCollectionGet(ctx _context.Context, applicationUuid string, componentUuid string, localVarOptionals *ApplicationComponentSnapshotCollectionGetOpts) (ApplicationComponentSnapshotResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ApplicationComponentSnapshotResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/application/applications/{application.uuid}/components/{component.uuid}/snapshots"
	localVarPath = strings.Replace(localVarPath, "{"+"application.uuid"+"}", _neturl.QueryEscape(parameterToString(applicationUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"component.uuid"+"}", _neturl.QueryEscape(parameterToString(componentUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.ComponentName.IsSet() {
		localVarQueryParams.Add("component.name", parameterToString(localVarOptionals.ComponentName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ConsistencyType.IsSet() {
		localVarQueryParams.Add("consistency_type", parameterToString(localVarOptionals.ConsistencyType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Comment.IsSet() {
		localVarQueryParams.Add("comment", parameterToString(localVarOptionals.Comment.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreateTime.IsSet() {
		localVarQueryParams.Add("create_time", parameterToString(localVarOptionals.CreateTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsPartial.IsSet() {
		localVarQueryParams.Add("is_partial", parameterToString(localVarOptionals.IsPartial.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ApplicationComponentSnapshotResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ApplicationComponentSnapshotCreateOpts Optional parameters for the method 'ApplicationComponentSnapshotCreate'
type ApplicationComponentSnapshotCreateOpts struct {
	Info optional.Interface
}

/*
ApplicationComponentSnapshotCreate Method for ApplicationComponentSnapshotCreate
Creates a Snapshot copy of an application component.&lt;br/&gt; This endpoint is only supported for Maxdata template applications.&lt;br/&gt; ### Required properties * &#x60;name&#x60; ### Recommended optional properties * &#x60;consistency_type&#x60; - Track whether this snapshot is _application_ or _crash_ consistent. Component Snapshot copies are essentially more granular application Snapshot copies. There is no difference beyond the scope of the operation. ### Learn more * [&#x60;DOC /application/applications/{application.uuid}/snapshots&#x60;](#docs-application-application_applications_{application.uuid}_snapshots) * [&#x60;GET /application/applications/{uuid}/snapshots&#x60;](#operations-application-application_snapshot_create) * [&#x60;DOC /application&#x60;](#docs-application-overview)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationUuid Application UUID
 * @param componentUuid Application Component UUID
 * @param optional nil or *ApplicationComponentSnapshotCreateOpts - Optional Parameters:
 * @param "Info" (optional.Interface of ApplicationComponentSnapshot) -  Info specification
@return JobLinkResponse
*/
func (a *ApplicationApiService) ApplicationComponentSnapshotCreate(ctx _context.Context, applicationUuid string, componentUuid string, localVarOptionals *ApplicationComponentSnapshotCreateOpts) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/application/applications/{application.uuid}/components/{component.uuid}/snapshots"
	localVarPath = strings.Replace(localVarPath, "{"+"application.uuid"+"}", _neturl.QueryEscape(parameterToString(applicationUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"component.uuid"+"}", _neturl.QueryEscape(parameterToString(componentUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(ApplicationComponentSnapshot)
		if !localVarOptionalInfook {
			return localVarReturnValue, nil, reportError("info should be ApplicationComponentSnapshot")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
ApplicationComponentSnapshotDelete Method for ApplicationComponentSnapshotDelete
Delete a Snapshot copy of an application component.&lt;br/&gt; This endpoint is only supported for Maxdata template applications.&lt;br/&gt; Component Snapshot copies are essentially more granular application Snapshot copies. There is no difference beyond the scope of the operation. ### Learn more * [&#x60;DOC /application/applications/{application.uuid}/snapshots&#x60;](#docs-application-application_applications_{application.uuid}_snapshots) * [&#x60;DELETE /application/applications/{uuid}/snapshots&#x60;](#operations-application-application_snapshot_delete) * [&#x60;DOC /application&#x60;](#docs-application-overview)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationUuid Application UUID
 * @param componentUuid Application Component UUID
 * @param uuid Snapshot UUID
@return JobLinkResponse
*/
func (a *ApplicationApiService) ApplicationComponentSnapshotDelete(ctx _context.Context, applicationUuid string, componentUuid string, uuid string) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/application/applications/{application.uuid}/components/{component.uuid}/snapshots/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"application.uuid"+"}", _neturl.QueryEscape(parameterToString(applicationUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"component.uuid"+"}", _neturl.QueryEscape(parameterToString(componentUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ApplicationComponentSnapshotGetOpts Optional parameters for the method 'ApplicationComponentSnapshotGet'
type ApplicationComponentSnapshotGetOpts struct {
	Fields optional.Interface
}

/*
ApplicationComponentSnapshotGet Method for ApplicationComponentSnapshotGet
Retrieve a Snapshot copy of an application component.&lt;br/&gt; This endpoint is only supported for Maxdata template applications.&lt;br/&gt; Component Snapshot copies are essentially more granular application Snapshot copies. There is no difference beyond the scope of the operation. ### Learn more * [&#x60;DOC /application/applications/{application.uuid}/snapshots&#x60;](#docs-application-application_applications_{application.uuid}_snapshots) * [&#x60;GET /application/applications/{uuid}/snapshots&#x60;](#operations-application-application_snapshot_get) * [&#x60;DOC /application&#x60;](#docs-application-overview)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationUuid Application UUID
 * @param componentUuid Application Component UUID
 * @param uuid Snapshot UUID
 * @param optional nil or *ApplicationComponentSnapshotGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return ApplicationComponentSnapshot
*/
func (a *ApplicationApiService) ApplicationComponentSnapshotGet(ctx _context.Context, applicationUuid string, componentUuid string, uuid string, localVarOptionals *ApplicationComponentSnapshotGetOpts) (ApplicationComponentSnapshot, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ApplicationComponentSnapshot
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/application/applications/{application.uuid}/components/{component.uuid}/snapshots/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"application.uuid"+"}", _neturl.QueryEscape(parameterToString(applicationUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"component.uuid"+"}", _neturl.QueryEscape(parameterToString(componentUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ApplicationComponentSnapshot
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
ApplicationComponentSnapshotRestore Method for ApplicationComponentSnapshotRestore
Restore a Snapshot copy of an application component.&lt;br/&gt; This endpoint is only supported for Maxdata template applications.&lt;br/&gt; Component Snapshot copies are essentially more granular application Snapshot copies. There is no difference beyond the scope of the operation. ### Learn more * [&#x60;DOC /application/applications/{application.uuid}/snapshots&#x60;](#docs-application-application_applications_{application.uuid}_snapshots) * [&#x60;POST /application/applications/{application.uuid}/snapshots/{uuid}/restore&#x60;](#operations-application-application_snapshot_restore) * [&#x60;DOC /application&#x60;](#docs-application-overview) * [&#x60;DOC Asynchronous operations&#x60;](#docs-docs-Synchronous-and-asynchronous-operations)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationUuid Application UUID
 * @param componentUuid Application Component UUID
 * @param uuid Snapshot copy UUID
@return JobLinkResponse
*/
func (a *ApplicationApiService) ApplicationComponentSnapshotRestore(ctx _context.Context, applicationUuid string, componentUuid string, uuid string) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/application/applications/{application.uuid}/components/{component.uuid}/snapshots/{uuid}/restore"
	localVarPath = strings.Replace(localVarPath, "{"+"application.uuid"+"}", _neturl.QueryEscape(parameterToString(applicationUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"component.uuid"+"}", _neturl.QueryEscape(parameterToString(componentUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
ApplicationCreate Method for ApplicationCreate
Creates an application. ### Template properties The application APIs appear to be complex and long in this documentation because we document every possible template, of which there are currently 14. When creating an application, only a single template is used, so it is best to focus only on the template of interest. Other than the properties for the chosen template, only the &#x60;name&#x60; and &#x60;svm&#x60; of the application must be provided. The following three sections provided guidelines on using the properties of the templates, but the whole idea behind the templates is to automatically follow the best practices of the given application, so the only way to determine the exact list of required properties and default values is to dig in to the model section of the template. The templates are all top level properties of the application object with names matching the values returned by [&#x60;GET /application/templates&#x60;](#operations-application-application_template_collection_get). ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - The existing SVM in which to create the application. * &#x60;name&#x60; - The name for the application. * &#x60;&lt;template&gt;&#x60; - Properties for one template must be provided. In general, the following properties are required, however the naming of these may vary slightly from template to template.   * &#x60;name&#x60; - The generic templates require names for the components of the application. Other templates name the components automatically.   * &#x60;size&#x60; - This generally refers to the size of an application component, which may be spread across multiple underlying storage objects (volumes, LUNs, etc...).   * &#x60;igroup_name&#x60; - All SAN applications require an initiator group to be specified in some way.   * &#x60;os_type&#x60; - All SAN applications require an os_type to be specified in some way. Some templates refer to this as the &#x60;hypervisor&#x60;. ### Recommended optional properties * &#x60;&lt;template&gt;&#x60; - The following properties are available in some templates.   * &#x60;new_igroups.*&#x60; - SAN applications can use existing initiator groups or create new ones. When creating new initiator groups, &#x60;new_igroups.name&#x60; is required and the other properties may be used to fully specify the new initiator group. ### Default property values If not specified in POST, the follow default property values are assigned. It is recommended that most of these properties be provided explicitly rather than relying upon the defaults. The defaults are intended to make it as easy as possible to provision and connect to an application, but likely provide more access to the application than is necessary. * &#x60;template.name&#x60; - Defaults to match the &#x60;&lt;template&gt;&#x60; provided. If specified, the value of this property must match the provided template properties. * &#x60;&lt;template&gt;&#x60; - The majority of template properties have default values. The defaults may vary from template to template. See the model of each template for complete details. In general the following patterns are common across all template properties. The location of these properties varies from template to template.   * &#x60;storage_service.name&#x60; - _value_   * &#x60;nfs_access.host&#x60; - _0.0.0.0/0_   * &#x60;nfs_access.access&#x60; - _rw_   * &#x60;cifs_access.user_or_group&#x60; - _everyone_   * &#x60;cifs_access.access&#x60; - _full_access_   * &#x60;protection_type.local_rpo&#x60; - _hourly_ (Hourly Snapshot copies)   * &#x60;protection_type.remote_rpo&#x60; - _none_ (Not MetroCluster)   * &#x60;new_igroups.os_type&#x60; - Defaults to match the &#x60;os_type&#x60; provided for the application, but may need to be provided explicitly when using virtualization. ### Optional components A common pattern across many templates are objects that are optional, but once any property in the object is specified, other properties within the object become required. Many applications have optional components. For example, provisioning a database without a component to store the logs is supported. If the properties related to the logs are omitted, no storage will be provisioned for logs. But when the additional component is desired, the size is required. Specifying any other property of a component without specifying the size is not supported. In the model of each template, this is documented in the description of each property. When a &#x60;size&#x60; property is listed as optional, that means the component itself is optional, and the size should be specified to include that component in the application. ### POST body examples 1. Create a generic SAN application that exposes four LUNs to an existing initiator group, _igroup_1_.&lt;br/&gt;     &#x60;&#x60;&#x60;     {       \&quot;name\&quot;: \&quot;app1\&quot;,       \&quot;svm\&quot;: { \&quot;name\&quot;: \&quot;svm1\&quot; },       \&quot;san\&quot;: {         \&quot;os_type\&quot;: \&quot;linux\&quot;,         \&quot;application_components\&quot;: [           { \&quot;name\&quot;: \&quot;component1\&quot;, \&quot;total_size\&quot;: \&quot;10GB\&quot;, \&quot;lun_count\&quot;: 4, \&quot;igroup_name\&quot;: \&quot;igroup_1\&quot; }         ]       }     }     &#x60;&#x60;&#x60;     &lt;br/&gt; 2. Create an SQL application that can be accessed via initiator _iqn.2017-01.com.example:foo_ from a new initiator group, _igroup_2_.&lt;br/&gt;     &#x60;&#x60;&#x60;     {       \&quot;name\&quot;: \&quot;app2\&quot;,       \&quot;svm\&quot;: { \&quot;name\&quot;: \&quot;svm1\&quot; },       \&quot;sql_on_san\&quot;: {         \&quot;db\&quot;: { \&quot;size\&quot;: \&quot;5GB\&quot; },         \&quot;log\&quot;: { \&quot;size\&quot;: \&quot;1GB\&quot; },         \&quot;temp_db\&quot;: { \&quot;size\&quot;: \&quot;2GB\&quot; },         \&quot;igroup_name\&quot;: \&quot;igroup_2\&quot;,         \&quot;new_igroups\&quot;: [           { \&quot;name\&quot;: \&quot;igroup_2\&quot;, \&quot;initiators\&quot;: [ \&quot;iqn.2017-01.com.example:foo\&quot; ] }         ]       }     }     &#x60;&#x60;&#x60;     &lt;br/&gt; 3. The following body creates the exact same SQL application, but manually provides all the defaults that were excluded from the previous call. Note: The model of a _sql_on_san_ application documents all these default values.&lt;br/&gt;     &#x60;&#x60;&#x60;     {       \&quot;name\&quot;: \&quot;app3\&quot;,       \&quot;svm\&quot;: { \&quot;name\&quot;: \&quot;svm1\&quot; },       \&quot;template\&quot;: { \&quot;name\&quot;: \&quot;sql_on_san\&quot; },       \&quot;sql_on_san\&quot;: {         \&quot;os_type\&quot;: \&quot;windows_2008\&quot;,         \&quot;server_cores_count\&quot;: 8,         \&quot;db\&quot;: { \&quot;size\&quot;: \&quot;5GB\&quot;, \&quot;storage_service\&quot;: { \&quot;name\&quot;: \&quot;value\&quot; } },         \&quot;log\&quot;: { \&quot;size\&quot;: \&quot;1GB\&quot;, \&quot;storage_service\&quot;: { \&quot;name\&quot;: \&quot;value\&quot; } },         \&quot;temp_db\&quot;: { \&quot;size\&quot;: \&quot;2GB\&quot;, \&quot;storage_service\&quot;: { \&quot;name\&quot;: \&quot;value\&quot; } },         \&quot;igroup_name\&quot;: \&quot;igroup_2\&quot;,         \&quot;new_igroups\&quot;: [           {             \&quot;name\&quot;: \&quot;igroup_2\&quot;,             \&quot;protocol\&quot;: \&quot;mixed\&quot;,             \&quot;os_type\&quot;: \&quot;windows\&quot;,             \&quot;initiators\&quot;: [ \&quot;iqn.a.new.initiator\&quot; ]           }         ],         \&quot;protection_type\&quot;: { \&quot;local_rpo\&quot;: \&quot;none\&quot; }       }     }     &#x60;&#x60;&#x60; ### Learn more * [&#x60;DOC /application&#x60;](#docs-application-overview) * [&#x60;DOC Asynchronous operations&#x60;](#docs-docs-Synchronous-and-asynchronous-operations)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info Info specification
@return JobLinkResponse
*/
func (a *ApplicationApiService) ApplicationCreate(ctx _context.Context, info Application) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/application/applications"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
ApplicationDelete Method for ApplicationDelete
Deletes an application and all associated data. ### Warning - this deletes it all, including your data This deletes everything created with the application, including any volumes, LUNs, NFS export policies, CIFS shares, and initiator groups. Initiator groups are only destroyed if they were created as part of an application and are no longer in use by other applications. ### Learn more * [&#x60;DOC /application&#x60;](#docs-application-overview) * [&#x60;DOC Asynchronous operations&#x60;](#docs-docs-Synchronous-and-asynchronous-operations)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Application UUID
@return JobLinkResponse
*/
func (a *ApplicationApiService) ApplicationDelete(ctx _context.Context, uuid string) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/application/applications/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ApplicationGetOpts Optional parameters for the method 'ApplicationGet'
type ApplicationGetOpts struct {
	Fields optional.Interface
}

/*
ApplicationGet Method for ApplicationGet
Retrieves an application ### Expensive properties There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the &#x60;fields&#x60; query parameter. See [&#x60;DOC Requesting specific fields&#x60;](#docs-docs-Requesting-specific-fields) to learn more. * &#x60;&lt;template&gt;&#x60; the property corresponding to the &#x60;template.name&#x60; of the application ### Property overview An application includes three main groups or properties. * Generic properties - such as the &#x60;name&#x60;, &#x60;template.name&#x60;, and &#x60;state&#x60; of the application. These properties are all inexpensive to retrieve and their meaning is consistent for every type of application. * &#x60;statistics.*&#x60; - application statistics report live usage data about the application and its components. Various space and IOPS details are included at both the application level and at a per component level. The application model includes a detailed description of each property. These properties are slightly more expensive than the generic properties because live data must be collected from every storage element in the application. * &#x60;&lt;template&gt;&#x60; - the property corresponding to the value of the &#x60;template.name&#x60; returns the contents of the application in the same layout that was used to provision the application. This information is very expensive to retrieve because it requires collecting information about all the storage and access settings for every element of the application. There are a few notable limitations to what can be returned in the &#x60;&lt;template&gt;&#x60; section:   * The &#x60;new_igroups&#x60; array of many SAN templates is not returned by GET. This property allows igroup creation in the same call that creates an application, but is not a property of the application itself. The &#x60;new_igroups&#x60; array is allowed during PATCH operations, but that does not modify the &#x60;new_igroups&#x60; of the application. It is another way to allow igroup creation while updating the application to use a different igroup.   * The &#x60;vdi_on_san&#x60; and &#x60;vdi_on_nas&#x60; &#x60;desktops.count&#x60; property is rounded to the nearest 1000 during creation, and is reported with that rounding applied.   * The &#x60;mongo_db_on_san&#x60; &#x60;dataset.element_count&#x60; property is rounded up to an even number, and is reported with that rounding applied.   * The &#x60;sql_on_san&#x60; and &#x60;sql_on_smb&#x60; &#x60;server_cores_count&#x60; property is limited to 8 for GET operations. Higher values are accepted by POST, but the impact of the &#x60;server_cores_count&#x60; property on the application layout currently reaches its limit at 8. ### Learn more * [&#x60;DOC /application&#x60;](#docs-application-overview)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Application UUID
 * @param optional nil or *ApplicationGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return Application
*/
func (a *ApplicationApiService) ApplicationGet(ctx _context.Context, uuid string, localVarOptionals *ApplicationGetOpts) (Application, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Application
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/application/applications/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Application
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ApplicationModifyOpts Optional parameters for the method 'ApplicationModify'
type ApplicationModifyOpts struct {
	Info optional.Interface
}

/*
ApplicationModify Method for ApplicationModify
Updates the properties of an application. ### Overview Similar to creating an application, modification is done using the template properties of an application. The &#x60;storage_service&#x60;, &#x60;size&#x60;, and &#x60;igroup_name&#x60; of an application may be modified. ### &#x60;storage_service&#x60; Storage service modifications are processed in place, meaning that the storage can not be moved to a location with more performance headroom to accommodate the request. If the current backing storage of the application is in a location that can support increased performance, the QoS policies associated with the application will be modified to allow it. If not, an error will be returned. A storage service modification to a lower tier of performance is always allowed, but the reverse modification may not be supported if the cluster is over provisioned and the cluster is unlikely to be able to fulfil the original storage service. ### &#x60;size&#x60; Size modifications are processed in a variety of ways depending on the type of application. For NAS applications, volumes are grown or new volumes are added. For SAN applications, LUNs are grown, new LUNs are added to existing volumes, or new LUNs are added to new volumes. If new storage elements are created, they can be found using the [&#x60;GET /application/applications/{application.uuid}/components&#x60;](#operations-application-application_component_collection_get) interface. The creation time of each storage object is included, and the newly created objects will use the same naming scheme as the previous objects. Resize follows the best practices associated with the type of application being expanded. Reducing the size of an application is not supported. ### &#x60;igroup_name&#x60; Modification of the igroup name allows an entire application to be mapped from one initiator group to another. Data access will be interrupted as the LUNs are unmapped from the original igroup and remapped to the new one. ### Application state During a modification, the &#x60;state&#x60; property of the application updates to indicate &#x60;modifying&#x60;. In &#x60;modifying&#x60; state, statistics are not available and Snapshot copy operations are not allowed. If the modification fails, it is possible for the application to be left in an inconsistent state, with the underlying ONTAP storage elements not matching across a component. When this occurs, the application is left in the &#x60;modifying&#x60; state until the command is either retried and succeeds or a call to restore the original state is successful. ### Examples 1. Change the storage service of the database of the Oracle application to _extreme_ and resize the redo logs to _100GB_.     &#x60;&#x60;&#x60;     {       \&quot;oracle_on_nfs\&quot;: {         \&quot;db\&quot;: {           \&quot;storage_service\&quot;: {             \&quot;name\&quot;: \&quot;extreme\&quot;           }         },         \&quot;redo_log\&quot;: {           \&quot;size\&quot;: \&quot;100GB\&quot;         }       }     }     &#x60;&#x60;&#x60;     &lt;br/&gt; 2. Change the storage service, size, and igroup of a generic application by component name.     &#x60;&#x60;&#x60;     {       \&quot;san\&quot;: {         \&quot;application_components\&quot;: [           {             \&quot;name\&quot;: \&quot;component1\&quot;,             \&quot;storage_service\&quot;: {               \&quot;name\&quot;: \&quot;value\&quot;             }           },           {             \&quot;name\&quot;: \&quot;component2\&quot;,             \&quot;size\&quot;: \&quot;200GB\&quot;           },           {             \&quot;name\&quot;: \&quot;component3\&quot;,             \&quot;igroup_name\&quot;: \&quot;igroup5\&quot;           }         ]       }     }     &#x60;&#x60;&#x60;     &lt;br/&gt; ### Learn more * [&#x60;DOC /application&#x60;](#docs-application-overview) * [&#x60;DOC Asynchronous operations&#x60;](#docs-docs-Synchronous-and-asynchronous-operations)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Application UUID
 * @param optional nil or *ApplicationModifyOpts - Optional Parameters:
 * @param "Info" (optional.Interface of Application) -  Info specification
@return JobLinkResponse
*/
func (a *ApplicationApiService) ApplicationModify(ctx _context.Context, uuid string, localVarOptionals *ApplicationModifyOpts) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/application/applications/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(Application)
		if !localVarOptionalInfook {
			return localVarReturnValue, nil, reportError("info should be Application")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ApplicationSnapshotCollectionGetOpts Optional parameters for the method 'ApplicationSnapshotCollectionGet'
type ApplicationSnapshotCollectionGetOpts struct {
	Uuid            optional.String
	Name            optional.String
	ConsistencyType optional.String
	ComponentsName  optional.String
	ComponentsUuid  optional.String
	Comment         optional.String
	CreateTime      optional.String
	IsPartial       optional.String
	Fields          optional.Interface
	MaxRecords      optional.Int32
	ReturnTimeout   optional.Int32
	ReturnRecords   optional.Bool
	OrderBy         optional.Interface
}

/*
ApplicationSnapshotCollectionGet Method for ApplicationSnapshotCollectionGet
Retrieves Snapshot copies of an application. ### Query examples The following query returns all Snapshot copies from May 4, 2017 EST. For readability, the colon (&#x60;:&#x60;) is left in this example. For an actual call, they should be escaped as &#x60;%3A&#x60;.&lt;br/&gt;&lt;br/&gt; &#x60;&#x60;&#x60; GET /application/applications/{application.uuid}/snapshots?create_time&#x3D;2017-05-04T00:00:00-05:00..2017-05-04T23:59:59-05:00 &#x60;&#x60;&#x60; &lt;br/&gt;The following query returns all Snapshot copies that have been flagged as _application consistent_.&lt;br/&gt;&lt;br/&gt; &#x60;&#x60;&#x60; GET /application/applications/{application.uuid}/snapshots?consistency_type&#x3D;application &#x60;&#x60;&#x60; ### Learn more * [&#x60;DOC /application/applications/{application.uuid}/snapshots&#x60;](#docs-application-application_applications_{application.uuid}_snapshots) * [&#x60;DOC /application&#x60;](#docs-application-overview)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationUuid Application UUID
 * @param optional nil or *ApplicationSnapshotCollectionGetOpts - Optional Parameters:
 * @param "Uuid" (optional.String) -  Filter by UUID
 * @param "Name" (optional.String) -  Filter by name
 * @param "ConsistencyType" (optional.String) -  Filter by consistency_type
 * @param "ComponentsName" (optional.String) -  Filter by components.name
 * @param "ComponentsUuid" (optional.String) -  Filter by components.uuid
 * @param "Comment" (optional.String) -  Filter by comment
 * @param "CreateTime" (optional.String) -  Filter by create_time
 * @param "IsPartial" (optional.String) -  Filter by is_partial
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return ApplicationSnapshotResponse
*/
func (a *ApplicationApiService) ApplicationSnapshotCollectionGet(ctx _context.Context, applicationUuid string, localVarOptionals *ApplicationSnapshotCollectionGetOpts) (ApplicationSnapshotResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ApplicationSnapshotResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/application/applications/{application.uuid}/snapshots"
	localVarPath = strings.Replace(localVarPath, "{"+"application.uuid"+"}", _neturl.QueryEscape(parameterToString(applicationUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ConsistencyType.IsSet() {
		localVarQueryParams.Add("consistency_type", parameterToString(localVarOptionals.ConsistencyType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ComponentsName.IsSet() {
		localVarQueryParams.Add("components.name", parameterToString(localVarOptionals.ComponentsName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ComponentsUuid.IsSet() {
		localVarQueryParams.Add("components.uuid", parameterToString(localVarOptionals.ComponentsUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Comment.IsSet() {
		localVarQueryParams.Add("comment", parameterToString(localVarOptionals.Comment.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreateTime.IsSet() {
		localVarQueryParams.Add("create_time", parameterToString(localVarOptionals.CreateTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsPartial.IsSet() {
		localVarQueryParams.Add("is_partial", parameterToString(localVarOptionals.IsPartial.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ApplicationSnapshotResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ApplicationSnapshotCreateOpts Optional parameters for the method 'ApplicationSnapshotCreate'
type ApplicationSnapshotCreateOpts struct {
	Info optional.Interface
}

/*
ApplicationSnapshotCreate Method for ApplicationSnapshotCreate
Creates a Snapshot copy of the application. ### Required properties * &#x60;name&#x60; ### Recommended optional properties * &#x60;consistency_type&#x60; - Track whether this snapshot is _application_ or _crash_ consistent. ### Learn more * [&#x60;DOC /application/applications/{application.uuid}/snapshots&#x60;](#docs-application-application_applications_{application.uuid}_snapshots) * [&#x60;DOC /application&#x60;](#docs-application-overview)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationUuid Application UUID
 * @param optional nil or *ApplicationSnapshotCreateOpts - Optional Parameters:
 * @param "Info" (optional.Interface of ApplicationSnapshot) -  Info specification
@return JobLinkResponse
*/
func (a *ApplicationApiService) ApplicationSnapshotCreate(ctx _context.Context, applicationUuid string, localVarOptionals *ApplicationSnapshotCreateOpts) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/application/applications/{application.uuid}/snapshots"
	localVarPath = strings.Replace(localVarPath, "{"+"application.uuid"+"}", _neturl.QueryEscape(parameterToString(applicationUuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(ApplicationSnapshot)
		if !localVarOptionalInfook {
			return localVarReturnValue, nil, reportError("info should be ApplicationSnapshot")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
ApplicationSnapshotDelete Method for ApplicationSnapshotDelete
Delete a Snapshot copy of an application ### Query examples Individual Snapshot copies can be destroyed with no query parameters, or a range of Snapshot copies can be destroyed at one time using a query.&lt;br/&gt; The following query deletes all application Snapshot copies created before May 4, 2017&lt;br/&gt;&lt;br/&gt; &#x60;&#x60;&#x60; DELETE /application/applications/{application.uuid}/snapshots?create_time&#x3D;&lt;2017-05-04T00:00:00-05:00 &#x60;&#x60;&#x60;  ### Learn more * [&#x60;DOC /application/applications/{application.uuid}/snapshots&#x60;](#docs-application-application_applications_{application.uuid}_snapshots)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationUuid Application UUID
 * @param uuid Snapshot copy UUID
@return JobLinkResponse
*/
func (a *ApplicationApiService) ApplicationSnapshotDelete(ctx _context.Context, applicationUuid string, uuid string) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/application/applications/{application.uuid}/snapshots/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"application.uuid"+"}", _neturl.QueryEscape(parameterToString(applicationUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ApplicationSnapshotGetOpts Optional parameters for the method 'ApplicationSnapshotGet'
type ApplicationSnapshotGetOpts struct {
	Fields optional.Interface
}

/*
ApplicationSnapshotGet Method for ApplicationSnapshotGet
Retrieve a Snapshot copy of an application component.&lt;br/&gt; This endpoint is only supported for Maxdata template applications.&lt;br/&gt; Component Snapshot copies are essentially more granular application Snapshot copies. There is no difference beyond the scope of the operation. ### Learn more * [&#x60;DOC /application/applications/{application.uuid}/snapshots&#x60;](#docs-application-application_applications_{application.uuid}_snapshots) * [&#x60;GET /application/applications/{uuid}/snapshots&#x60;](#operations-application-application_snapshot_create) * [&#x60;DOC /application&#x60;](#docs-application-overview)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationUuid Application UUID
 * @param uuid Snapshot copy UUID
 * @param optional nil or *ApplicationSnapshotGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return ApplicationSnapshot
*/
func (a *ApplicationApiService) ApplicationSnapshotGet(ctx _context.Context, applicationUuid string, uuid string, localVarOptionals *ApplicationSnapshotGetOpts) (ApplicationSnapshot, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ApplicationSnapshot
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/application/applications/{application.uuid}/snapshots/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"application.uuid"+"}", _neturl.QueryEscape(parameterToString(applicationUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ApplicationSnapshot
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
ApplicationSnapshotRestore Method for ApplicationSnapshotRestore
Restore an application snapshot&lt;br/&gt; Restoring an application Snapshot copy reverts all storage elements in the Snapshot copy to the state in which the Snapshot copy was in when the Snapshot copy was taken. This restoration does not apply to access settings that might have changed since the Snapshot copy was created. ### Learn more * [&#x60;DOC /application&#x60;](#docs-application-overview) * [&#x60;DOC Asynchronous operations&#x60;](#docs-docs-Synchronous-and-asynchronous-operations)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationUuid Application UUID
 * @param uuid Snapshot copy UUID
@return JobLinkResponse
*/
func (a *ApplicationApiService) ApplicationSnapshotRestore(ctx _context.Context, applicationUuid string, uuid string) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/application/applications/{application.uuid}/snapshots/{uuid}/restore"
	localVarPath = strings.Replace(localVarPath, "{"+"application.uuid"+"}", _neturl.QueryEscape(parameterToString(applicationUuid, "")), -1)

	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ApplicationTemplateCollectionGetOpts Optional parameters for the method 'ApplicationTemplateCollectionGet'
type ApplicationTemplateCollectionGetOpts struct {
	Name                 optional.String
	Protocol             optional.String
	Description          optional.String
	MissingPrerequisites optional.String
	Fields               optional.Interface
	MaxRecords           optional.Int32
	ReturnTimeout        optional.Int32
	ReturnRecords        optional.Bool
	OrderBy              optional.Interface
}

/*
ApplicationTemplateCollectionGet Method for ApplicationTemplateCollectionGet
Retrieves application templates. ### Query examples The most useful queries on this API allows searches by name or protocol access. The following query returns all templates that are used to provision an Oracle application.&lt;br/&gt;&lt;br/&gt; &#x60;&#x60;&#x60; GET /application/templates?name&#x3D;ora* &#x60;&#x60;&#x60; &lt;br/&gt;Similarly, the following query returns all templates that support SAN access.&lt;br/&gt;&lt;br/&gt; &#x60;&#x60;&#x60; GET /application/templates?protocol&#x3D;san &#x60;&#x60;&#x60; ### Learn more * [&#x60;DOC /application&#x60;](#docs-application-overview)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ApplicationTemplateCollectionGetOpts - Optional Parameters:
 * @param "Name" (optional.String) -  Filter by name
 * @param "Protocol" (optional.String) -  Filter by protocol
 * @param "Description" (optional.String) -  Filter by description
 * @param "MissingPrerequisites" (optional.String) -  Filter by missing_prerequisites
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return ApplicationTemplateResponse
*/
func (a *ApplicationApiService) ApplicationTemplateCollectionGet(ctx _context.Context, localVarOptionals *ApplicationTemplateCollectionGetOpts) (ApplicationTemplateResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ApplicationTemplateResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/application/templates"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Protocol.IsSet() {
		localVarQueryParams.Add("protocol", parameterToString(localVarOptionals.Protocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MissingPrerequisites.IsSet() {
		localVarQueryParams.Add("missing_prerequisites", parameterToString(localVarOptionals.MissingPrerequisites.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ApplicationTemplateResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ApplicationTemplateGetOpts Optional parameters for the method 'ApplicationTemplateGet'
type ApplicationTemplateGetOpts struct {
	Fields optional.Interface
}

/*
ApplicationTemplateGet Method for ApplicationTemplateGet
Retrieves an application template. ### Template properties Each application template has a set of properties. These properties are always nested under a property with the same name as the template. For example, when using the &#x60;mongo_db_on_san&#x60; template, the properties are found nested inside the &#x60;mongo_db_on_san&#x60; property. The properties nested under the template property are all specific to the template. The model for the application template object includes all the available templates, but only the object that corresponds to the template&#39;s name is returned, and only one is provided in any application API.&lt;br/&gt; The model of each template includes a description of each property and its allowed values or usage. Default values are also indicated when available. The template properties returned by this API include an example value for each property. ### Template prerequisites Each template has a set of prerequisites required for its use. If any of these prerequisites are not met, the &#x60;missing_prerequisites&#x60; property indicates which prerequisite is missing. ### Learn more * [&#x60;DOC /application&#x60;](#docs-application-overview)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Template Name
 * @param optional nil or *ApplicationTemplateGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return ApplicationTemplate
*/
func (a *ApplicationApiService) ApplicationTemplateGet(ctx _context.Context, name string, localVarOptionals *ApplicationTemplateGetOpts) (ApplicationTemplate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ApplicationTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/application/templates/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.QueryEscape(parameterToString(name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ApplicationTemplate
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
