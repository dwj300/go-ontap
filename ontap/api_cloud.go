/*
 * ONTAP REST API
 *
 * ONTAP 9.6 adds support for an expansive RESTful API. The documentation below provides information about the types of API calls available to you, as well as details about using each API endpoint. You can learn more about the ONTAP REST API and ONTAP in the ONTAP 9 Documentation Center:  http://docs.netapp.com/ontap-9/topic/com.netapp.doc.dot-rest-api/home.html. NetApp welcomes your comments and suggestions about the ONTAP REST API and the documentation for its use.</br> **Using the ONTAP 9.6 REST API online documentation** Each API method includes usage examples, as well as a model that displays all the required and optional properties supported by the method. Click the _Model_ link, available with each API method, to see all the required and optional properties supported by each method.
 *
 * API version: v1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package ontap

import (
	_context "context"
	"github.com/antihax/optional"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// CloudApiService CloudApi service
type CloudApiService service

// CloudTargetCollectionGetOpts Optional parameters for the method 'CloudTargetCollectionGet'
type CloudTargetCollectionGetOpts struct {
	Name                         optional.String
	SvmUuid                      optional.String
	SvmName                      optional.String
	AuthenticationType           optional.String
	Port                         optional.Int32
	Used                         optional.Int32
	CapUrl                       optional.String
	SnapmirrorUse                optional.String
	IpspaceUuid                  optional.String
	IpspaceName                  optional.String
	AzureAccount                 optional.String
	Owner                        optional.String
	Container                    optional.String
	Server                       optional.String
	Uuid                         optional.String
	SslEnabled                   optional.Bool
	CertificateValidationEnabled optional.Bool
	ProviderType                 optional.String
	AccessKey                    optional.String
	Fields                       optional.Interface
	MaxRecords                   optional.Int32
	ReturnRecords                optional.Bool
	ReturnTimeout                optional.Int32
	OrderBy                      optional.Interface
}

/*
CloudTargetCollectionGet Method for CloudTargetCollectionGet
Retrieves the collection of cloud targets in the cluster. ### Related ONTAP commands * &#x60;storage aggregate object-store config show&#x60;  ### Learn more * [&#x60;DOC /cloud/targets&#x60;](#docs-cloud-cloud_targets)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *CloudTargetCollectionGetOpts - Optional Parameters:
 * @param "Name" (optional.String) -  Filter by name
 * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
 * @param "SvmName" (optional.String) -  Filter by svm.name
 * @param "AuthenticationType" (optional.String) -  Filter by authentication_type
 * @param "Port" (optional.Int32) -  Filter by port
 * @param "Used" (optional.Int32) -  Filter by used
 * @param "CapUrl" (optional.String) -  Filter by cap_url
 * @param "SnapmirrorUse" (optional.String) -  Filter by snapmirror_use
 * @param "IpspaceUuid" (optional.String) -  Filter by ipspace.uuid
 * @param "IpspaceName" (optional.String) -  Filter by ipspace.name
 * @param "AzureAccount" (optional.String) -  Filter by azure_account
 * @param "Owner" (optional.String) -  Filter by owner
 * @param "Container" (optional.String) -  Filter by container
 * @param "Server" (optional.String) -  Filter by server
 * @param "Uuid" (optional.String) -  Filter by uuid
 * @param "SslEnabled" (optional.Bool) -  Filter by ssl_enabled
 * @param "CertificateValidationEnabled" (optional.Bool) -  Filter by certificate_validation_enabled
 * @param "ProviderType" (optional.String) -  Filter by provider_type
 * @param "AccessKey" (optional.String) -  Filter by access_key
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return CloudTargetResponse
*/
func (a *CloudApiService) CloudTargetCollectionGet(ctx _context.Context, localVarOptionals *CloudTargetCollectionGetOpts) (CloudTargetResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CloudTargetResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cloud/targets"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AuthenticationType.IsSet() {
		localVarQueryParams.Add("authentication_type", parameterToString(localVarOptionals.AuthenticationType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Port.IsSet() {
		localVarQueryParams.Add("port", parameterToString(localVarOptionals.Port.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Used.IsSet() {
		localVarQueryParams.Add("used", parameterToString(localVarOptionals.Used.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CapUrl.IsSet() {
		localVarQueryParams.Add("cap_url", parameterToString(localVarOptionals.CapUrl.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnapmirrorUse.IsSet() {
		localVarQueryParams.Add("snapmirror_use", parameterToString(localVarOptionals.SnapmirrorUse.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IpspaceUuid.IsSet() {
		localVarQueryParams.Add("ipspace.uuid", parameterToString(localVarOptionals.IpspaceUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IpspaceName.IsSet() {
		localVarQueryParams.Add("ipspace.name", parameterToString(localVarOptionals.IpspaceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AzureAccount.IsSet() {
		localVarQueryParams.Add("azure_account", parameterToString(localVarOptionals.AzureAccount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Owner.IsSet() {
		localVarQueryParams.Add("owner", parameterToString(localVarOptionals.Owner.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Container.IsSet() {
		localVarQueryParams.Add("container", parameterToString(localVarOptionals.Container.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Server.IsSet() {
		localVarQueryParams.Add("server", parameterToString(localVarOptionals.Server.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SslEnabled.IsSet() {
		localVarQueryParams.Add("ssl_enabled", parameterToString(localVarOptionals.SslEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CertificateValidationEnabled.IsSet() {
		localVarQueryParams.Add("certificate_validation_enabled", parameterToString(localVarOptionals.CertificateValidationEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderType.IsSet() {
		localVarQueryParams.Add("provider_type", parameterToString(localVarOptionals.ProviderType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccessKey.IsSet() {
		localVarQueryParams.Add("access_key", parameterToString(localVarOptionals.AccessKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v CloudTargetResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// CloudTargetCreateOpts Optional parameters for the method 'CloudTargetCreate'
type CloudTargetCreateOpts struct {
	IgnoreWarnings optional.Bool
	CheckOnly      optional.Bool
	Info           optional.Interface
}

/*
CloudTargetCreate Method for CloudTargetCreate
Creates a cloud target. ### Required properties * &#x60;name&#x60; - Name for the cloud target. * &#x60;owner&#x60; - Owner of the target: _fabricpool_, _snapmirror_. * &#x60;provider_type&#x60; - Type of cloud provider: _AWS_S3_, _Azure_Cloud_, _SGWS_, _IBM_COS_, _AliCloud_, _GoogleCloud_. * &#x60;server&#x60; - Fully qualified domain name of the object store server. Required when &#x60;provider_type&#x60; is one of the following: _SGWS_, _IBM_COS_, _AliCloud_. * &#x60;container&#x60; - Data bucket/container name. * &#x60;access_key&#x60; - Access key ID if &#x60;provider_type&#x60; is not _Azure_Cloud_ and &#x60;authentication_type&#x60; is _key_. * &#x60;secret_password&#x60; - Secret access key if &#x60;provider_type&#x60; is not _Azure_Cloud_ and &#x60;authentication_type&#x60; is _key_. * &#x60;azure_account&#x60; - Azure account if &#x60;provider_type&#x60; is _Azure_Cloud_. * &#x60;azure_private_key&#x60; - Azure access key if &#x60;provider_type&#x60; is _Azure_Cloud_. * &#x60;cap_url&#x60; - Full URL of the request to a CAP server for retrieving temporary credentials if &#x60;authentication_type&#x60; is _cap_. * &#x60;svm.name&#x60; or &#x60;svm.uuid&#x60; - Name or UUID of SVM if &#x60;owner&#x60; is _snapmirror_. * &#x60;snapmirror_use&#x60; - Use of the cloud target if &#x60;owner&#x60; is _snapmirror_: data, metadata. ### Recommended optional properties * &#x60;authentication_type&#x60; - Authentication used to access the target: _key_, _cap_, _ec2_iam_. * &#x60;ssl_enabled&#x60; - SSL/HTTPS enabled or disabled. * &#x60;port&#x60; - Port number of the object store that ONTAP uses when establishing a connection. * &#x60;ipspace&#x60; - IPspace to use in order to reach the cloud target. ### Default property values * &#x60;authentication_type&#x60;   - _ec2_iam_ - if running in Cloud Volumes ONTAP in AWS   - _key_  - in all other cases. * &#x60;server&#x60;   - _s3.amazonaws.com_ - if &#x60;provider_type&#x60; is _AWS_S3_   - _blob.core.windows.net_ - if &#x60;provider_type&#x60; is _Azure_Cloud_   - _storage.googleapis.com_ - if &#x60;provider_type&#x60; is _GoogleCloud_ * &#x60;ssl_enabled&#x60; - _true_ * &#x60;port&#x60;   - _443_ if &#x60;ssl_enabled&#x60; is _true_ and &#x60;provider_type&#x60; is not _SGWS_   - _8082_ if &#x60;ssl_enabled&#x60; is _true_ and &#x60;provider_type&#x60; is _SGWS_   - _80_ if &#x60;ssl_enabled&#x60; is _false_ and &#x60;provider_type&#x60; is not _SGWS_   - _8084_ if &#x60;ssl_enabled&#x60; is _false_ and &#x60;provider_type&#x60; is _SGWS_ * &#x60;ipspace&#x60; - _Default_ * &#x60;certificate_validation_enabled&#x60; - _true_ * &#x60;ignore_warnings&#x60; - _false_ * &#x60;check_only&#x60; - _false_ ### Related ONTAP commands * &#x60;storage aggregate object-store config create&#x60;  ### Learn more * [&#x60;DOC /cloud/targets&#x60;](#docs-cloud-cloud_targets)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *CloudTargetCreateOpts - Optional Parameters:
 * @param "IgnoreWarnings" (optional.Bool) -  Specifies whether or not warning codes should be ignored.
 * @param "CheckOnly" (optional.Bool) -  Do not create the target configuration, only check that the POST request succeeds.
 * @param "Info" (optional.Interface of CloudTarget) -  Info specification
@return JobLinkResponse
*/
func (a *CloudApiService) CloudTargetCreate(ctx _context.Context, localVarOptionals *CloudTargetCreateOpts) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cloud/targets"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IgnoreWarnings.IsSet() {
		localVarQueryParams.Add("ignore_warnings", parameterToString(localVarOptionals.IgnoreWarnings.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CheckOnly.IsSet() {
		localVarQueryParams.Add("check_only", parameterToString(localVarOptionals.CheckOnly.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(CloudTarget)
		if !localVarOptionalInfook {
			return localVarReturnValue, nil, reportError("info should be CloudTarget")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
CloudTargetDelete Method for CloudTargetDelete
Deletes the cloud target specified by the UUID. This request starts a job and returns a link to that job. ### Related ONTAP commands * &#x60;storage aggregate object-store config delete&#x60;  ### Learn more * [&#x60;DOC /cloud/targets&#x60;](#docs-cloud-cloud_targets)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Cloud target UUID
@return JobLinkResponse
*/
func (a *CloudApiService) CloudTargetDelete(ctx _context.Context, uuid string) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cloud/targets/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// CloudTargetGetOpts Optional parameters for the method 'CloudTargetGet'
type CloudTargetGetOpts struct {
	Fields optional.Interface
}

/*
CloudTargetGet Method for CloudTargetGet
Retrieves the cloud target specified by the UUID. ### Related ONTAP commands * &#x60;storage aggregate object-store config show&#x60;  ### Learn more * [&#x60;DOC /cloud/targets&#x60;](#docs-cloud-cloud_targets)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Cloud target UUID
 * @param optional nil or *CloudTargetGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return CloudTarget
*/
func (a *CloudApiService) CloudTargetGet(ctx _context.Context, uuid string, localVarOptionals *CloudTargetGetOpts) (CloudTarget, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CloudTarget
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cloud/targets/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v CloudTarget
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// CloudTargetModifyOpts Optional parameters for the method 'CloudTargetModify'
type CloudTargetModifyOpts struct {
	IgnoreWarnings optional.Bool
	CheckOnly      optional.Bool
	Info           optional.Interface
}

/*
CloudTargetModify Method for CloudTargetModify
Updates the cloud target specified by the UUID with the fields in the body. This request starts a job and returns a link to that job. ### Related ONTAP commands * &#x60;storage aggregate object-store config modify&#x60;  ### Learn more * [&#x60;DOC /cloud/targets&#x60;](#docs-cloud-cloud_targets)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Cloud target UUID
 * @param optional nil or *CloudTargetModifyOpts - Optional Parameters:
 * @param "IgnoreWarnings" (optional.Bool) -  Specifies whether or not warnings should be ignored.
 * @param "CheckOnly" (optional.Bool) -  Do not modify the configuration, only check that the PATCH request succeeds.
 * @param "Info" (optional.Interface of CloudTarget) -  Info specification
@return JobLinkResponse
*/
func (a *CloudApiService) CloudTargetModify(ctx _context.Context, uuid string, localVarOptionals *CloudTargetModifyOpts) (JobLinkResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/cloud/targets/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", _neturl.QueryEscape(parameterToString(uuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.IgnoreWarnings.IsSet() {
		localVarQueryParams.Add("ignore_warnings", parameterToString(localVarOptionals.IgnoreWarnings.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CheckOnly.IsSet() {
		localVarQueryParams.Add("check_only", parameterToString(localVarOptionals.CheckOnly.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(CloudTarget)
		if !localVarOptionalInfook {
			return localVarReturnValue, nil, reportError("info should be CloudTarget")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		var v ErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
