/*
 * ONTAP REST API
 *
 * ONTAP 9.6 adds support for an expansive RESTful API. The documentation below provides information about the types of API calls available to you, as well as details about using each API endpoint. You can learn more about the ONTAP REST API and ONTAP in the ONTAP 9 Documentation Center:  http://docs.netapp.com/ontap-9/topic/com.netapp.doc.dot-rest-api/home.html. NetApp welcomes your comments and suggestions about the ONTAP REST API and the documentation for its use.</br> **Using the ONTAP 9.6 REST API online documentation** Each API method includes usage examples, as well as a model that displays all the required and optional properties supported by the method. Click the _Model_ link, available with each API method, to see all the required and optional properties supported by each method. 
 *
 * API version: v1
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type SANApiService service

/* 
SANApiService
Retrieves FC logins. ### Related ONTAP commands * &#x60;vserver fcp initiator show&#x60; ### Learn more * SAN: [&#x60;DOC /network/fc/logins&#x60;](#docs-SAN-network_fc_logins) * NVMe: [&#x60;DOC /network/fc/logins&#x60;](#docs-NVMe-network_fc_logins) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *FcLoginCollectionGetOpts - Optional Parameters:
     * @param "Protocol" (optional.String) -  Filter by protocol
     * @param "InitiatorPortAddress" (optional.String) -  Filter by initiator.port_address
     * @param "InitiatorWwpn" (optional.String) -  Filter by initiator.wwpn
     * @param "InitiatorWwnn" (optional.String) -  Filter by initiator.wwnn
     * @param "InitiatorAliases" (optional.String) -  Filter by initiator.aliases
     * @param "IgroupsUuid" (optional.String) -  Filter by igroups.uuid
     * @param "IgroupsName" (optional.String) -  Filter by igroups.name
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "InterfaceName" (optional.String) -  Filter by interface.name
     * @param "InterfaceWwpn" (optional.String) -  Filter by interface.wwpn
     * @param "InterfaceUuid" (optional.String) -  Filter by interface.uuid
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return FcLoginResponse
*/

type FcLoginCollectionGetOpts struct { 
	Protocol optional.String
	InitiatorPortAddress optional.String
	InitiatorWwpn optional.String
	InitiatorWwnn optional.String
	InitiatorAliases optional.String
	IgroupsUuid optional.String
	IgroupsName optional.String
	SvmUuid optional.String
	SvmName optional.String
	InterfaceName optional.String
	InterfaceWwpn optional.String
	InterfaceUuid optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *SANApiService) FcLoginCollectionGet(ctx context.Context, localVarOptionals *FcLoginCollectionGetOpts) (FcLoginResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FcLoginResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/fc/logins"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Protocol.IsSet() {
		localVarQueryParams.Add("protocol", parameterToString(localVarOptionals.Protocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitiatorPortAddress.IsSet() {
		localVarQueryParams.Add("initiator.port_address", parameterToString(localVarOptionals.InitiatorPortAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitiatorWwpn.IsSet() {
		localVarQueryParams.Add("initiator.wwpn", parameterToString(localVarOptionals.InitiatorWwpn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitiatorWwnn.IsSet() {
		localVarQueryParams.Add("initiator.wwnn", parameterToString(localVarOptionals.InitiatorWwnn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitiatorAliases.IsSet() {
		localVarQueryParams.Add("initiator.aliases", parameterToString(localVarOptionals.InitiatorAliases.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IgroupsUuid.IsSet() {
		localVarQueryParams.Add("igroups.uuid", parameterToString(localVarOptionals.IgroupsUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IgroupsName.IsSet() {
		localVarQueryParams.Add("igroups.name", parameterToString(localVarOptionals.IgroupsName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InterfaceName.IsSet() {
		localVarQueryParams.Add("interface.name", parameterToString(localVarOptionals.InterfaceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InterfaceWwpn.IsSet() {
		localVarQueryParams.Add("interface.wwpn", parameterToString(localVarOptionals.InterfaceWwpn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InterfaceUuid.IsSet() {
		localVarQueryParams.Add("interface.uuid", parameterToString(localVarOptionals.InterfaceUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FcLoginResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SANApiService
Retrieves an FC login. ### Related ONTAP commands * &#x60;vserver fcp initiator show&#x60; ### Learn more * SAN: [&#x60;DOC /network/fc/logins&#x60;](#docs-SAN-network_fc_logins) * NVMe: [&#x60;DOC /network/fc/logins&#x60;](#docs-NVMe-network_fc_logins) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param interfaceUuid The unique identifier of the FC interface through which the initiator logged in. 
 * @param initiatorWwpn The world wide port name (WWPN) of the initiator. 
 * @param optional nil or *FcLoginGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return FcLogin
*/

type FcLoginGetOpts struct { 
	Fields optional.Interface
}

func (a *SANApiService) FcLoginGet(ctx context.Context, interfaceUuid string, initiatorWwpn string, localVarOptionals *FcLoginGetOpts) (FcLogin, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FcLogin
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/fc/logins/{interface.uuid}/{initiator.wwpn}"
	localVarPath = strings.Replace(localVarPath, "{"+"interface.uuid"+"}", fmt.Sprintf("%v", interfaceUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"initiator.wwpn"+"}", fmt.Sprintf("%v", initiatorWwpn), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FcLogin
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SANApiService
Retrieves FC Protocol services. ### Related ONTAP commands * &#x60;vserver fcp show&#x60; ### Learn more * [&#x60;DOC /protocols/san/fcp/services&#x60;](#docs-SAN-protocols_san_fcp_services) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *FcpServiceCollectionGetOpts - Optional Parameters:
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "TargetName" (optional.String) -  Filter by target.name
     * @param "Enabled" (optional.Bool) -  Filter by enabled
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return FcpServiceResponse
*/

type FcpServiceCollectionGetOpts struct { 
	SvmUuid optional.String
	SvmName optional.String
	TargetName optional.String
	Enabled optional.Bool
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *SANApiService) FcpServiceCollectionGet(ctx context.Context, localVarOptionals *FcpServiceCollectionGetOpts) (FcpServiceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FcpServiceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/fcp/services"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TargetName.IsSet() {
		localVarQueryParams.Add("target.name", parameterToString(localVarOptionals.TargetName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarQueryParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FcpServiceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SANApiService
Creates an FC Protocol service. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the FC service. ### Related ONTAP commands * &#x60;vserver fcp create&#x60; ### Learn more * [&#x60;DOC /protocols/san/fcp/services&#x60;](#docs-SAN-protocols_san_fcp_services) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info The property values for the new FC Protocol service. 

@return FcpServiceResponse
*/
func (a *SANApiService) FcpServiceCreate(ctx context.Context, info FcpService) (FcpServiceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FcpServiceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/fcp/services"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v FcpServiceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SANApiService
Deletes an FC Protocol service. An FC Protocol service must be disabled before it can be deleted. ### Related ONTAP commands * &#x60;vserver fcp delete&#x60; ### Learn more * [&#x60;DOC /protocols/san/fcp/services&#x60;](#docs-SAN-protocols_san_fcp_services) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid The unique identifier of the SVM for which to delete the FC Protocol service. 


*/
func (a *SANApiService) FcpServiceDelete(ctx context.Context, svmUuid string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/fcp/services/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
SANApiService
Retrieves a Fibre Channel Protocol service. ### Related ONTAP commands * &#x60;vserver fcp show&#x60; ### Learn more * [&#x60;DOC /protocols/san/fcp/services&#x60;](#docs-SAN-protocols_san_fcp_services) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid The unique identifier of the SVM for which to retrieve the FC Protocol service. 
 * @param optional nil or *FcpServiceGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return FcpService
*/

type FcpServiceGetOpts struct { 
	Fields optional.Interface
}

func (a *SANApiService) FcpServiceGet(ctx context.Context, svmUuid string, localVarOptionals *FcpServiceGetOpts) (FcpService, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FcpService
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/fcp/services/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FcpService
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SANApiService
Updates an FC Protocol service. ### Related ONTAP commands * &#x60;vserver fcp modify&#x60; * &#x60;vserver fcp start&#x60; * &#x60;vserver fcp stop&#x60; ### Learn more * [&#x60;DOC /protocols/san/fcp/services&#x60;](#docs-SAN-protocols_san_fcp_services) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid The unique identifier of the SVM whose FC Protocol service is to be patched. 
 * @param info The new property values for the FC Protocol service. 


*/
func (a *SANApiService) FcpServiceModify(ctx context.Context, svmUuid string, info FcpService) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/fcp/services/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
SANApiService
Retrieves initiator groups. ### Expensive properties There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the &#x60;fields&#x60; query parameter. See [&#x60;DOC Requesting specific fields&#x60;](#docs-docs-Requesting-specific-fields) to learn more. * &#x60;lun_maps.*&#x60; ### Related ONTAP commands * &#x60;lun igroup show&#x60; * &#x60;lun mapping show&#x60; ### Learn more * [&#x60;DOC /protocols/san/igroups&#x60;](#docs-SAN-protocols_san_igroups) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *IgroupCollectionGetOpts - Optional Parameters:
     * @param "DeleteOnUnmap" (optional.Bool) -  Filter by delete_on_unmap
     * @param "Protocol" (optional.String) -  Filter by protocol
     * @param "LunMapsLogicalUnitNumber" (optional.Int32) -  Filter by lun_maps.logical_unit_number
     * @param "LunMapsLunNodeUuid" (optional.String) -  Filter by lun_maps.lun.node.uuid
     * @param "LunMapsLunNodeName" (optional.String) -  Filter by lun_maps.lun.node.name
     * @param "LunMapsLunUuid" (optional.String) -  Filter by lun_maps.lun.uuid
     * @param "LunMapsLunName" (optional.String) -  Filter by lun_maps.lun.name
     * @param "InitiatorsIgroupUuid" (optional.String) -  Filter by initiators.igroup.uuid
     * @param "InitiatorsName" (optional.String) -  Filter by initiators.name
     * @param "Uuid" (optional.String) -  Filter by uuid
     * @param "OsType" (optional.String) -  Filter by os_type
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "Name" (optional.String) -  Filter by name
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return IgroupResponse
*/

type IgroupCollectionGetOpts struct { 
	DeleteOnUnmap optional.Bool
	Protocol optional.String
	LunMapsLogicalUnitNumber optional.Int32
	LunMapsLunNodeUuid optional.String
	LunMapsLunNodeName optional.String
	LunMapsLunUuid optional.String
	LunMapsLunName optional.String
	InitiatorsIgroupUuid optional.String
	InitiatorsName optional.String
	Uuid optional.String
	OsType optional.String
	SvmUuid optional.String
	SvmName optional.String
	Name optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *SANApiService) IgroupCollectionGet(ctx context.Context, localVarOptionals *IgroupCollectionGetOpts) (IgroupResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue IgroupResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/igroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.DeleteOnUnmap.IsSet() {
		localVarQueryParams.Add("delete_on_unmap", parameterToString(localVarOptionals.DeleteOnUnmap.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Protocol.IsSet() {
		localVarQueryParams.Add("protocol", parameterToString(localVarOptionals.Protocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LunMapsLogicalUnitNumber.IsSet() {
		localVarQueryParams.Add("lun_maps.logical_unit_number", parameterToString(localVarOptionals.LunMapsLogicalUnitNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LunMapsLunNodeUuid.IsSet() {
		localVarQueryParams.Add("lun_maps.lun.node.uuid", parameterToString(localVarOptionals.LunMapsLunNodeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LunMapsLunNodeName.IsSet() {
		localVarQueryParams.Add("lun_maps.lun.node.name", parameterToString(localVarOptionals.LunMapsLunNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LunMapsLunUuid.IsSet() {
		localVarQueryParams.Add("lun_maps.lun.uuid", parameterToString(localVarOptionals.LunMapsLunUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LunMapsLunName.IsSet() {
		localVarQueryParams.Add("lun_maps.lun.name", parameterToString(localVarOptionals.LunMapsLunName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitiatorsIgroupUuid.IsSet() {
		localVarQueryParams.Add("initiators.igroup.uuid", parameterToString(localVarOptionals.InitiatorsIgroupUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitiatorsName.IsSet() {
		localVarQueryParams.Add("initiators.name", parameterToString(localVarOptionals.InitiatorsName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OsType.IsSet() {
		localVarQueryParams.Add("os_type", parameterToString(localVarOptionals.OsType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v IgroupResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SANApiService
Creates an initiator group. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the initiator group. * &#x60;name&#x60; - Name of the initiator group. * &#x60;os_type&#x60; - Operating system of the initiator group&#39;s initiators. ### Recommended optional properties * &#x60;initiators.name&#x60; - Name(s) of initiator group&#39;s initiators. This property can be used to create the initiator group and populate it with initiators in a single request. ### Default property values If not specified in POST, the following default property values are assigned. * &#x60;protocol&#x60; - _mixed_ - Data protocol of the initiator group&#39;s initiators. ### Learn more * [&#x60;DOC /protocols/san/igroups&#x60;](#docs-SAN-protocols_san_igroups) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info The property values for the new initiator group. 

@return IgroupResponse
*/
func (a *SANApiService) IgroupCreate(ctx context.Context, info Igroup) (IgroupResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue IgroupResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/igroups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v IgroupResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SANApiService
Deletes an initiator group. ### Related ONTAP commands * &#x60;lun igroup delete&#x60; ### Learn more * [&#x60;DOC /protocols/san/igroups&#x60;](#docs-SAN-protocols_san_igroups) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid The unique identifier of the initiator group. 
 * @param optional nil or *IgroupDeleteOpts - Optional Parameters:
     * @param "AllowDeleteWhileMapped" (optional.Bool) -  Allow deletion of a mapped initiator group.&lt;br/&gt; Deleting a mapped initiator group makes the LUNs to which the initiator group is mapped no longer available. This might cause a disruption in the availability of data.&lt;br/&gt; &lt;b&gt;This parameter should be used with caution.&lt;/b&gt; 


*/

type IgroupDeleteOpts struct { 
	AllowDeleteWhileMapped optional.Bool
}

func (a *SANApiService) IgroupDelete(ctx context.Context, uuid string, localVarOptionals *IgroupDeleteOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/igroups/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AllowDeleteWhileMapped.IsSet() {
		localVarQueryParams.Add("allow_delete_while_mapped", parameterToString(localVarOptionals.AllowDeleteWhileMapped.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
SANApiService
Retrieves an initiator group. ### Expensive properties There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the &#x60;fields&#x60; query parameter. See [&#x60;DOC Requesting specific fields&#x60;](#docs-docs-Requesting-specific-fields) to learn more. * &#x60;lun_maps.*&#x60; ### Related ONTAP commands * &#x60;lun igroup show&#x60; * &#x60;lun mapping show&#x60; ### Learn more * [&#x60;DOC /protocols/san/igroups&#x60;](#docs-SAN-protocols_san_igroups) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid The unique identifier of the initiator group. 
 * @param optional nil or *IgroupGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return Igroup
*/

type IgroupGetOpts struct { 
	Fields optional.Interface
}

func (a *SANApiService) IgroupGet(ctx context.Context, uuid string, localVarOptionals *IgroupGetOpts) (Igroup, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Igroup
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/igroups/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Igroup
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SANApiService
Retrieves initiators of an initiator group. ### Related ONTAP commands * &#x60;lun igroup show&#x60; ### Learn more * [&#x60;DOC /protocols/san/igroups&#x60;](#docs-SAN-protocols_san_igroups) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param igroupUuid The unique identifier of the initiator group. 
 * @param optional nil or *IgroupInitiatorCollectionGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return IgroupInitiatorResponse
*/

type IgroupInitiatorCollectionGetOpts struct { 
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *SANApiService) IgroupInitiatorCollectionGet(ctx context.Context, igroupUuid string, localVarOptionals *IgroupInitiatorCollectionGetOpts) (IgroupInitiatorResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue IgroupInitiatorResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/igroups/{igroup.uuid}/initiators"
	localVarPath = strings.Replace(localVarPath, "{"+"igroup.uuid"+"}", fmt.Sprintf("%v", igroupUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v IgroupInitiatorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SANApiService
Adds one or more initiators to an initiator group. ### Required properties * &#x60;name&#x60; or &#x60;records.name&#x60; - Initiator name(s) to add to the initiator group. ### Related ONTAP commands * &#x60;lun igroup add&#x60; ### Learn more * [&#x60;DOC /protocols/san/igroups&#x60;](#docs-SAN-protocols_san_igroups) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param igroupUuid The unique identifier of the initiator group. 
 * @param info The properties of the initiator to add to the initiator group. 

@return IgroupInitiatorResponse
*/
func (a *SANApiService) IgroupInitiatorCreate(ctx context.Context, igroupUuid string, info IgroupInitiator) (IgroupInitiatorResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue IgroupInitiatorResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/igroups/{igroup.uuid}/initiators"
	localVarPath = strings.Replace(localVarPath, "{"+"igroup.uuid"+"}", fmt.Sprintf("%v", igroupUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v IgroupInitiatorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SANApiService
Deletes an initiator from an initiator group. ### Related ONTAP commands * &#x60;lun igroup remove&#x60; ### Learn more * [&#x60;DOC /protocols/san/igroups&#x60;](#docs-SAN-protocols_san_igroups) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param igroupUuid The unique identifier of the initiator group. 
 * @param name The initiator name. 
 * @param optional nil or *IgroupInitiatorDeleteOpts - Optional Parameters:
     * @param "AllowDeleteWhileMapped" (optional.Bool) -  Allow deletion of an initiator from of a mapped initiator group.&lt;br/&gt; Deleting an initiator from a mapped initiator group makes the LUNs to which the initiator group is mapped no longer available to the initiator. This might cause a disruption in the availability of data.&lt;br/&gt; &lt;b&gt;This parameter should be used with caution.&lt;/b&gt; 


*/

type IgroupInitiatorDeleteOpts struct { 
	AllowDeleteWhileMapped optional.Bool
}

func (a *SANApiService) IgroupInitiatorDelete(ctx context.Context, igroupUuid string, name string, localVarOptionals *IgroupInitiatorDeleteOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/igroups/{igroup.uuid}/initiators/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"igroup.uuid"+"}", fmt.Sprintf("%v", igroupUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AllowDeleteWhileMapped.IsSet() {
		localVarQueryParams.Add("allow_delete_while_mapped", parameterToString(localVarOptionals.AllowDeleteWhileMapped.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
SANApiService
Retrieves an initiator of an initiator group. ### Related ONTAP commands * &#x60;lun igroup show&#x60; ### Learn more * [&#x60;DOC /protocols/san/igroups&#x60;](#docs-SAN-protocols_san_igroups) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param igroupUuid The unique identifier of the initiator group. 
 * @param name The initiator name. 
 * @param optional nil or *IgroupInitiatorGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return IgroupInitiator
*/

type IgroupInitiatorGetOpts struct { 
	Fields optional.Interface
}

func (a *SANApiService) IgroupInitiatorGet(ctx context.Context, igroupUuid string, name string, localVarOptionals *IgroupInitiatorGetOpts) (IgroupInitiator, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue IgroupInitiator
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/igroups/{igroup.uuid}/initiators/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"igroup.uuid"+"}", fmt.Sprintf("%v", igroupUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v IgroupInitiator
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SANApiService
Updates an initiator group. ### Related ONTAP commands * &#x60;lun igroup modify&#x60; * &#x60;lun igroup rename&#x60; ### Learn more * [&#x60;DOC /protocols/san/igroups&#x60;](#docs-SAN-protocols_san_igroups) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid The unique identifier of the initiator group. 
 * @param info The new property values for the initiator group. 


*/
func (a *SANApiService) IgroupModify(ctx context.Context, uuid string, info Igroup) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/igroups/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
SANApiService
Retrieves iSCSI credentials. ### Related ONTAP commands * &#x60;vserver iscsi security show&#x60; ### Learn more * [&#x60;DOC /protocols/san/iscsi/credentials&#x60;](#docs-SAN-protocols_san_iscsi_credentials) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *IscsiCredentialsCollectionGetOpts - Optional Parameters:
     * @param "InitiatorAddressMasksAddress" (optional.String) -  Filter by initiator_address.masks.address
     * @param "InitiatorAddressMasksNetmask" (optional.String) -  Filter by initiator_address.masks.netmask
     * @param "InitiatorAddressMasksFamily" (optional.String) -  Filter by initiator_address.masks.family
     * @param "InitiatorAddressRangesFamily" (optional.String) -  Filter by initiator_address.ranges.family
     * @param "InitiatorAddressRangesStart" (optional.String) -  Filter by initiator_address.ranges.start
     * @param "InitiatorAddressRangesEnd" (optional.String) -  Filter by initiator_address.ranges.end
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "Initiator" (optional.String) -  Filter by initiator
     * @param "AuthenticationType" (optional.String) -  Filter by authentication_type
     * @param "ChapInboundUser" (optional.String) -  Filter by chap.inbound.user
     * @param "ChapOutboundUser" (optional.String) -  Filter by chap.outbound.user
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return IscsiCredentialsResponse
*/

type IscsiCredentialsCollectionGetOpts struct { 
	InitiatorAddressMasksAddress optional.String
	InitiatorAddressMasksNetmask optional.String
	InitiatorAddressMasksFamily optional.String
	InitiatorAddressRangesFamily optional.String
	InitiatorAddressRangesStart optional.String
	InitiatorAddressRangesEnd optional.String
	SvmUuid optional.String
	SvmName optional.String
	Initiator optional.String
	AuthenticationType optional.String
	ChapInboundUser optional.String
	ChapOutboundUser optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *SANApiService) IscsiCredentialsCollectionGet(ctx context.Context, localVarOptionals *IscsiCredentialsCollectionGetOpts) (IscsiCredentialsResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue IscsiCredentialsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/iscsi/credentials"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.InitiatorAddressMasksAddress.IsSet() {
		localVarQueryParams.Add("initiator_address.masks.address", parameterToString(localVarOptionals.InitiatorAddressMasksAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitiatorAddressMasksNetmask.IsSet() {
		localVarQueryParams.Add("initiator_address.masks.netmask", parameterToString(localVarOptionals.InitiatorAddressMasksNetmask.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitiatorAddressMasksFamily.IsSet() {
		localVarQueryParams.Add("initiator_address.masks.family", parameterToString(localVarOptionals.InitiatorAddressMasksFamily.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitiatorAddressRangesFamily.IsSet() {
		localVarQueryParams.Add("initiator_address.ranges.family", parameterToString(localVarOptionals.InitiatorAddressRangesFamily.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitiatorAddressRangesStart.IsSet() {
		localVarQueryParams.Add("initiator_address.ranges.start", parameterToString(localVarOptionals.InitiatorAddressRangesStart.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitiatorAddressRangesEnd.IsSet() {
		localVarQueryParams.Add("initiator_address.ranges.end", parameterToString(localVarOptionals.InitiatorAddressRangesEnd.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Initiator.IsSet() {
		localVarQueryParams.Add("initiator", parameterToString(localVarOptionals.Initiator.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AuthenticationType.IsSet() {
		localVarQueryParams.Add("authentication_type", parameterToString(localVarOptionals.AuthenticationType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChapInboundUser.IsSet() {
		localVarQueryParams.Add("chap.inbound.user", parameterToString(localVarOptionals.ChapInboundUser.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChapOutboundUser.IsSet() {
		localVarQueryParams.Add("chap.outbound.user", parameterToString(localVarOptionals.ChapOutboundUser.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v IscsiCredentialsResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SANApiService
Creates iSCSI credentials. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the iSCSI credentials. * &#x60;initiator&#x60; - Initiator for which the iSCSI credentials are to be created. * &#x60;authentication_type&#x60; - Type of authentication to use for the credentials. ### Recommended optional properties * &#x60;chap.inbound.user&#x60; - In-bound CHAP authentication user name. * &#x60;chap.inbound.password&#x60; - In-bound CHAP authentication password. * &#x60;chap.outbound.user&#x60; - Out-bound CHAP authentication user name. * &#x60;chap.outbound.password&#x60; - Out-bound CHAP authentication password. ### Related ONTAP commands * &#x60;vserver iscsi security create&#x60; ### Learn more * [&#x60;DOC /protocols/san/iscsi/credentials&#x60;](#docs-SAN-protocols_san_iscsi_credentials) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info The property values for the new iSCSI credentials object. 

@return IscsiCredentialsResponse
*/
func (a *SANApiService) IscsiCredentialsCreate(ctx context.Context, info IscsiCredentials) (IscsiCredentialsResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue IscsiCredentialsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/iscsi/credentials"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v IscsiCredentialsResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SANApiService
Deletes specified iSCSI credentials. ### Related ONTAP commands * &#x60;vserver iscsi security delete&#x60; ### Learn more * [&#x60;DOC /protocols/san/iscsi/credentials&#x60;](#docs-SAN-protocols_san_iscsi_credentials) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid The unique identifier of an SVM. 
 * @param initiator The iSCSI initiator of the credentials object. 


*/
func (a *SANApiService) IscsiCredentialsDelete(ctx context.Context, svmUuid string, initiator string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/iscsi/credentials/{svm.uuid}/{initiator}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"initiator"+"}", fmt.Sprintf("%v", initiator), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
SANApiService
Retrieves specified iSCSI credentials. ### Related ONTAP commands * &#x60;vserver iscsi security show&#x60; ### Learn more * [&#x60;DOC /protocols/san/iscsi/credentials&#x60;](#docs-SAN-protocols_san_iscsi_credentials) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid The unique identifier of an SVM. 
 * @param initiator The iSCSI initiator of the credentials object. 
 * @param optional nil or *IscsiCredentialsGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return IscsiCredentials
*/

type IscsiCredentialsGetOpts struct { 
	Fields optional.Interface
}

func (a *SANApiService) IscsiCredentialsGet(ctx context.Context, svmUuid string, initiator string, localVarOptionals *IscsiCredentialsGetOpts) (IscsiCredentials, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue IscsiCredentials
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/iscsi/credentials/{svm.uuid}/{initiator}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"initiator"+"}", fmt.Sprintf("%v", initiator), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v IscsiCredentials
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SANApiService
Updates specified iSCSI credentials. ### Related ONTAP commands * &#x60;vserver iscsi security add-initiator-address-ranges&#x60; * &#x60;vserver iscsi security default&#x60; * &#x60;vserver iscsi security modify&#x60; * &#x60;vserver iscsi security remove-initiator-address-ranges&#x60; ### Learn more * [&#x60;DOC /protocols/san/iscsi/credentials&#x60;](#docs-SAN-protocols_san_iscsi_credentials) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid The unique identifier of an SVM. 
 * @param initiator The iSCSI initiator of the credentials object. 
 * @param info The new property values for the iSCSI credentials object. 
 * @param optional nil or *IscsiCredentialsModifyOpts - Optional Parameters:
     * @param "AddInitiatorAddresses" (optional.Bool) -  If _true_, the initiator addresses in the body merge into the existing addresses in the iSCSI security object rather than replace the existing addresses. 
     * @param "RemoveInitiatorAddresses" (optional.Bool) -  If _true_, the initiator addresses in the body are removed from the existing addresses in the iSCSI security object rather than replace the existing addresses. 


*/

type IscsiCredentialsModifyOpts struct { 
	AddInitiatorAddresses optional.Bool
	RemoveInitiatorAddresses optional.Bool
}

func (a *SANApiService) IscsiCredentialsModify(ctx context.Context, svmUuid string, initiator string, info IscsiCredentials, localVarOptionals *IscsiCredentialsModifyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/iscsi/credentials/{svm.uuid}/{initiator}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"initiator"+"}", fmt.Sprintf("%v", initiator), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AddInitiatorAddresses.IsSet() {
		localVarQueryParams.Add("add_initiator_addresses", parameterToString(localVarOptionals.AddInitiatorAddresses.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RemoveInitiatorAddresses.IsSet() {
		localVarQueryParams.Add("remove_initiator_addresses", parameterToString(localVarOptionals.RemoveInitiatorAddresses.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
SANApiService
Retrieves iSCSI services. ### Related ONTAP commands * &#x60;vserver iscsi show&#x60; ### Learn more * [&#x60;DOC /protocols/san/iscsi/services&#x60;](#docs-SAN-protocols_san_iscsi_services) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *IscsiServiceCollectionGetOpts - Optional Parameters:
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "Enabled" (optional.Bool) -  Filter by enabled
     * @param "TargetName" (optional.String) -  Filter by target.name
     * @param "TargetAlias" (optional.String) -  Filter by target.alias
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return IscsiServiceResponse
*/

type IscsiServiceCollectionGetOpts struct { 
	SvmUuid optional.String
	SvmName optional.String
	Enabled optional.Bool
	TargetName optional.String
	TargetAlias optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *SANApiService) IscsiServiceCollectionGet(ctx context.Context, localVarOptionals *IscsiServiceCollectionGetOpts) (IscsiServiceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue IscsiServiceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/iscsi/services"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarQueryParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TargetName.IsSet() {
		localVarQueryParams.Add("target.name", parameterToString(localVarOptionals.TargetName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TargetAlias.IsSet() {
		localVarQueryParams.Add("target.alias", parameterToString(localVarOptionals.TargetAlias.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v IscsiServiceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SANApiService
Creates an iSCSI service. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the iSCSI service. ### Related ONTAP commands * &#x60;vserver iscsi create&#x60; ### Learn more * [&#x60;DOC /protocols/san/iscsi/services&#x60;](#docs-SAN-protocols_san_iscsi_services) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info The property values for the new iSCSI service. 

@return IscsiServiceResponse
*/
func (a *SANApiService) IscsiServiceCreate(ctx context.Context, info IscsiService) (IscsiServiceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue IscsiServiceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/iscsi/services"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v IscsiServiceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SANApiService
Deletes an iSCSI service. An iSCSI service must be disabled before it can be deleted. ### Related ONTAP commands * &#x60;vserver iscsi delete&#x60; ### Learn more * [&#x60;DOC /protocols/san/iscsi/services&#x60;](#docs-SAN-protocols_san_iscsi_services) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid The unique identifier of the SVM for which to delete the iSCSI service. 


*/
func (a *SANApiService) IscsiServiceDelete(ctx context.Context, svmUuid string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/iscsi/services/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
SANApiService
Retrieves an iSCSI service. ### Related ONTAP commands * &#x60;vserver iscsi show&#x60; ### Learn more * [&#x60;DOC /protocols/san/iscsi/services&#x60;](#docs-SAN-protocols_san_iscsi_services) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid The unique identifier of the SVM for which to retrieve the iSCSI service. 
 * @param optional nil or *IscsiServiceGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return IscsiService
*/

type IscsiServiceGetOpts struct { 
	Fields optional.Interface
}

func (a *SANApiService) IscsiServiceGet(ctx context.Context, svmUuid string, localVarOptionals *IscsiServiceGetOpts) (IscsiService, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue IscsiService
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/iscsi/services/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v IscsiService
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SANApiService
Updates an iSCSI service. ### Related ONTAP commands * &#x60;vserver iscsi modify&#x60; * &#x60;vserver iscsi start&#x60; * &#x60;vserver iscsi stop&#x60; ### Learn more * [&#x60;DOC /protocols/san/iscsi/services&#x60;](#docs-SAN-protocols_san_iscsi_services) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid The unique identifier of the SVM for which to update the iSCSI service. 
 * @param info The new property values for the iSCSI service. 


*/
func (a *SANApiService) IscsiServiceModify(ctx context.Context, svmUuid string, info IscsiService) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/iscsi/services/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
SANApiService
Retrieves iSCSI sessions. ### Related ONTAP commands * &#x60;vserver iscsi connection show&#x60; * &#x60;vserver iscsi session parameter show&#x60; * &#x60;vserver iscsi session show&#x60; ### Learn more * [&#x60;DOC /protocols/san/iscsi/sessions&#x60;](#docs-SAN-protocols_san_iscsi_sessions) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *IscsiSessionCollectionGetOpts - Optional Parameters:
     * @param "IgroupsUuid" (optional.String) -  Filter by igroups.uuid
     * @param "IgroupsName" (optional.String) -  Filter by igroups.name
     * @param "ConnectionsAuthenticationType" (optional.String) -  Filter by connections.authentication_type
     * @param "ConnectionsCid" (optional.Int32) -  Filter by connections.cid
     * @param "ConnectionsInterfaceIpAddress" (optional.String) -  Filter by connections.interface.ip.address
     * @param "ConnectionsInterfaceIpPort" (optional.Int32) -  Filter by connections.interface.ip.port
     * @param "ConnectionsInterfaceUuid" (optional.String) -  Filter by connections.interface.uuid
     * @param "ConnectionsInterfaceName" (optional.String) -  Filter by connections.interface.name
     * @param "ConnectionsInitiatorAddressPort" (optional.Int32) -  Filter by connections.initiator_address.port
     * @param "ConnectionsInitiatorAddressAddress" (optional.String) -  Filter by connections.initiator_address.address
     * @param "TargetPortalGroup" (optional.String) -  Filter by target_portal_group
     * @param "Tsih" (optional.Int32) -  Filter by tsih
     * @param "InitiatorName" (optional.String) -  Filter by initiator.name
     * @param "InitiatorAlias" (optional.String) -  Filter by initiator.alias
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "Isid" (optional.String) -  Filter by isid
     * @param "TargetPortalGroupTag" (optional.Int32) -  Filter by target_portal_group_tag
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return IscsiSessionResponse
*/

type IscsiSessionCollectionGetOpts struct { 
	IgroupsUuid optional.String
	IgroupsName optional.String
	ConnectionsAuthenticationType optional.String
	ConnectionsCid optional.Int32
	ConnectionsInterfaceIpAddress optional.String
	ConnectionsInterfaceIpPort optional.Int32
	ConnectionsInterfaceUuid optional.String
	ConnectionsInterfaceName optional.String
	ConnectionsInitiatorAddressPort optional.Int32
	ConnectionsInitiatorAddressAddress optional.String
	TargetPortalGroup optional.String
	Tsih optional.Int32
	InitiatorName optional.String
	InitiatorAlias optional.String
	SvmUuid optional.String
	SvmName optional.String
	Isid optional.String
	TargetPortalGroupTag optional.Int32
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *SANApiService) IscsiSessionCollectionGet(ctx context.Context, localVarOptionals *IscsiSessionCollectionGetOpts) (IscsiSessionResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue IscsiSessionResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/iscsi/sessions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.IgroupsUuid.IsSet() {
		localVarQueryParams.Add("igroups.uuid", parameterToString(localVarOptionals.IgroupsUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IgroupsName.IsSet() {
		localVarQueryParams.Add("igroups.name", parameterToString(localVarOptionals.IgroupsName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ConnectionsAuthenticationType.IsSet() {
		localVarQueryParams.Add("connections.authentication_type", parameterToString(localVarOptionals.ConnectionsAuthenticationType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ConnectionsCid.IsSet() {
		localVarQueryParams.Add("connections.cid", parameterToString(localVarOptionals.ConnectionsCid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ConnectionsInterfaceIpAddress.IsSet() {
		localVarQueryParams.Add("connections.interface.ip.address", parameterToString(localVarOptionals.ConnectionsInterfaceIpAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ConnectionsInterfaceIpPort.IsSet() {
		localVarQueryParams.Add("connections.interface.ip.port", parameterToString(localVarOptionals.ConnectionsInterfaceIpPort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ConnectionsInterfaceUuid.IsSet() {
		localVarQueryParams.Add("connections.interface.uuid", parameterToString(localVarOptionals.ConnectionsInterfaceUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ConnectionsInterfaceName.IsSet() {
		localVarQueryParams.Add("connections.interface.name", parameterToString(localVarOptionals.ConnectionsInterfaceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ConnectionsInitiatorAddressPort.IsSet() {
		localVarQueryParams.Add("connections.initiator_address.port", parameterToString(localVarOptionals.ConnectionsInitiatorAddressPort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ConnectionsInitiatorAddressAddress.IsSet() {
		localVarQueryParams.Add("connections.initiator_address.address", parameterToString(localVarOptionals.ConnectionsInitiatorAddressAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TargetPortalGroup.IsSet() {
		localVarQueryParams.Add("target_portal_group", parameterToString(localVarOptionals.TargetPortalGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tsih.IsSet() {
		localVarQueryParams.Add("tsih", parameterToString(localVarOptionals.Tsih.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitiatorName.IsSet() {
		localVarQueryParams.Add("initiator.name", parameterToString(localVarOptionals.InitiatorName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitiatorAlias.IsSet() {
		localVarQueryParams.Add("initiator.alias", parameterToString(localVarOptionals.InitiatorAlias.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Isid.IsSet() {
		localVarQueryParams.Add("isid", parameterToString(localVarOptionals.Isid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TargetPortalGroupTag.IsSet() {
		localVarQueryParams.Add("target_portal_group_tag", parameterToString(localVarOptionals.TargetPortalGroupTag.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v IscsiSessionResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SANApiService
Retrieves an iSCSI session. ### Related ONTAP commands * &#x60;vserver iscsi connection show&#x60; * &#x60;vserver iscsi session parameter show&#x60; * &#x60;vserver iscsi session show&#x60; ### Learn more * [&#x60;DOC /protocols/san/iscsi/sessions&#x60;](#docs-SAN-protocols_san_iscsi_sessions) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid The unique identifier of the SVM of the iSCSI session. 
 * @param tpgroup The target portal group of the iSCSI session. 
 * @param tsih The target session identifying handle. 
 * @param optional nil or *IscsiSessionGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return IscsiSession
*/

type IscsiSessionGetOpts struct { 
	Fields optional.Interface
}

func (a *SANApiService) IscsiSessionGet(ctx context.Context, svmUuid string, tpgroup string, tsih int32, localVarOptionals *IscsiSessionGetOpts) (IscsiSession, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue IscsiSession
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/iscsi/sessions/{svm.uuid}/{tpgroup}/{tsih}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tpgroup"+"}", fmt.Sprintf("%v", tpgroup), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tsih"+"}", fmt.Sprintf("%v", tsih), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v IscsiSession
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SANApiService
Retrieves LUNs. ### Expensive properties There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the &#x60;fields&#x60; query parameter. See [&#x60;DOC Requesting specific fields&#x60;](#docs-docs-Requesting-specific-fields) to learn more. * &#x60;auto_delete&#x60; * &#x60;lun_maps.*&#x60; * &#x60;movement.*&#x60; * &#x60;status.mapped&#x60; ### Related ONTAP commands * &#x60;lun mapping show&#x60; * &#x60;lun move show&#x60; * &#x60;lun show&#x60; * &#x60;volume file clone show-autodelete&#x60; ### Learn more * [&#x60;DOC /storage/luns&#x60;](#docs-SAN-storage_luns) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *LunCollectionGetOpts - Optional Parameters:
     * @param "LocationLogicalUnit" (optional.String) -  Filter by location.logical_unit
     * @param "LocationQtreeName" (optional.String) -  Filter by location.qtree.name
     * @param "LocationQtreeId" (optional.Int32) -  Filter by location.qtree.id
     * @param "LocationVolumeName" (optional.String) -  Filter by location.volume.name
     * @param "LocationVolumeUuid" (optional.String) -  Filter by location.volume.uuid
     * @param "StatusContainerState" (optional.String) -  Filter by status.container_state
     * @param "StatusMapped" (optional.Bool) -  Filter by status.mapped
     * @param "StatusState" (optional.String) -  Filter by status.state
     * @param "StatusReadOnly" (optional.Bool) -  Filter by status.read_only
     * @param "QosPolicyUuid" (optional.String) -  Filter by qos_policy.uuid
     * @param "QosPolicyName" (optional.String) -  Filter by qos_policy.name
     * @param "Class" (optional.String) -  Filter by class
     * @param "MovementMaxThroughput" (optional.String) -  Filter by movement.max_throughput
     * @param "MovementPathsSource" (optional.String) -  Filter by movement.paths.source
     * @param "MovementPathsDestination" (optional.String) -  Filter by movement.paths.destination
     * @param "MovementProgressState" (optional.String) -  Filter by movement.progress.state
     * @param "MovementProgressFailureCode" (optional.String) -  Filter by movement.progress.failure.code
     * @param "MovementProgressFailureArgumentsMessage" (optional.String) -  Filter by movement.progress.failure.arguments.message
     * @param "MovementProgressFailureArgumentsCode" (optional.String) -  Filter by movement.progress.failure.arguments.code
     * @param "MovementProgressFailureMessage" (optional.String) -  Filter by movement.progress.failure.message
     * @param "MovementProgressFailureTarget" (optional.String) -  Filter by movement.progress.failure.target
     * @param "MovementProgressPercentComplete" (optional.Int32) -  Filter by movement.progress.percent_complete
     * @param "MovementProgressVolumeSnapshotBlocked" (optional.Bool) -  Filter by movement.progress.volume_snapshot_blocked
     * @param "MovementProgressElapsed" (optional.Int32) -  Filter by movement.progress.elapsed
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "Name" (optional.String) -  Filter by name
     * @param "Enabled" (optional.Bool) -  Filter by enabled
     * @param "LunMapsLogicalUnitNumber" (optional.Int32) -  Filter by lun_maps.logical_unit_number
     * @param "LunMapsIgroupUuid" (optional.String) -  Filter by lun_maps.igroup.uuid
     * @param "LunMapsIgroupName" (optional.String) -  Filter by lun_maps.igroup.name
     * @param "SpaceSize" (optional.Int32) -  Filter by space.size
     * @param "SpaceGuaranteeRequested" (optional.Bool) -  Filter by space.guarantee.requested
     * @param "SpaceGuaranteeReserved" (optional.Bool) -  Filter by space.guarantee.reserved
     * @param "SpaceUsed" (optional.Int32) -  Filter by space.used
     * @param "OsType" (optional.String) -  Filter by os_type
     * @param "Comment" (optional.String) -  Filter by comment
     * @param "AutoDelete" (optional.Bool) -  Filter by auto_delete
     * @param "Uuid" (optional.String) -  Filter by uuid
     * @param "SerialNumber" (optional.String) -  Filter by serial_number
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return LunResponse
*/

type LunCollectionGetOpts struct { 
	LocationLogicalUnit optional.String
	LocationQtreeName optional.String
	LocationQtreeId optional.Int32
	LocationVolumeName optional.String
	LocationVolumeUuid optional.String
	StatusContainerState optional.String
	StatusMapped optional.Bool
	StatusState optional.String
	StatusReadOnly optional.Bool
	QosPolicyUuid optional.String
	QosPolicyName optional.String
	Class optional.String
	MovementMaxThroughput optional.String
	MovementPathsSource optional.String
	MovementPathsDestination optional.String
	MovementProgressState optional.String
	MovementProgressFailureCode optional.String
	MovementProgressFailureArgumentsMessage optional.String
	MovementProgressFailureArgumentsCode optional.String
	MovementProgressFailureMessage optional.String
	MovementProgressFailureTarget optional.String
	MovementProgressPercentComplete optional.Int32
	MovementProgressVolumeSnapshotBlocked optional.Bool
	MovementProgressElapsed optional.Int32
	SvmUuid optional.String
	SvmName optional.String
	Name optional.String
	Enabled optional.Bool
	LunMapsLogicalUnitNumber optional.Int32
	LunMapsIgroupUuid optional.String
	LunMapsIgroupName optional.String
	SpaceSize optional.Int32
	SpaceGuaranteeRequested optional.Bool
	SpaceGuaranteeReserved optional.Bool
	SpaceUsed optional.Int32
	OsType optional.String
	Comment optional.String
	AutoDelete optional.Bool
	Uuid optional.String
	SerialNumber optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *SANApiService) LunCollectionGet(ctx context.Context, localVarOptionals *LunCollectionGetOpts) (LunResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue LunResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/luns"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.LocationLogicalUnit.IsSet() {
		localVarQueryParams.Add("location.logical_unit", parameterToString(localVarOptionals.LocationLogicalUnit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationQtreeName.IsSet() {
		localVarQueryParams.Add("location.qtree.name", parameterToString(localVarOptionals.LocationQtreeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationQtreeId.IsSet() {
		localVarQueryParams.Add("location.qtree.id", parameterToString(localVarOptionals.LocationQtreeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationVolumeName.IsSet() {
		localVarQueryParams.Add("location.volume.name", parameterToString(localVarOptionals.LocationVolumeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LocationVolumeUuid.IsSet() {
		localVarQueryParams.Add("location.volume.uuid", parameterToString(localVarOptionals.LocationVolumeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatusContainerState.IsSet() {
		localVarQueryParams.Add("status.container_state", parameterToString(localVarOptionals.StatusContainerState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatusMapped.IsSet() {
		localVarQueryParams.Add("status.mapped", parameterToString(localVarOptionals.StatusMapped.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatusState.IsSet() {
		localVarQueryParams.Add("status.state", parameterToString(localVarOptionals.StatusState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatusReadOnly.IsSet() {
		localVarQueryParams.Add("status.read_only", parameterToString(localVarOptionals.StatusReadOnly.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QosPolicyUuid.IsSet() {
		localVarQueryParams.Add("qos_policy.uuid", parameterToString(localVarOptionals.QosPolicyUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.QosPolicyName.IsSet() {
		localVarQueryParams.Add("qos_policy.name", parameterToString(localVarOptionals.QosPolicyName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Class.IsSet() {
		localVarQueryParams.Add("class", parameterToString(localVarOptionals.Class.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementMaxThroughput.IsSet() {
		localVarQueryParams.Add("movement.max_throughput", parameterToString(localVarOptionals.MovementMaxThroughput.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementPathsSource.IsSet() {
		localVarQueryParams.Add("movement.paths.source", parameterToString(localVarOptionals.MovementPathsSource.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementPathsDestination.IsSet() {
		localVarQueryParams.Add("movement.paths.destination", parameterToString(localVarOptionals.MovementPathsDestination.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementProgressState.IsSet() {
		localVarQueryParams.Add("movement.progress.state", parameterToString(localVarOptionals.MovementProgressState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementProgressFailureCode.IsSet() {
		localVarQueryParams.Add("movement.progress.failure.code", parameterToString(localVarOptionals.MovementProgressFailureCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementProgressFailureArgumentsMessage.IsSet() {
		localVarQueryParams.Add("movement.progress.failure.arguments.message", parameterToString(localVarOptionals.MovementProgressFailureArgumentsMessage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementProgressFailureArgumentsCode.IsSet() {
		localVarQueryParams.Add("movement.progress.failure.arguments.code", parameterToString(localVarOptionals.MovementProgressFailureArgumentsCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementProgressFailureMessage.IsSet() {
		localVarQueryParams.Add("movement.progress.failure.message", parameterToString(localVarOptionals.MovementProgressFailureMessage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementProgressFailureTarget.IsSet() {
		localVarQueryParams.Add("movement.progress.failure.target", parameterToString(localVarOptionals.MovementProgressFailureTarget.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementProgressPercentComplete.IsSet() {
		localVarQueryParams.Add("movement.progress.percent_complete", parameterToString(localVarOptionals.MovementProgressPercentComplete.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementProgressVolumeSnapshotBlocked.IsSet() {
		localVarQueryParams.Add("movement.progress.volume_snapshot_blocked", parameterToString(localVarOptionals.MovementProgressVolumeSnapshotBlocked.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MovementProgressElapsed.IsSet() {
		localVarQueryParams.Add("movement.progress.elapsed", parameterToString(localVarOptionals.MovementProgressElapsed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarQueryParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LunMapsLogicalUnitNumber.IsSet() {
		localVarQueryParams.Add("lun_maps.logical_unit_number", parameterToString(localVarOptionals.LunMapsLogicalUnitNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LunMapsIgroupUuid.IsSet() {
		localVarQueryParams.Add("lun_maps.igroup.uuid", parameterToString(localVarOptionals.LunMapsIgroupUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LunMapsIgroupName.IsSet() {
		localVarQueryParams.Add("lun_maps.igroup.name", parameterToString(localVarOptionals.LunMapsIgroupName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceSize.IsSet() {
		localVarQueryParams.Add("space.size", parameterToString(localVarOptionals.SpaceSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceGuaranteeRequested.IsSet() {
		localVarQueryParams.Add("space.guarantee.requested", parameterToString(localVarOptionals.SpaceGuaranteeRequested.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceGuaranteeReserved.IsSet() {
		localVarQueryParams.Add("space.guarantee.reserved", parameterToString(localVarOptionals.SpaceGuaranteeReserved.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SpaceUsed.IsSet() {
		localVarQueryParams.Add("space.used", parameterToString(localVarOptionals.SpaceUsed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OsType.IsSet() {
		localVarQueryParams.Add("os_type", parameterToString(localVarOptionals.OsType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Comment.IsSet() {
		localVarQueryParams.Add("comment", parameterToString(localVarOptionals.Comment.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AutoDelete.IsSet() {
		localVarQueryParams.Add("auto_delete", parameterToString(localVarOptionals.AutoDelete.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SerialNumber.IsSet() {
		localVarQueryParams.Add("serial_number", parameterToString(localVarOptionals.SerialNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v LunResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SANApiService
Creates a LUN. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the LUN. * &#x60;name&#x60;, &#x60;location.volume.name&#x60; or &#x60;location.volume.uuid&#x60; - Existing volume in which to create the LUN. * &#x60;name&#x60; or &#x60;location.logical_unit&#x60; - Base name of the LUN. * &#x60;os_type&#x60; - Operating system from which the LUN will be accessed. Required when creating a non-clone LUN and disallowed when creating a clone of an existing LUN. A clone&#39;s &#x60;os_type&#x60; is taken from the source LUN. * &#x60;space.size&#x60; - Size of the LUN. Required when creating a non-clone LUN and disallowed when creating a clone of an existing LUN. A clone&#39;s size is taken from the source LUN. ### Recommended optional properties * &#x60;qos_policy.name&#x60; or &#x60;qos_policy.uuid&#x60; - Existing traditional or adaptive QoS policy to be applied to the LUN. All LUNs should be managed by a QoS policy at the volume or LUN level. ### Default property values If not specified in POST, the follow default property values are assigned. * &#x60;auto_delete&#x60; - _false_ ### Related ONTAP commands * &#x60;lun create&#x60; * &#x60;volume file clone autodelete&#x60; * &#x60;volume file clone create&#x60; ### Learn more * [&#x60;DOC /storage/luns&#x60;](#docs-SAN-storage_luns) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info The property values for the new LUN. 

@return LunResponse
*/
func (a *SANApiService) LunCreate(ctx context.Context, info Lun) (LunResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue LunResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/luns"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v LunResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SANApiService
Deletes a LUN. ### Related ONTAP commands * &#x60;lun delete&#x60; ### Learn more * [&#x60;DOC /storage/luns&#x60;](#docs-SAN-storage_luns) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid The unique identifier of the LUN. 
 * @param optional nil or *LunDeleteOpts - Optional Parameters:
     * @param "AllowDeleteWhileMapped" (optional.Bool) -  Allow deletion of a mapped LUN. A mapped LUN might be in use. Deleting a mapped LUN also deletes the LUN map and makes the data no longer available. This might cause a disruption in the availability of data. **This parameter should be used with caution.** 


*/

type LunDeleteOpts struct { 
	AllowDeleteWhileMapped optional.Bool
}

func (a *SANApiService) LunDelete(ctx context.Context, uuid string, localVarOptionals *LunDeleteOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/luns/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AllowDeleteWhileMapped.IsSet() {
		localVarQueryParams.Add("allow_delete_while_mapped", parameterToString(localVarOptionals.AllowDeleteWhileMapped.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
SANApiService
Retrieves a LUN. ### Expensive properties There is an added cost to retrieving values for these properties. They are not included by default in GET results and must be explicitly requested using the &#x60;fields&#x60; query parameter. See [&#x60;DOC Requesting specific fields&#x60;](#docs-docs-Requesting-specific-fields) to learn more. * &#x60;auto_delete&#x60; * &#x60;lun_maps.*&#x60; * &#x60;movement.*&#x60; * &#x60;status.mapped&#x60; ### Related ONTAP commands * &#x60;lun mapping show&#x60; * &#x60;lun move show&#x60; * &#x60;lun show&#x60; * &#x60;volume file clone show-autodelete&#x60; ### Learn more * [&#x60;DOC /storage/luns&#x60;](#docs-SAN-storage_luns) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid The unique identifier of the LUN to retrieve. 
 * @param optional nil or *LunGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return Lun
*/

type LunGetOpts struct { 
	Fields optional.Interface
}

func (a *SANApiService) LunGet(ctx context.Context, uuid string, localVarOptionals *LunGetOpts) (Lun, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Lun
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/luns/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Lun
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SANApiService
Retrieves LUN maps. ### Related ONTAP commands * &#x60;lun mapping show&#x60; * [&#x60;DOC /protocols/san/lun-maps&#x60;](#docs-SAN-protocols_san_lun-maps)  ### Learn more * [&#x60;DOC /protocols/san/lun-maps&#x60;](#docs-SAN-protocols_san_lun-maps)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *LunMapCollectionGetOpts - Optional Parameters:
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "LogicalUnitNumber" (optional.Int32) -  Filter by logical_unit_number
     * @param "IgroupProtocol" (optional.String) -  Filter by igroup.protocol
     * @param "IgroupUuid" (optional.String) -  Filter by igroup.uuid
     * @param "IgroupInitiators" (optional.String) -  Filter by igroup.initiators
     * @param "IgroupOsType" (optional.String) -  Filter by igroup.os_type
     * @param "IgroupName" (optional.String) -  Filter by igroup.name
     * @param "LunName" (optional.String) -  Filter by lun.name
     * @param "LunNodeName" (optional.String) -  Filter by lun.node.name
     * @param "LunNodeUuid" (optional.String) -  Filter by lun.node.uuid
     * @param "LunUuid" (optional.String) -  Filter by lun.uuid
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return LunMapResponse
*/

type LunMapCollectionGetOpts struct { 
	SvmUuid optional.String
	SvmName optional.String
	LogicalUnitNumber optional.Int32
	IgroupProtocol optional.String
	IgroupUuid optional.String
	IgroupInitiators optional.String
	IgroupOsType optional.String
	IgroupName optional.String
	LunName optional.String
	LunNodeName optional.String
	LunNodeUuid optional.String
	LunUuid optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *SANApiService) LunMapCollectionGet(ctx context.Context, localVarOptionals *LunMapCollectionGetOpts) (LunMapResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue LunMapResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/lun-maps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LogicalUnitNumber.IsSet() {
		localVarQueryParams.Add("logical_unit_number", parameterToString(localVarOptionals.LogicalUnitNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IgroupProtocol.IsSet() {
		localVarQueryParams.Add("igroup.protocol", parameterToString(localVarOptionals.IgroupProtocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IgroupUuid.IsSet() {
		localVarQueryParams.Add("igroup.uuid", parameterToString(localVarOptionals.IgroupUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IgroupInitiators.IsSet() {
		localVarQueryParams.Add("igroup.initiators", parameterToString(localVarOptionals.IgroupInitiators.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IgroupOsType.IsSet() {
		localVarQueryParams.Add("igroup.os_type", parameterToString(localVarOptionals.IgroupOsType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IgroupName.IsSet() {
		localVarQueryParams.Add("igroup.name", parameterToString(localVarOptionals.IgroupName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LunName.IsSet() {
		localVarQueryParams.Add("lun.name", parameterToString(localVarOptionals.LunName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LunNodeName.IsSet() {
		localVarQueryParams.Add("lun.node.name", parameterToString(localVarOptionals.LunNodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LunNodeUuid.IsSet() {
		localVarQueryParams.Add("lun.node.uuid", parameterToString(localVarOptionals.LunNodeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LunUuid.IsSet() {
		localVarQueryParams.Add("lun.uuid", parameterToString(localVarOptionals.LunUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v LunMapResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SANApiService
Creates a LUN map. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the LUN map. * &#x60;igroup.uuid&#x60; or &#x60;igroup.name&#x60; - Existing initiator group to map to the specified LUN. * &#x60;lun.uuid&#x60; or &#x60;lun.name&#x60; - Existing LUN to map to the specified initiator group. ### Default property values If not specified in POST, the following default property values are assigned. * &#x60;logical_unit_number&#x60; - If no value is provided, ONTAP assigns the lowest available value. ### Related ONTAP commands * &#x60;lun mapping create&#x60; ### Learn more * [&#x60;DOC /protocols/san/lun-maps&#x60;](#docs-SAN-protocols_san_lun-maps) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info The property values for the new LUN map. 

@return LunMapResponse
*/
func (a *SANApiService) LunMapCreate(ctx context.Context, info LunMap) (LunMapResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue LunMapResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/lun-maps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v LunMapResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SANApiService
Deletes a LUN map. ### Related ONTAP commands * &#x60;lun mapping delete&#x60; ### Learn more * [&#x60;DOC /protocols/san/lun-maps&#x60;](#docs-SAN-protocols_san_lun-maps) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param lunUuid The unique identifier of the LUN. 
 * @param igroupUuid The unique identifier of the igroup. 


*/
func (a *SANApiService) LunMapDelete(ctx context.Context, lunUuid string, igroupUuid string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/lun-maps/{lun.uuid}/{igroup.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"lun.uuid"+"}", fmt.Sprintf("%v", lunUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"igroup.uuid"+"}", fmt.Sprintf("%v", igroupUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
SANApiService
Retrieves a LUN map. ### Related ONTAP commands * &#x60;lun mapping show&#x60; ### Learn more * [&#x60;DOC /protocols/san/lun-maps&#x60;](#docs-SAN-protocols_san_lun-maps) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param lunUuid The unique identifier of the LUN. 
 * @param igroupUuid The unique identifier of the igroup. 
 * @param optional nil or *LunMapGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return LunMap
*/

type LunMapGetOpts struct { 
	Fields optional.Interface
}

func (a *SANApiService) LunMapGet(ctx context.Context, lunUuid string, igroupUuid string, localVarOptionals *LunMapGetOpts) (LunMap, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue LunMap
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/san/lun-maps/{lun.uuid}/{igroup.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"lun.uuid"+"}", fmt.Sprintf("%v", lunUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"igroup.uuid"+"}", fmt.Sprintf("%v", igroupUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v LunMap
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SANApiService
Updates the properties of a LUN. PATCH can also be be used to overwrite the contents of a LUN as a clone of another, to begin movement of a LUN between volumes, and to pause and resume the movement of a LUN between volumes. ### Related ONTAP commands * &#x60;lun modify&#x60; * &#x60;lun move modify&#x60; * &#x60;lun move pause&#x60; * &#x60;lun move resume&#x60; * &#x60;lun move start&#x60; * &#x60;lun resize&#x60; * &#x60;volume file clone autodelete&#x60; ### Learn more * [&#x60;DOC /storage/luns&#x60;](#docs-SAN-storage_luns) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid The unique identifier of the LUN to update. 
 * @param info The new property values for the LUN. 


*/
func (a *SANApiService) LunModify(ctx context.Context, uuid string, info Lun) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/storage/luns/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
SANApiService
Retrieves FC WWPN aliases. ### Related ONTAP commands * &#x60;vserver fcp wwpn-alias show&#x60; ### Learn more * [&#x60;DOC /network/fc/wwpn-aliases&#x60;](#docs-SAN-network_fc_wwpn-aliases) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *WwpnAliasCollectionGetOpts - Optional Parameters:
     * @param "Wwpn" (optional.String) -  Filter by wwpn
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "Alias" (optional.String) -  Filter by alias
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return WwpnAliasResponse
*/

type WwpnAliasCollectionGetOpts struct { 
	Wwpn optional.String
	SvmUuid optional.String
	SvmName optional.String
	Alias optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *SANApiService) WwpnAliasCollectionGet(ctx context.Context, localVarOptionals *WwpnAliasCollectionGetOpts) (WwpnAliasResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue WwpnAliasResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/fc/wwpn-aliases"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Wwpn.IsSet() {
		localVarQueryParams.Add("wwpn", parameterToString(localVarOptionals.Wwpn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Alias.IsSet() {
		localVarQueryParams.Add("alias", parameterToString(localVarOptionals.Alias.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v WwpnAliasResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SANApiService
Creates an FC WWPN alias. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the FC alias. * &#x60;alias&#x60; - Name of the FC alias. * &#x60;wwpn&#x60; - FC WWPN for which to create the alias. ### Related ONTAP commands * &#x60;vserver fcp wwpn-alias set&#x60; ### Learn more * [&#x60;DOC /network/fc/wwpn-aliases&#x60;](#docs-SAN-network_fc_wwpn-aliases) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info The property values for the new WWPN alias. 

@return WwpnAliasResponse
*/
func (a *SANApiService) WwpnAliasCreate(ctx context.Context, info WwpnAlias) (WwpnAliasResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue WwpnAliasResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/fc/wwpn-aliases"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v WwpnAliasResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SANApiService
Deletes an FC WWPN alias. ### Related ONTAP commands * &#x60;vserver fcp wwpn-alias remove&#x60; ### Learn more * [&#x60;DOC /network/fc/wwpn-aliases&#x60;](#docs-SAN-network_fc_wwpn-aliases) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid The unique identifier of the SVM. 
 * @param alias The name of FC WWPN alias. 


*/
func (a *SANApiService) WwpnAliasDelete(ctx context.Context, svmUuid string, alias string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/fc/wwpn-aliases/{svm.uuid}/{alias}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alias"+"}", fmt.Sprintf("%v", alias), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
SANApiService
Retrieves an FC WWPN alias. ### Related ONTAP commands * &#x60;vserver fcp wwpn-alias show&#x60; ### Learn more * [&#x60;DOC /network/fc/wwpn-aliases&#x60;](#docs-SAN-network_fc_wwpn-aliases) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid The unique identifier of the SVM in which the alias is found. 
 * @param alias The name of FC WWPN alias. 
 * @param optional nil or *WwpnAliasGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return WwpnAlias
*/

type WwpnAliasGetOpts struct { 
	Fields optional.Interface
}

func (a *SANApiService) WwpnAliasGet(ctx context.Context, svmUuid string, alias string, localVarOptionals *WwpnAliasGetOpts) (WwpnAlias, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue WwpnAlias
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/network/fc/wwpn-aliases/{svm.uuid}/{alias}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alias"+"}", fmt.Sprintf("%v", alias), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v WwpnAlias
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
