/*
 * ONTAP REST API
 *
 * ONTAP 9.6 adds support for an expansive RESTful API. The documentation below provides information about the types of API calls available to you, as well as details about using each API endpoint. You can learn more about the ONTAP REST API and ONTAP in the ONTAP 9 Documentation Center:  http://docs.netapp.com/ontap-9/topic/com.netapp.doc.dot-rest-api/home.html. NetApp welcomes your comments and suggestions about the ONTAP REST API and the documentation for its use.</br> **Using the ONTAP 9.6 REST API online documentation** Each API method includes usage examples, as well as a model that displays all the required and optional properties supported by the method. Click the _Model_ link, available with each API method, to see all the required and optional properties supported by each method. 
 *
 * API version: v1
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type SnapmirrorApiService service

/* 
SnapmirrorApiService
Retrieves SnapMirror policies of type \&quot;mirror-vault\&quot;, \&quot;sync-mirror\&quot; and \&quot;strict-sync-mirror\&quot;. ### Related ONTAP commands * &#x60;snapmirror policy show&#x60; ### Example The following example shows how to retrieve a collection of SnapMirror policies. &lt;br/&gt; &#x60;&#x60;&#x60; GET \&quot;/api/storage/snapmirror/policies\&quot; &#x60;&#x60;&#x60; &lt;br/&gt; ### Learn more * [&#x60;DOC /snapmirror/policies&#x60;](#docs-snapmirror-snapmirror_policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *SnapmirrorPoliciesGetOpts - Optional Parameters:
     * @param "SyncType" (optional.String) -  Filter by sync_type
     * @param "NetworkCompressionEnabled" (optional.Bool) -  Filter by network_compression_enabled
     * @param "TransferScheduleUuid" (optional.String) -  Filter by transfer_schedule.uuid
     * @param "TransferScheduleName" (optional.String) -  Filter by transfer_schedule.name
     * @param "Type_" (optional.String) -  Filter by type
     * @param "Throttle" (optional.Int32) -  Filter by throttle
     * @param "SyncCommonSnapshotScheduleUuid" (optional.String) -  Filter by sync_common_snapshot_schedule.uuid
     * @param "SyncCommonSnapshotScheduleName" (optional.String) -  Filter by sync_common_snapshot_schedule.name
     * @param "Scope" (optional.String) -  Filter by scope
     * @param "Comment" (optional.String) -  Filter by comment
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "Name" (optional.String) -  Filter by name
     * @param "IdentityPreservation" (optional.String) -  Filter by identity_preservation
     * @param "RetentionPrefix" (optional.String) -  Filter by retention.prefix
     * @param "RetentionCreationScheduleUuid" (optional.String) -  Filter by retention.creation_schedule.uuid
     * @param "RetentionCreationScheduleName" (optional.String) -  Filter by retention.creation_schedule.name
     * @param "RetentionLabel" (optional.String) -  Filter by retention.label
     * @param "RetentionCount" (optional.Int32) -  Filter by retention.count
     * @param "Uuid" (optional.String) -  Filter by uuid
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return SnapmirrorPolicyResponse
*/

type SnapmirrorPoliciesGetOpts struct { 
	SyncType optional.String
	NetworkCompressionEnabled optional.Bool
	TransferScheduleUuid optional.String
	TransferScheduleName optional.String
	Type_ optional.String
	Throttle optional.Int32
	SyncCommonSnapshotScheduleUuid optional.String
	SyncCommonSnapshotScheduleName optional.String
	Scope optional.String
	Comment optional.String
	SvmUuid optional.String
	SvmName optional.String
	Name optional.String
	IdentityPreservation optional.String
	RetentionPrefix optional.String
	RetentionCreationScheduleUuid optional.String
	RetentionCreationScheduleName optional.String
	RetentionLabel optional.String
	RetentionCount optional.Int32
	Uuid optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *SnapmirrorApiService) SnapmirrorPoliciesGet(ctx context.Context, localVarOptionals *SnapmirrorPoliciesGetOpts) (SnapmirrorPolicyResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SnapmirrorPolicyResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/snapmirror/policies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.SyncType.IsSet() {
		localVarQueryParams.Add("sync_type", parameterToString(localVarOptionals.SyncType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NetworkCompressionEnabled.IsSet() {
		localVarQueryParams.Add("network_compression_enabled", parameterToString(localVarOptionals.NetworkCompressionEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransferScheduleUuid.IsSet() {
		localVarQueryParams.Add("transfer_schedule.uuid", parameterToString(localVarOptionals.TransferScheduleUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransferScheduleName.IsSet() {
		localVarQueryParams.Add("transfer_schedule.name", parameterToString(localVarOptionals.TransferScheduleName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Throttle.IsSet() {
		localVarQueryParams.Add("throttle", parameterToString(localVarOptionals.Throttle.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SyncCommonSnapshotScheduleUuid.IsSet() {
		localVarQueryParams.Add("sync_common_snapshot_schedule.uuid", parameterToString(localVarOptionals.SyncCommonSnapshotScheduleUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SyncCommonSnapshotScheduleName.IsSet() {
		localVarQueryParams.Add("sync_common_snapshot_schedule.name", parameterToString(localVarOptionals.SyncCommonSnapshotScheduleName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Scope.IsSet() {
		localVarQueryParams.Add("scope", parameterToString(localVarOptionals.Scope.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Comment.IsSet() {
		localVarQueryParams.Add("comment", parameterToString(localVarOptionals.Comment.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdentityPreservation.IsSet() {
		localVarQueryParams.Add("identity_preservation", parameterToString(localVarOptionals.IdentityPreservation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RetentionPrefix.IsSet() {
		localVarQueryParams.Add("retention.prefix", parameterToString(localVarOptionals.RetentionPrefix.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RetentionCreationScheduleUuid.IsSet() {
		localVarQueryParams.Add("retention.creation_schedule.uuid", parameterToString(localVarOptionals.RetentionCreationScheduleUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RetentionCreationScheduleName.IsSet() {
		localVarQueryParams.Add("retention.creation_schedule.name", parameterToString(localVarOptionals.RetentionCreationScheduleName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RetentionLabel.IsSet() {
		localVarQueryParams.Add("retention.label", parameterToString(localVarOptionals.RetentionLabel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RetentionCount.IsSet() {
		localVarQueryParams.Add("retention.count", parameterToString(localVarOptionals.RetentionCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v SnapmirrorPolicyResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SnapmirrorApiService
Creates a SnapMirror policy. The parameter \&quot;identity_preservation\&quot; is applicable to only SnapMirror relationships with SVM endpoints and it indicates which configuration of the source SVM is replicated to the destination SVM.&lt;/br&gt; It takes the following values: - &#x60;full&#x60; - indicates that the source SVM configuration is replicated to the destination SVM endpoint. - &#x60;exclude_network_config&#x60; - indicates that the source SVM configuration other than network configuration is replicated to the destination SVM endpoint. - &#x60;exclude_network_and_protocol_config&#x60; - indicates that the source SVM configuration is not replicated to the destination SVM endpoint.&lt;br/&gt; ### Important note - The property \&quot;identity_preservation\&quot; is applicable to only SnapMirror relationships with SVM endpoints and it indicates which configuration of the source SVM is replicated to the destination SVM. - The properties \&quot;identity_preservation\&quot;, \&quot;retention\&quot; and \&quot;transfer_schedule\&quot; are not applicable for \&quot;sync\&quot; type policies. - The property \&quot;sync_common_snapshot_schedule\&quot; is not applicabe for an \&quot;async\&quot; type policy. - The property \&quot;retention.count\&quot; specifies the maximum number of Snapshot copies that are retained on the SnapMirror destination volume. - When the property \&quot;retention.label\&quot; is specified, the Snapshot copies that have a SnapMirror label matching this property is transferred to the SnapMirror destination. - When the property \&quot;retention.creation_schedule\&quot; is specified, Snapshot copies are directly created on the SnapMirror destination. The Snapshot copies created have the same content as the latest Snapshot copy already present on the SnapMirror destination. ### Required properties * &#x60;name&#x60; - Name of the new SnapMirror policy. ### Recommended optional properties * &#x60;svm.name&#x60; or &#x60;svm.uuid&#x60; - Name or UUID of the SVM that owns the SnapMirror policy. ### Default property values If not specified in POST, the following default property values are assigned: * &#x60;type&#x60; - _async_ * &#x60;sync_type&#x60; - _sync_ (when &#x60;type&#x60; is _sync_) * &#x60;network_compression_enabled&#x60; - _false_ * &#x60;throttle&#x60; - _0_ * &#x60;identity_preservation&#x60; - &#x60;_exclude_network_and_protocol_config_&#x60; ### Related ONTAP commands * &#x60;snapmirror policy create&#x60; ### Examples   Creating a SnapMirror policy of type \&quot;sync\&quot;    &lt;br/&gt;    &#x60;&#x60;&#x60;    POST \&quot;/api/snapmirror/policies/\&quot; &#39;{\&quot;name\&quot;: \&quot;policy1\&quot;, \&quot;svm.name\&quot;: \&quot;VS0\&quot;, \&quot;type\&quot;: \&quot;sync\&quot;, \&quot;sync_type\&quot;: \&quot;sync\&quot;}&#39;    &#x60;&#x60;&#x60;    &lt;br/&gt;   Creating a SnapMirror policy of type \&quot;async\&quot; with retention values    &lt;br/&gt;    &#x60;&#x60;&#x60;    POST \&quot;/api/snapmirror/policies\&quot; &#39;{\&quot;name\&quot;: \&quot;policy_ret\&quot;, \&quot;svm\&quot;: {\&quot;name\&quot;: \&quot;vs1\&quot;}, \&quot;retention\&quot;: {\&quot;label\&quot;: [\&quot;smcreate\&quot;], \&quot;count\&quot;: [\&quot;2\&quot;], \&quot;creation_schedule\&quot;: [\&quot;weekly\&quot;]}}&#39;    &#x60;&#x60;&#x60;    &lt;br/&gt;   Creating a SnapMirror policy of type \&quot;async\&quot;    &#x60;&#x60;&#x60;    POST \&quot;/api/snapmirror/policies\&quot; &#39;{\&quot;name\&quot;: \&quot;newPolicy\&quot;, \&quot;svm\&quot;:{\&quot;name\&quot; : \&quot;vs1\&quot;}, \&quot;type\&quot;: \&quot;async\&quot;}&#39;    &#x60;&#x60;&#x60;    &lt;br/&gt; ### Learn more * [&#x60;DOC /snapmirror/policies&#x60;](#docs-snapmirror-snapmirror_policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info Information on the SnapMirror policy
 * @param optional nil or *SnapmirrorPolicyCreateOpts - Optional Parameters:
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning. When doing a POST, PATCH, or DELETE operation on a single record, the default is 0 seconds.  This means that if an asynchronous operation is started, the server immediately returns HTTP code 202 (Accepted) along with a link to the job.  If a non-zero value is specified for POST, PATCH, or DELETE operations, ONTAP waits that length of time to see if the job completes so it can return something other than 202.

@return JobLinkResponse
*/

type SnapmirrorPolicyCreateOpts struct { 
	ReturnTimeout optional.Int32
}

func (a *SnapmirrorApiService) SnapmirrorPolicyCreate(ctx context.Context, info SnapmirrorPolicy, localVarOptionals *SnapmirrorPolicyCreateOpts) (JobLinkResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/snapmirror/policies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SnapmirrorApiService
Deletes a SnapMirror policy. ### Related ONTAP commands * &#x60;snapmirror policy delete&#x60; ### Example &lt;br/&gt; &#x60;&#x60;&#x60; DELETE \&quot;/api/snapmirror/policies/510c15d4-f9e6-11e8-bdb5-0050568e12c2\&quot; &#x60;&#x60;&#x60; &lt;br/&gt; ### Learn more * [&#x60;DOC /snapmirror/policies&#x60;](#docs-snapmirror-snapmirror_policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Policy UUID
 * @param optional nil or *SnapmirrorPolicyDeleteOpts - Optional Parameters:
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning. When doing a POST, PATCH, or DELETE operation on a single record, the default is 0 seconds.  This means that if an asynchronous operation is started, the server immediately returns HTTP code 202 (Accepted) along with a link to the job.  If a non-zero value is specified for POST, PATCH, or DELETE operations, ONTAP waits that length of time to see if the job completes so it can return something other than 202.

@return JobLinkResponse
*/

type SnapmirrorPolicyDeleteOpts struct { 
	ReturnTimeout optional.Int32
}

func (a *SnapmirrorApiService) SnapmirrorPolicyDelete(ctx context.Context, uuid string, localVarOptionals *SnapmirrorPolicyDeleteOpts) (JobLinkResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/snapmirror/policies/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SnapmirrorApiService
Retrieves a specific SnapMirror policy. ### Example &lt;br/&gt; &#x60;&#x60;&#x60; GET \&quot;/api/snapmirror/policies/567aaac0-f863-11e8-a666-0050568e12c2\&quot; &#x60;&#x60;&#x60; &lt;br/&gt; ### Learn more * [&#x60;DOC /snapmirror/policies&#x60;](#docs-snapmirror-snapmirror_policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Policy UUID
 * @param optional nil or *SnapmirrorPolicyGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return SnapmirrorPolicy
*/

type SnapmirrorPolicyGetOpts struct { 
	Fields optional.Interface
}

func (a *SnapmirrorApiService) SnapmirrorPolicyGet(ctx context.Context, uuid string, localVarOptionals *SnapmirrorPolicyGetOpts) (SnapmirrorPolicy, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SnapmirrorPolicy
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/snapmirror/policies/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v SnapmirrorPolicy
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SnapmirrorApiService
Updates the SnapMirror policy. ### Important notes * The properties \&quot;transfer_schedule\&quot; and \&quot;throttle\&quot; can be modified only if all the SnapMirror relationships associated with the specified SnapMirror policy have the same values. * The properties \&quot;retention.label\&quot; and \&quot;retention.count\&quot; are mandatory if \&quot;retention\&quot; is provided in the input. The provided \&quot;retention.label\&quot; is the final list and is replaced with the existing values. * The value of the \&quot;identity_preservation\&quot; property cannot be changed if the SnapMirror relationships associated with the policy have different identity_preservation configurations. * If the SnapMirror policy \&quot;identity_preservation\&quot; value matches the \&quot;identity_preservation\&quot; value of the associated SnapMirror relationships, then the \&quot;identity_preservation\&quot; value can be changed from a higher \&quot;identity_preservation\&quot; threshold value to a lower \&quot;identity_preservation\&quot; threshold value but not vice-versa. For example, the threshold value of the \&quot;identity_preservation\&quot; property can be changed from \&quot;full\&quot; to \&quot;exclude_network_config\&quot; to \&quot;exclude_network_and_protocol_config\&quot;, but could not be increased from \&quot;exclude_network_and_protocol_config\&quot; to \&quot;exclude_network_config\&quot; to \&quot;full\&quot;.&lt;br/&gt; ### Related ONTAP commands * &#x60;snapmirror policy modify&#x60; ### Example   Updating the \&quot;retention\&quot; property    &lt;br/&gt;    &#x60;&#x60;&#x60;    PATCH \&quot;/api/snapmirror/policies/fe65686d-00dc-11e9-b5fb-0050568e3f83\&quot; &#39;{\&quot;retention\&quot; : {\&quot;label\&quot; : [\&quot;sm_created\&quot;, \&quot;lab2\&quot;], \&quot;count\&quot;: [\&quot;1\&quot;,\&quot;2\&quot;], \&quot;creation_schedule\&quot;: {\&quot;name\&quot;: [\&quot;weekly\&quot;]}}}&#39;    &#x60;&#x60;&#x60;    &lt;br/&gt;   Updating \&quot;transfer_schedule\&quot;, \&quot;throttle\&quot;, and \&quot;identity_preservation\&quot; properties    &lt;br/&gt;    &#x60;&#x60;&#x60;    PATCH \&quot;/api/snapmirror/policies/8aef950b-3bef-11e9-80ac-0050568ea591\&quot; &#39;{\&quot;transfer_schedule.name\&quot; : \&quot;weekly\&quot;, \&quot;throttle\&quot; : \&quot;100\&quot;, \&quot;identity_preservation\&quot;:\&quot;exclude_network_and_protocol_config\&quot;}&#39;    &#x60;&#x60;&#x60;    &lt;br/&gt; ### Learn more * [&#x60;DOC /snapmirror/policies&#x60;](#docs-snapmirror-snapmirror_policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Policy UUID
 * @param info Information on the SnapMirror policy

@return JobLinkResponse
*/
func (a *SnapmirrorApiService) SnapmirrorPolicyModify(ctx context.Context, uuid string, info SnapmirrorPolicy) (JobLinkResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/snapmirror/policies/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SnapmirrorApiService
Creates a SnapMirror relationship. This API must be executed on the cluster containing the destination endpoint. ### Required properties * &#x60;source.path&#x60; - Path to the source endpoint of the SnapMirror relationship. * &#x60;destination.path&#x60; - Path to the destination endpoint of the SnapMirror relationship. ### Recommended optional properties * &#x60;policy.name&#x60; or &#x60;policy.uuid&#x60; - Policy governing the SnapMirror relationship. ### Default property values If not specified in POST, the following default property values are assigned: * &#x60;policy.name&#x60; - _MirrorAndVault_ * &#x60;restore&#x60; - _false_ ### Related ONTAP commands * &#x60;snapmirror create&#x60; ### Examples The following examples show how to create FlexVol, FlexGroup and SVM SnapMirror relationships. Note that the source SVM name should be the local name of the peer SVM.&lt;/br&gt;    Creating a FlexVol SnapMirror relationship of type XDP.    &lt;br/&gt;    &#x60;&#x60;&#x60;    POST \&quot;/api/snapmirror/relationships/\&quot; &#39;{\&quot;source\&quot;: {\&quot;path\&quot;: \&quot;test_vserv_src:src_vol_rw\&quot;}, \&quot;destination\&quot;: { \&quot;path\&quot;: \&quot;test_vserv_dst:dst_vol_rw\&quot;}}&#39;    &#x60;&#x60;&#x60;    &lt;br/&gt;    Creating a FlexGroup SnapMirror relationship of type XDP.    &lt;br/&gt;    &#x60;&#x60;&#x60;    POST \&quot;/api/snapmirror/relationships/\&quot; &#39;{\&quot;source\&quot;: {\&quot;path\&quot;: \&quot;test_vserv_src:source_flexgrp\&quot;}, \&quot;destination\&quot;: { \&quot;path\&quot;: \&quot;test_vserv_dst:dest_flexgrp\&quot;}}&#39;    &#x60;&#x60;&#x60;    &lt;br/&gt;    Creating a SVM SnapMirror relationship of type XDP.    &lt;br/&gt;    &#x60;&#x60;&#x60;    POST \&quot;/api/snapmirror/relationships/\&quot; &#39;{\&quot;source\&quot;: { \&quot;path\&quot;: \&quot;src_svm:\&quot;}, \&quot;destination\&quot;: { \&quot;path\&quot;: \&quot;dst_svm:\&quot;}}&#39;    &#x60;&#x60;&#x60;    &lt;br/&gt;    Creating a SnapMirror relationship in order to restore from a destination.    &lt;br/&gt;    &#x60;&#x60;&#x60;    POST \&quot;/api/snapmirror/relationships/\&quot; &#39;{\&quot;source\&quot;: {\&quot;path\&quot;: \&quot;test_vserv_src:src_vol_rw\&quot;}, \&quot;destination\&quot;: { \&quot;path\&quot;: \&quot;test_vserv_dst:dst_vol_rw\&quot;}, \&quot;restore\&quot;: \&quot;true\&quot;}&#39;    &#x60;&#x60;&#x60;    &lt;br/&gt; ### Learn more * [&#x60;DOC /snapmirror/relationships&#x60;](#docs-snapmirror-snapmirror_relationships) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param info Information on the SnapMirror relationship
 * @param optional nil or *SnapmirrorRelationshipCreateOpts - Optional Parameters:
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning. When doing a POST, PATCH, or DELETE operation on a single record, the default is 0 seconds.  This means that if an asynchronous operation is started, the server immediately returns HTTP code 202 (Accepted) along with a link to the job.  If a non-zero value is specified for POST, PATCH, or DELETE operations, ONTAP waits that length of time to see if the job completes so it can return something other than 202.

@return JobLinkResponse
*/

type SnapmirrorRelationshipCreateOpts struct { 
	ReturnTimeout optional.Int32
}

func (a *SnapmirrorApiService) SnapmirrorRelationshipCreate(ctx context.Context, info SnapmirrorRelationship, localVarOptionals *SnapmirrorRelationshipCreateOpts) (JobLinkResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/snapmirror/relationships"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SnapmirrorApiService
Deletes a SnapMirror relationship. ### Important notes * The \&quot;destination_only\&quot;, \&quot;source_only\&quot;, and \&quot;source_info_only\&quot; flags are mutually exclusive. If no flag is specified, the relationship is deleted from both the source and destination and all common Snapshot copies between the source and destination are also deleted. * For a restore relationship, the call must be executed on the cluster containing the destination endpoint without specifying the destination_only, source_only, or source_info_only parameters. * Additionally, ensure that there are no ongoing transfers on a restore relationship before calling this API. ### Related ONTAP commands * &#x60;snapmirror delete&#x60; * &#x60;snapmirror release&#x60; ### Examples The following examples show how to delete the relationship from both the source and destination, the destination only, and the source only. &lt;br/&gt;    Deleting the relationship from both the source and destination. This API must be run on the cluster containing the destination endpoint.    &lt;br/&gt;    &#x60;&#x60;&#x60;    DELETE \&quot;/api/snapmirror/relationships/4512b2d2-fd60-11e8-8929-005056bbfe52\&quot;    &#x60;&#x60;&#x60;    &lt;br/&gt;    Deleting the relationship on the destination only. This API must be run on the cluster containing the destination endpoint.    &lt;br/&gt;    &#x60;&#x60;&#x60;    DELETE \&quot;/api/snapmirror/relationships/fd1e0697-02ba-11e9-acc7-005056a7697f/?destination_only&#x3D;true\&quot;    &#x60;&#x60;&#x60;    &lt;br/&gt;    Deleting the relationship on the source only. This API must be run on the cluster containing the source endpoint.    &lt;br/&gt;    &#x60;&#x60;&#x60;    DELETE \&quot;/api/snapmirror/relationships/93e828ba-02bc-11e9-acc7-005056a7697f/?source_only&#x3D;true\&quot;    &#x60;&#x60;&#x60;    &lt;br/&gt;    Deleting the source information only. This API must be run on the cluster containing the source endpoint. This does not delete the common Snapshot copies between the source and destination.    &lt;br/&gt;    &#x60;&#x60;&#x60;    DELETE \&quot;/api/snapmirror/relationships/caf545a2-fc60-11e8-aa13-005056a707ff/?source_info_only&#x3D;true\&quot;    &#x60;&#x60;&#x60;    &lt;br/&gt; ### Learn more * [&#x60;DOC /snapmirror/relationships&#x60;](#docs-snapmirror-snapmirror_relationships) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Relationship UUID
 * @param optional nil or *SnapmirrorRelationshipDeleteOpts - Optional Parameters:
     * @param "DestinationOnly" (optional.Bool) -  Deletes a relationship on the destination only. This parameter is applicable only when the call is executed on the cluster that contains the destination endpoint.
     * @param "SourceOnly" (optional.Bool) -  Deletes a relationship on the source only. This parameter is applicable only when the call is executed on the cluster that contains the source endpoint.
     * @param "SourceInfoOnly" (optional.Bool) -  Deletes relationship information on the source only. This parameter is applicable only when the call is executed on the cluster that contains the source endpoint.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning. When doing a POST, PATCH, or DELETE operation on a single record, the default is 0 seconds.  This means that if an asynchronous operation is started, the server immediately returns HTTP code 202 (Accepted) along with a link to the job.  If a non-zero value is specified for POST, PATCH, or DELETE operations, ONTAP waits that length of time to see if the job completes so it can return something other than 202.

@return JobLinkResponse
*/

type SnapmirrorRelationshipDeleteOpts struct { 
	DestinationOnly optional.Bool
	SourceOnly optional.Bool
	SourceInfoOnly optional.Bool
	ReturnTimeout optional.Int32
}

func (a *SnapmirrorApiService) SnapmirrorRelationshipDelete(ctx context.Context, uuid string, localVarOptionals *SnapmirrorRelationshipDeleteOpts) (JobLinkResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/snapmirror/relationships/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.DestinationOnly.IsSet() {
		localVarQueryParams.Add("destination_only", parameterToString(localVarOptionals.DestinationOnly.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourceOnly.IsSet() {
		localVarQueryParams.Add("source_only", parameterToString(localVarOptionals.SourceOnly.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourceInfoOnly.IsSet() {
		localVarQueryParams.Add("source_info_only", parameterToString(localVarOptionals.SourceInfoOnly.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SnapmirrorApiService
Retrieves a SnapMirror relationship. ### Related ONTAP commands * &#x60;snapmirror show&#x60; * &#x60;snapmirror list-destinations&#x60; ### Example &lt;br/&gt; &#x60;&#x60;&#x60; GET \&quot;/api/snapmirror/relationships/caf545a2-fc60-11e8-aa13-005056a707ff/\&quot; &#x60;&#x60;&#x60; &lt;br/&gt; ### Learn more * [&#x60;DOC /snapmirror/relationships&#x60;](#docs-snapmirror-snapmirror_relationships) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Relationship UUID
 * @param optional nil or *SnapmirrorRelationshipGetOpts - Optional Parameters:
     * @param "ListDestinationsOnly" (optional.Bool) -  Set to true to show relationships from the source only.
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return SnapmirrorRelationship
*/

type SnapmirrorRelationshipGetOpts struct { 
	ListDestinationsOnly optional.Bool
	Fields optional.Interface
}

func (a *SnapmirrorApiService) SnapmirrorRelationshipGet(ctx context.Context, uuid string, localVarOptionals *SnapmirrorRelationshipGetOpts) (SnapmirrorRelationship, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SnapmirrorRelationship
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/snapmirror/relationships/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ListDestinationsOnly.IsSet() {
		localVarQueryParams.Add("list_destinations_only", parameterToString(localVarOptionals.ListDestinationsOnly.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v SnapmirrorRelationship
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SnapmirrorApiService
Updates a SnapMirror relationship. This API is used to initiate SnapMirror operations such as \&quot;initialize\&quot;, \&quot;resync\&quot;, \&quot;break\&quot;, \&quot;quiesce\&quot;, and \&quot;resume\&quot; by specifying the appropriate value for the \&quot;state\&quot; field. It is also used to modify the SnapMirror policy associated with the specified relationship. ### Related ONTAP commands * &#x60;snapmirror modify&#x60; * &#x60;snapmirror initialize&#x60; * &#x60;snapmirror resync&#x60; * &#x60;snapmirror break&#x60; * &#x60;snapmirror quiesce&#x60; * &#x60;snapmirror resume&#x60; ### Examples The following examples show how to perform the SnapMirror \&quot;resync\&quot;, \&quot;initialize\&quot;, \&quot;resume\&quot;, \&quot;quiesce\&quot;, and \&quot;break\&quot; operations. &lt;br/&gt;    Performing a SnapMirror \&quot;resync\&quot;    &lt;br/&gt;    &#x60;&#x60;&#x60;    PATCH \&quot;/api/snapmirror/relationships/98bb2608-fc60-11e8-aa13-005056a707ff/\&quot; &#39;{\&quot;state\&quot;:\&quot;snapmirrored\&quot;}&#39;    &#x60;&#x60;&#x60;    &lt;br/&gt;    Performing a SnapMirror \&quot;initialize\&quot;    &lt;br/&gt;    &#x60;&#x60;&#x60;    PATCH \&quot;/api/snapmirror/relationships/98bb2608-fc60-11e8-aa13-005056a707ff/\&quot; &#39;{\&quot;state\&quot;:\&quot;snapmirrored\&quot;}&#39;    &#x60;&#x60;&#x60;    &lt;br/&gt;    Performing a SnapMirror \&quot;resume\&quot;    &lt;br/&gt;    &#x60;&#x60;&#x60;    PATCH \&quot;/api/snapmirror/relationships/98bb2608-fc60-11e8-aa13-005056a707ff/\&quot; &#39;{\&quot;state\&quot;:\&quot;snapmirrored\&quot;}&#39;    &#x60;&#x60;&#x60;    &lt;br/&gt;    Performing a SnapMirror \&quot;quiesce\&quot;    &lt;br/&gt;    &#x60;&#x60;&#x60;    PATCH \&quot;/api/snapmirror/relationships/98bb2608-fc60-11e8-aa13-005056a707ff\&quot; &#39;{\&quot;state\&quot;:\&quot;paused\&quot;}&#39;    &#x60;&#x60;&#x60;    &lt;br/&gt;    Performing a SnapMirror \&quot;break\&quot;    &lt;br/&gt;    &#x60;&#x60;&#x60;    PATCH \&quot;/api/snapmirror/relationships/98bb2608-fc60-11e8-aa13-005056a707ff\&quot; &#39;{\&quot;state\&quot;:\&quot;broken_off\&quot;}&#39;    &#x60;&#x60;&#x60;    &lt;br/&gt;    Updating an associated SnapMirror policy    &lt;br/&gt;    &#x60;&#x60;&#x60;    PATCH \&quot;/api/snapmirror/relationships/9e922e65-1818-11e9-8b22-005056bbee73/\&quot; &#39;{\&quot;policy\&quot;: { \&quot;name\&quot; : \&quot;MirrorAndVaultDiscardNetwork\&quot;}}&#39;    &#x60;&#x60;&#x60;    &lt;br/&gt; ### Learn more * [&#x60;DOC /snapmirror/relationships&#x60;](#docs-snapmirror-snapmirror_relationships) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Relationship UUID
 * @param info Information on the SnapMirror relationship

@return JobLinkResponse
*/
func (a *SnapmirrorApiService) SnapmirrorRelationshipModify(ctx context.Context, uuid string, info SnapmirrorRelationship) (JobLinkResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/snapmirror/relationships/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SnapmirrorApiService
Starts a SnapMirror transfer operation. This API initiates a restore operation if the SnapMirror relationship is of type \&quot;restore\&quot;. Otherwise, it intiates a SnapMirror \&quot;initialize\&quot; operation or \&quot;update\&quot; operation based on the current SnapMirror state. ### Default property values * &#x60;storage_efficiency_enabled&#x60; - _true_ ### Related ONTAP commands * &#x60;snapmirror update&#x60; * &#x60;snapmirror initialize&#x60; * &#x60;snapmirror restore&#x60; ### Examples The following examples show how to perform SnapMirror \&quot;initialize\&quot;, \&quot;update\&quot;, and \&quot;restore\&quot; operations. &lt;br/&gt;    Performing a SnapMirror initialize or update    &lt;br/&gt;    &#x60;&#x60;&#x60;    POST \&quot;/api/snapmirror/relationships/e4e7e130-0279-11e9-b566-0050568e9909/transfers\&quot; &#39;{}&#39;    &#x60;&#x60;&#x60;    &lt;br/&gt;    Performing a SnapMirror restore transfer    &lt;br/&gt;    &#x60;&#x60;&#x60;    POST \&quot;/api/snapmirror/relationships/c8c62a90-0fef-11e9-b09e-0050568e7067/transfers\&quot; &#39;{\&quot;source-snapshot\&quot;: \&quot;src\&quot;, \&quot;files\&quot;: {\&quot;source_path\&quot;: [\&quot;/a1.txt.0\&quot;], \&quot;destination_path\&quot;: [\&quot;/a1-renamed.txt.0\&quot;]}}&#39;    &#x60;&#x60;&#x60;    &lt;br/&gt; ### Learn more * [&#x60;DOC /snapmirror/relationships/{relationship.uuid}/transfers&#x60;](#docs-snapmirror-snapmirror_relationships_{relationship.uuid}_transfers) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param relationshipUuid Relationship UUID
 * @param optional nil or *SnapmirrorRelationshipTransferCreateOpts - Optional Parameters:
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning. When doing a POST, PATCH, or DELETE operation on a single record, the default is 0 seconds.  This means that if an asynchronous operation is started, the server immediately returns HTTP code 202 (Accepted) along with a link to the job.  If a non-zero value is specified for POST, PATCH, or DELETE operations, ONTAP waits that length of time to see if the job completes so it can return something other than 202.
     * @param "Info" (optional.Interface of SnapmirrorTransfer) -  Information on the SnapMirror transfer


*/

type SnapmirrorRelationshipTransferCreateOpts struct { 
	ReturnTimeout optional.Int32
	Info optional.Interface
}

func (a *SnapmirrorApiService) SnapmirrorRelationshipTransferCreate(ctx context.Context, relationshipUuid string, localVarOptionals *SnapmirrorRelationshipTransferCreateOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/snapmirror/relationships/{relationship.uuid}/transfers"
	localVarPath = strings.Replace(localVarPath, "{"+"relationship.uuid"+"}", fmt.Sprintf("%v", relationshipUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(SnapmirrorTransfer)
		if !localVarOptionalInfook {
				return nil, reportError("info should be SnapmirrorTransfer")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
SnapmirrorApiService
Retrieves the attributes of a specific ongoing SnapMirror transfer. ### Related ONTAP commands * &#x60;snapmirror show&#x60; ### Example &lt;br/&gt; &#x60;&#x60;&#x60; GET \&quot;/api/snapmirror/relationships/293baa53-e63d-11e8-bff1-005056a793dd/transfers/293baa53-e63d-11e8-bff1-005056a793dd\&quot; &#x60;&#x60;&#x60; &lt;br/&gt; ### Learn more * [&#x60;DOC /snapmirror/relationships/{relationship.uuid}/transfers&#x60;](#docs-snapmirror-snapmirror_relationships_{relationship.uuid}_transfers) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param relationshipUuid Relationship UUID
 * @param uuid Transfer UUID
 * @param optional nil or *SnapmirrorRelationshipTransferGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return SnapmirrorTransfer
*/

type SnapmirrorRelationshipTransferGetOpts struct { 
	Fields optional.Interface
}

func (a *SnapmirrorApiService) SnapmirrorRelationshipTransferGet(ctx context.Context, relationshipUuid string, uuid string, localVarOptionals *SnapmirrorRelationshipTransferGetOpts) (SnapmirrorTransfer, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SnapmirrorTransfer
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/snapmirror/relationships/{relationship.uuid}/transfers/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"relationship.uuid"+"}", fmt.Sprintf("%v", relationshipUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v SnapmirrorTransfer
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SnapmirrorApiService
Aborts an ongoing SnapMirror transfer. ### Related ONTAP commands * &#x60;snapmirror abort&#x60; ### Example &lt;br/&gt; &#x60;&#x60;&#x60; PATCH \&quot;/api/snapmirror/relationships/293baa53-e63d-11e8-bff1-005056a793dd/transfers/293baa53-e63d-11e8-bff1-005056a793dd\&quot; &#39;{\&quot;state\&quot;:\&quot;aborted\&quot;}&#39; &#x60;&#x60;&#x60; &lt;br/&gt; ### Learn more * [&#x60;DOC /snapmirror/relationships/{relationship.uuid}/transfers&#x60;](#docs-snapmirror-snapmirror_relationships_{relationship.uuid}_transfers) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param relationshipUuid Relationship UUID
 * @param uuid Transfer UUID
 * @param info Information on the SnapMirror transfer


*/
func (a *SnapmirrorApiService) SnapmirrorRelationshipTransferModify(ctx context.Context, relationshipUuid string, uuid string, info SnapmirrorTransfer) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/snapmirror/relationships/{relationship.uuid}/transfers/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"relationship.uuid"+"}", fmt.Sprintf("%v", relationshipUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &info
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
SnapmirrorApiService
Retrieves the list of ongoing SnapMirror transfers for the specified relationship. ### Related ONTAP commands * &#x60;snapmirror show&#x60; ### Example &lt;br/&gt; &#x60;&#x60;&#x60; GET \&quot;/api/snapmirror/relationships/293baa53-e63d-11e8-bff1-005056a793dd/transfers\&quot; &#x60;&#x60;&#x60; ### Learn more * [&#x60;DOC /snapmirror/relationships/{relationship.uuid}/transfers&#x60;](#docs-snapmirror-snapmirror_relationships_{relationship.uuid}_transfers) &lt;br/&gt; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param relationshipUuid Relationship UUID
 * @param optional nil or *SnapmirrorRelationshipTransfersGetOpts - Optional Parameters:
     * @param "RelationshipRestore" (optional.Bool) -  Filter by relationship.restore
     * @param "RelationshipDestinationPath" (optional.String) -  Filter by relationship.destination.path
     * @param "RelationshipDestinationSvmUuid" (optional.String) -  Filter by relationship.destination.svm.uuid
     * @param "RelationshipDestinationSvmName" (optional.String) -  Filter by relationship.destination.svm.name
     * @param "RelationshipUuid" (optional.String) -  Filter by relationship.uuid
     * @param "Uuid" (optional.String) -  Filter by uuid
     * @param "CheckpointSize" (optional.Int32) -  Filter by checkpoint_size
     * @param "Snapshot" (optional.String) -  Filter by snapshot
     * @param "BytesTransferred" (optional.Int32) -  Filter by bytes_transferred
     * @param "State" (optional.String) -  Filter by state
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return SnapmirrorTransferResponse
*/

type SnapmirrorRelationshipTransfersGetOpts struct { 
	RelationshipRestore optional.Bool
	RelationshipDestinationPath optional.String
	RelationshipDestinationSvmUuid optional.String
	RelationshipDestinationSvmName optional.String
	RelationshipUuid optional.String
	Uuid optional.String
	CheckpointSize optional.Int32
	Snapshot optional.String
	BytesTransferred optional.Int32
	State optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *SnapmirrorApiService) SnapmirrorRelationshipTransfersGet(ctx context.Context, relationshipUuid string, localVarOptionals *SnapmirrorRelationshipTransfersGetOpts) (SnapmirrorTransferResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SnapmirrorTransferResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/snapmirror/relationships/{relationship.uuid}/transfers"
	localVarPath = strings.Replace(localVarPath, "{"+"relationship.uuid"+"}", fmt.Sprintf("%v", relationshipUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.RelationshipRestore.IsSet() {
		localVarQueryParams.Add("relationship.restore", parameterToString(localVarOptionals.RelationshipRestore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RelationshipDestinationPath.IsSet() {
		localVarQueryParams.Add("relationship.destination.path", parameterToString(localVarOptionals.RelationshipDestinationPath.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RelationshipDestinationSvmUuid.IsSet() {
		localVarQueryParams.Add("relationship.destination.svm.uuid", parameterToString(localVarOptionals.RelationshipDestinationSvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RelationshipDestinationSvmName.IsSet() {
		localVarQueryParams.Add("relationship.destination.svm.name", parameterToString(localVarOptionals.RelationshipDestinationSvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RelationshipUuid.IsSet() {
		localVarQueryParams.Add("relationship.uuid", parameterToString(localVarOptionals.RelationshipUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CheckpointSize.IsSet() {
		localVarQueryParams.Add("checkpoint_size", parameterToString(localVarOptionals.CheckpointSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snapshot.IsSet() {
		localVarQueryParams.Add("snapshot", parameterToString(localVarOptionals.Snapshot.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BytesTransferred.IsSet() {
		localVarQueryParams.Add("bytes_transferred", parameterToString(localVarOptionals.BytesTransferred.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v SnapmirrorTransferResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
SnapmirrorApiService
Retrieves information for SnapMirror relationships whose destination endpoints are in the current SVM or the current cluster, depending on the cluster context. ### Related ONTAP commands * &#x60;snapmirror show&#x60; * &#x60;snapmirror list-destinations&#x60; ### Examples The following examples show how to retrieve the list of SnapMirror relationships and the list of SnapMirror destinations.    1. Retrieving the list of SnapMirror relationships. This API must be run on the cluster containing the destination endpoint.    &lt;br/&gt;    &#x60;&#x60;&#x60;    GET \&quot;/api/snapmirror/relationships/\&quot;    &#x60;&#x60;&#x60;    &lt;br/&gt;   2.  Retrieving the list of SnapMirror destinations on source. This must be run on the cluster containing the source endpoint.    &lt;br/&gt;    &#x60;&#x60;&#x60;    GET \&quot;/api/snapmirror/relationships/?list_destinations_only&#x3D;true\&quot;    &#x60;&#x60;&#x60;    &lt;br/&gt; ### Learn more * [&#x60;DOC /snapmirror/relationships&#x60;](#docs-snapmirror-snapmirror_relationships) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *SnapmirrorRelationshipsGetOpts - Optional Parameters:
     * @param "ListDestinationsOnly" (optional.Bool) -  Set to true to show relationships from the source only.
     * @param "Restore" (optional.Bool) -  Filter by restore
     * @param "TransferState" (optional.String) -  Filter by transfer.state
     * @param "TransferUuid" (optional.String) -  Filter by transfer.uuid
     * @param "TransferBytesTransferred" (optional.Int32) -  Filter by transfer.bytes_transferred
     * @param "Uuid" (optional.String) -  Filter by uuid
     * @param "PolicyUuid" (optional.String) -  Filter by policy.uuid
     * @param "PolicyType" (optional.String) -  Filter by policy.type
     * @param "PolicyName" (optional.String) -  Filter by policy.name
     * @param "ExportedSnapshot" (optional.String) -  Filter by exported_snapshot
     * @param "SourcePath" (optional.String) -  Filter by source.path
     * @param "SourceSvmUuid" (optional.String) -  Filter by source.svm.uuid
     * @param "SourceSvmName" (optional.String) -  Filter by source.svm.name
     * @param "Healthy" (optional.Bool) -  Filter by healthy
     * @param "LagTime" (optional.String) -  Filter by lag_time
     * @param "DestinationPath" (optional.String) -  Filter by destination.path
     * @param "DestinationSvmUuid" (optional.String) -  Filter by destination.svm.uuid
     * @param "DestinationSvmName" (optional.String) -  Filter by destination.svm.name
     * @param "UnhealthyReasonParameters" (optional.String) -  Filter by unhealthy_reason.parameters
     * @param "UnhealthyReasonMessage" (optional.String) -  Filter by unhealthy_reason.message
     * @param "UnhealthyReasonCode" (optional.Int32) -  Filter by unhealthy_reason.code
     * @param "State" (optional.String) -  Filter by state
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return SnapmirrorRelationshipResponse
*/

type SnapmirrorRelationshipsGetOpts struct { 
	ListDestinationsOnly optional.Bool
	Restore optional.Bool
	TransferState optional.String
	TransferUuid optional.String
	TransferBytesTransferred optional.Int32
	Uuid optional.String
	PolicyUuid optional.String
	PolicyType optional.String
	PolicyName optional.String
	ExportedSnapshot optional.String
	SourcePath optional.String
	SourceSvmUuid optional.String
	SourceSvmName optional.String
	Healthy optional.Bool
	LagTime optional.String
	DestinationPath optional.String
	DestinationSvmUuid optional.String
	DestinationSvmName optional.String
	UnhealthyReasonParameters optional.String
	UnhealthyReasonMessage optional.String
	UnhealthyReasonCode optional.Int32
	State optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *SnapmirrorApiService) SnapmirrorRelationshipsGet(ctx context.Context, localVarOptionals *SnapmirrorRelationshipsGetOpts) (SnapmirrorRelationshipResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SnapmirrorRelationshipResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/snapmirror/relationships"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ListDestinationsOnly.IsSet() {
		localVarQueryParams.Add("list_destinations_only", parameterToString(localVarOptionals.ListDestinationsOnly.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Restore.IsSet() {
		localVarQueryParams.Add("restore", parameterToString(localVarOptionals.Restore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransferState.IsSet() {
		localVarQueryParams.Add("transfer.state", parameterToString(localVarOptionals.TransferState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransferUuid.IsSet() {
		localVarQueryParams.Add("transfer.uuid", parameterToString(localVarOptionals.TransferUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransferBytesTransferred.IsSet() {
		localVarQueryParams.Add("transfer.bytes_transferred", parameterToString(localVarOptionals.TransferBytesTransferred.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyUuid.IsSet() {
		localVarQueryParams.Add("policy.uuid", parameterToString(localVarOptionals.PolicyUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyType.IsSet() {
		localVarQueryParams.Add("policy.type", parameterToString(localVarOptionals.PolicyType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PolicyName.IsSet() {
		localVarQueryParams.Add("policy.name", parameterToString(localVarOptionals.PolicyName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExportedSnapshot.IsSet() {
		localVarQueryParams.Add("exported_snapshot", parameterToString(localVarOptionals.ExportedSnapshot.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourcePath.IsSet() {
		localVarQueryParams.Add("source.path", parameterToString(localVarOptionals.SourcePath.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourceSvmUuid.IsSet() {
		localVarQueryParams.Add("source.svm.uuid", parameterToString(localVarOptionals.SourceSvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourceSvmName.IsSet() {
		localVarQueryParams.Add("source.svm.name", parameterToString(localVarOptionals.SourceSvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Healthy.IsSet() {
		localVarQueryParams.Add("healthy", parameterToString(localVarOptionals.Healthy.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LagTime.IsSet() {
		localVarQueryParams.Add("lag_time", parameterToString(localVarOptionals.LagTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationPath.IsSet() {
		localVarQueryParams.Add("destination.path", parameterToString(localVarOptionals.DestinationPath.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationSvmUuid.IsSet() {
		localVarQueryParams.Add("destination.svm.uuid", parameterToString(localVarOptionals.DestinationSvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DestinationSvmName.IsSet() {
		localVarQueryParams.Add("destination.svm.name", parameterToString(localVarOptionals.DestinationSvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UnhealthyReasonParameters.IsSet() {
		localVarQueryParams.Add("unhealthy_reason.parameters", parameterToString(localVarOptionals.UnhealthyReasonParameters.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UnhealthyReasonMessage.IsSet() {
		localVarQueryParams.Add("unhealthy_reason.message", parameterToString(localVarOptionals.UnhealthyReasonMessage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UnhealthyReasonCode.IsSet() {
		localVarQueryParams.Add("unhealthy_reason.code", parameterToString(localVarOptionals.UnhealthyReasonCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v SnapmirrorRelationshipResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
