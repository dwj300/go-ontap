/*
 * ONTAP REST API
 *
 * ONTAP 9.6 adds support for an expansive RESTful API. The documentation below provides information about the types of API calls available to you, as well as details about using each API endpoint. You can learn more about the ONTAP REST API and ONTAP in the ONTAP 9 Documentation Center:  http://docs.netapp.com/ontap-9/topic/com.netapp.doc.dot-rest-api/home.html. NetApp welcomes your comments and suggestions about the ONTAP REST API and the documentation for its use.</br> **Using the ONTAP 9.6 REST API online documentation** Each API method includes usage examples, as well as a model that displays all the required and optional properties supported by the method. Click the _Model_ link, available with each API method, to see all the required and optional properties supported by each method. 
 *
 * API version: v1
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type NASApiService service

/* 
NASApiService
Retrieves audit configurations. ### Related ONTAP commands * &#x60;vserver audit show&#x60; ### Learn more * [&#x60;DOC /protocols/audit&#x60;](#docs-NAS-protocols_audit) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *AuditCollectionGetOpts - Optional Parameters:
     * @param "LogRetentionDuration" (optional.String) -  Filter by log.retention.duration
     * @param "LogRetentionCount" (optional.Int32) -  Filter by log.retention.count
     * @param "LogRotationSize" (optional.Int32) -  Filter by log.rotation.size
     * @param "LogRotationScheduleDays" (optional.Int32) -  Filter by log.rotation.schedule.days
     * @param "LogRotationScheduleWeekdays" (optional.Int32) -  Filter by log.rotation.schedule.weekdays
     * @param "LogRotationScheduleMinutes" (optional.Int32) -  Filter by log.rotation.schedule.minutes
     * @param "LogRotationScheduleMonths" (optional.Int32) -  Filter by log.rotation.schedule.months
     * @param "LogRotationScheduleHours" (optional.Int32) -  Filter by log.rotation.schedule.hours
     * @param "LogFormat" (optional.String) -  Filter by log.format
     * @param "LogPath" (optional.String) -  Filter by log_path
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "Enabled" (optional.Bool) -  Filter by enabled
     * @param "EventsFileShare" (optional.Bool) -  Filter by events.file_share
     * @param "EventsAuthorizationPolicy" (optional.Bool) -  Filter by events.authorization_policy
     * @param "EventsCifsLogonLogoff" (optional.Bool) -  Filter by events.cifs_logon_logoff
     * @param "EventsCapStaging" (optional.Bool) -  Filter by events.cap_staging
     * @param "EventsUserAccount" (optional.Bool) -  Filter by events.user_account
     * @param "EventsSecurityGroup" (optional.Bool) -  Filter by events.security_group
     * @param "EventsFileOperations" (optional.Bool) -  Filter by events.file_operations
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return AuditResponse
*/

type AuditCollectionGetOpts struct { 
	LogRetentionDuration optional.String
	LogRetentionCount optional.Int32
	LogRotationSize optional.Int32
	LogRotationScheduleDays optional.Int32
	LogRotationScheduleWeekdays optional.Int32
	LogRotationScheduleMinutes optional.Int32
	LogRotationScheduleMonths optional.Int32
	LogRotationScheduleHours optional.Int32
	LogFormat optional.String
	LogPath optional.String
	SvmUuid optional.String
	SvmName optional.String
	Enabled optional.Bool
	EventsFileShare optional.Bool
	EventsAuthorizationPolicy optional.Bool
	EventsCifsLogonLogoff optional.Bool
	EventsCapStaging optional.Bool
	EventsUserAccount optional.Bool
	EventsSecurityGroup optional.Bool
	EventsFileOperations optional.Bool
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NASApiService) AuditCollectionGet(ctx context.Context, localVarOptionals *AuditCollectionGetOpts) (AuditResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue AuditResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/audit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.LogRetentionDuration.IsSet() {
		localVarQueryParams.Add("log.retention.duration", parameterToString(localVarOptionals.LogRetentionDuration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LogRetentionCount.IsSet() {
		localVarQueryParams.Add("log.retention.count", parameterToString(localVarOptionals.LogRetentionCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LogRotationSize.IsSet() {
		localVarQueryParams.Add("log.rotation.size", parameterToString(localVarOptionals.LogRotationSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LogRotationScheduleDays.IsSet() {
		localVarQueryParams.Add("log.rotation.schedule.days", parameterToString(localVarOptionals.LogRotationScheduleDays.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LogRotationScheduleWeekdays.IsSet() {
		localVarQueryParams.Add("log.rotation.schedule.weekdays", parameterToString(localVarOptionals.LogRotationScheduleWeekdays.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LogRotationScheduleMinutes.IsSet() {
		localVarQueryParams.Add("log.rotation.schedule.minutes", parameterToString(localVarOptionals.LogRotationScheduleMinutes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LogRotationScheduleMonths.IsSet() {
		localVarQueryParams.Add("log.rotation.schedule.months", parameterToString(localVarOptionals.LogRotationScheduleMonths.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LogRotationScheduleHours.IsSet() {
		localVarQueryParams.Add("log.rotation.schedule.hours", parameterToString(localVarOptionals.LogRotationScheduleHours.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LogFormat.IsSet() {
		localVarQueryParams.Add("log.format", parameterToString(localVarOptionals.LogFormat.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LogPath.IsSet() {
		localVarQueryParams.Add("log_path", parameterToString(localVarOptionals.LogPath.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarQueryParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFileShare.IsSet() {
		localVarQueryParams.Add("events.file_share", parameterToString(localVarOptionals.EventsFileShare.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsAuthorizationPolicy.IsSet() {
		localVarQueryParams.Add("events.authorization_policy", parameterToString(localVarOptionals.EventsAuthorizationPolicy.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsCifsLogonLogoff.IsSet() {
		localVarQueryParams.Add("events.cifs_logon_logoff", parameterToString(localVarOptionals.EventsCifsLogonLogoff.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsCapStaging.IsSet() {
		localVarQueryParams.Add("events.cap_staging", parameterToString(localVarOptionals.EventsCapStaging.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsUserAccount.IsSet() {
		localVarQueryParams.Add("events.user_account", parameterToString(localVarOptionals.EventsUserAccount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsSecurityGroup.IsSet() {
		localVarQueryParams.Add("events.security_group", parameterToString(localVarOptionals.EventsSecurityGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFileOperations.IsSet() {
		localVarQueryParams.Add("events.file_operations", parameterToString(localVarOptionals.EventsFileOperations.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v AuditResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Creates an audit configuration. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM to which audit configuration is to be created. * &#x60;log_path&#x60; - Path in the owning SVM namespace that is used to store audit logs. ### Default property values If not specified in POST, the following default property values are assigned: * &#x60;enabled&#x60; - _true_ * &#x60;events.authorization_policy&#x60; - _false_ * &#x60;events.cap_staging&#x60; - _false_ * &#x60;events.file_share&#x60; - _false_ * &#x60;events.security_group&#x60; - _false_ * &#x60;events.user_account&#x60; - _false_ * &#x60;events.cifs_logon_logoff&#x60; - _true_ * &#x60;events.file_operations&#x60; - _true_ * &#x60;log.format&#x60; - _evtx_ * &#x60;log.retention.count&#x60; - _0_ * &#x60;log.retention.duration&#x60; - _PT0S_ * &#x60;log.rotation.size&#x60; - _100MB_ * &#x60;log.rotation.now&#x60; - _false_ ### Related ONTAP commands * &#x60;vserver audit create&#x60; * &#x60;vserver audit enable&#x60; ### Learn more * [&#x60;DOC /protocols/audit&#x60;](#docs-NAS-protocols_audit) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *AuditCreateOpts - Optional Parameters:
     * @param "Info" (optional.Interface of Audit) -  Info specification

@return AuditResponse
*/

type AuditCreateOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) AuditCreate(ctx context.Context, localVarOptionals *AuditCreateOpts) (AuditResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue AuditResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/audit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(Audit)
		if !localVarOptionalInfook {
				return localVarReturnValue, nil, reportError("info should be Audit")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 202 {
			var v AuditResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Deletes an audit configuration. ### Related ONTAP commands * &#x60;vserver audit disable&#x60; * &#x60;vserver audit delete&#x60; ### Learn more * [&#x60;DOC /protocols/audit&#x60;](#docs-NAS-protocols_audit) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.


*/
func (a *NASApiService) AuditDelete(ctx context.Context, svmUuid string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/audit/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves an audit configuration for an SVM. ### Related ONTAP commands * &#x60;vserver audit show&#x60; ### Learn more * [&#x60;DOC /protocols/audit&#x60;](#docs-NAS-protocols_audit) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param optional nil or *AuditGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return Audit
*/

type AuditGetOpts struct { 
	Fields optional.Interface
}

func (a *NASApiService) AuditGet(ctx context.Context, svmUuid string, localVarOptionals *AuditGetOpts) (Audit, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Audit
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/audit/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Audit
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Updates an audit configuration for an SVM. ### Related ONTAP commands * &#x60;vserver audit modify&#x60; ### Learn more * [&#x60;DOC /protocols/audit&#x60;](#docs-NAS-protocols_audit) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param optional nil or *AuditModifyOpts - Optional Parameters:
     * @param "Info" (optional.Interface of Audit) -  Info specification


*/

type AuditModifyOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) AuditModify(ctx context.Context, svmUuid string, localVarOptionals *AuditModifyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/audit/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(Audit)
		if !localVarOptionalInfook {
				return nil, reportError("info should be Audit")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves a CIFS home directory search path of an SVM. ### Related ONTAP commands * &#x60;cifs server home-directory search-path show&#x60; ### Learn more * [&#x60;DOC /protocols/cifs/home-directory/search-paths&#x60;](#docs-NAS-protocols_cifs_home-directory_search-paths) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param index Home directory search path index
 * @param optional nil or *CifsHomedirSearchPathGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return CifsSearchPath
*/

type CifsHomedirSearchPathGetOpts struct { 
	Fields optional.Interface
}

func (a *NASApiService) CifsHomedirSearchPathGet(ctx context.Context, svmUuid string, index int32, localVarOptionals *CifsHomedirSearchPathGetOpts) (CifsSearchPath, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CifsSearchPath
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/cifs/home-directory/search-paths/{svm.uuid}/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", fmt.Sprintf("%v", index), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v CifsSearchPath
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves CIFS home directory search paths. ### Related ONTAP commands * &#x60;cifs server home-directory search-path show&#x60; ### Learn more * [&#x60;DOC /protocols/cifs/home-directory/search-paths&#x60;](#docs-NAS-protocols_cifs_home-directory_search-paths) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *CifsSearchPathCollectionGetOpts - Optional Parameters:
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "Index" (optional.Int32) -  Filter by index
     * @param "Path" (optional.String) -  Filter by path
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return CifsSearchPathResponse
*/

type CifsSearchPathCollectionGetOpts struct { 
	SvmUuid optional.String
	SvmName optional.String
	Index optional.Int32
	Path optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NASApiService) CifsSearchPathCollectionGet(ctx context.Context, localVarOptionals *CifsSearchPathCollectionGetOpts) (CifsSearchPathResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CifsSearchPathResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/cifs/home-directory/search-paths"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Index.IsSet() {
		localVarQueryParams.Add("index", parameterToString(localVarOptionals.Index.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Path.IsSet() {
		localVarQueryParams.Add("path", parameterToString(localVarOptionals.Path.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v CifsSearchPathResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Creates a home directory search path. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the home directory search path. * &#x60;path&#x60; - Path in the owning SVM namespace that is used to search for home directories. ### Related ONTAP commands * &#x60;cifs server home-directory search-path add&#x60; ### Learn more * [&#x60;DOC /protocols/cifs/home-directory/search-paths&#x60;](#docs-NAS-protocols_cifs_home-directory_search-paths) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *CifsSearchPathCreateOpts - Optional Parameters:
     * @param "Info" (optional.Interface of CifsSearchPath) -  Info specification

@return CifsSearchPathResponse
*/

type CifsSearchPathCreateOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) CifsSearchPathCreate(ctx context.Context, localVarOptionals *CifsSearchPathCreateOpts) (CifsSearchPathResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CifsSearchPathResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/cifs/home-directory/search-paths"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(CifsSearchPath)
		if !localVarOptionalInfook {
				return localVarReturnValue, nil, reportError("info should be CifsSearchPath")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v CifsSearchPathResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Deletes a CIFS home directory search path. ### Related ONTAP commands * &#x60;cifs server home-directory search-path remove&#x60; ### Learn more * [&#x60;DOC /protocols/cifs/home-directory/search-paths&#x60;](#docs-NAS-protocols_cifs_home-directory_search-paths) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param index Home directory search path index


*/
func (a *NASApiService) CifsSearchPathDelete(ctx context.Context, svmUuid string, index int32) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/cifs/home-directory/search-paths/{svm.uuid}/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", fmt.Sprintf("%v", index), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Reorders a CIFS home directory search path. ### Related ONTAP commands * &#x60;cifs server home-directory search-path reorder&#x60; ### Learn more * [&#x60;DOC /protocols/cifs/home-directory/search-paths&#x60;](#docs-NAS-protocols_cifs_home-directory_search-paths) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param index Home directory search path index
 * @param optional nil or *CifsSearchPathModifyOpts - Optional Parameters:
     * @param "NewIndex" (optional.Int32) -  New position for the home directory search path


*/

type CifsSearchPathModifyOpts struct { 
	NewIndex optional.Int32
}

func (a *NASApiService) CifsSearchPathModify(ctx context.Context, svmUuid string, index int32, localVarOptionals *CifsSearchPathModifyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/cifs/home-directory/search-paths/{svm.uuid}/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", fmt.Sprintf("%v", index), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.NewIndex.IsSet() {
		localVarQueryParams.Add("new_index", parameterToString(localVarOptionals.NewIndex.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves CIFS servers. ### Related ONTAP commands * &#x60;vserver cifs server show&#x60; * &#x60;vserver cifs server options show&#x60; * &#x60;vserver cifs server security show&#x60; ### Learn more * [&#x60;DOC /protocols/cifs/services&#x60;](#docs-NAS-protocols_cifs_services) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *CifsServiceCollectionGetOpts - Optional Parameters:
     * @param "Name" (optional.String) -  Filter by name
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "Enabled" (optional.Bool) -  Filter by enabled
     * @param "Comment" (optional.String) -  Filter by comment
     * @param "DefaultUnixUser" (optional.String) -  Filter by default_unix_user
     * @param "SecurityRestrictAnonymous" (optional.String) -  Filter by security.restrict_anonymous
     * @param "SecuritySmbEncryption" (optional.Bool) -  Filter by security.smb_encryption
     * @param "SecurityKdcEncryption" (optional.Bool) -  Filter by security.kdc_encryption
     * @param "SecuritySmbSigning" (optional.Bool) -  Filter by security.smb_signing
     * @param "AdDomainUser" (optional.String) -  Filter by ad_domain.user
     * @param "AdDomainFqdn" (optional.String) -  Filter by ad_domain.fqdn
     * @param "AdDomainOrganizationalUnit" (optional.String) -  Filter by ad_domain.organizational_unit
     * @param "NetbiosWinsServers" (optional.String) -  Filter by netbios.wins_servers
     * @param "NetbiosAliases" (optional.String) -  Filter by netbios.aliases
     * @param "NetbiosEnabled" (optional.Bool) -  Filter by netbios.enabled
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return CifsServiceResponse
*/

type CifsServiceCollectionGetOpts struct { 
	Name optional.String
	SvmUuid optional.String
	SvmName optional.String
	Enabled optional.Bool
	Comment optional.String
	DefaultUnixUser optional.String
	SecurityRestrictAnonymous optional.String
	SecuritySmbEncryption optional.Bool
	SecurityKdcEncryption optional.Bool
	SecuritySmbSigning optional.Bool
	AdDomainUser optional.String
	AdDomainFqdn optional.String
	AdDomainOrganizationalUnit optional.String
	NetbiosWinsServers optional.String
	NetbiosAliases optional.String
	NetbiosEnabled optional.Bool
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NASApiService) CifsServiceCollectionGet(ctx context.Context, localVarOptionals *CifsServiceCollectionGetOpts) (CifsServiceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CifsServiceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/cifs/services"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarQueryParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Comment.IsSet() {
		localVarQueryParams.Add("comment", parameterToString(localVarOptionals.Comment.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DefaultUnixUser.IsSet() {
		localVarQueryParams.Add("default_unix_user", parameterToString(localVarOptionals.DefaultUnixUser.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SecurityRestrictAnonymous.IsSet() {
		localVarQueryParams.Add("security.restrict_anonymous", parameterToString(localVarOptionals.SecurityRestrictAnonymous.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SecuritySmbEncryption.IsSet() {
		localVarQueryParams.Add("security.smb_encryption", parameterToString(localVarOptionals.SecuritySmbEncryption.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SecurityKdcEncryption.IsSet() {
		localVarQueryParams.Add("security.kdc_encryption", parameterToString(localVarOptionals.SecurityKdcEncryption.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SecuritySmbSigning.IsSet() {
		localVarQueryParams.Add("security.smb_signing", parameterToString(localVarOptionals.SecuritySmbSigning.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AdDomainUser.IsSet() {
		localVarQueryParams.Add("ad_domain.user", parameterToString(localVarOptionals.AdDomainUser.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AdDomainFqdn.IsSet() {
		localVarQueryParams.Add("ad_domain.fqdn", parameterToString(localVarOptionals.AdDomainFqdn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AdDomainOrganizationalUnit.IsSet() {
		localVarQueryParams.Add("ad_domain.organizational_unit", parameterToString(localVarOptionals.AdDomainOrganizationalUnit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NetbiosWinsServers.IsSet() {
		localVarQueryParams.Add("netbios.wins_servers", parameterToString(localVarOptionals.NetbiosWinsServers.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NetbiosAliases.IsSet() {
		localVarQueryParams.Add("netbios.aliases", parameterToString(localVarOptionals.NetbiosAliases.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NetbiosEnabled.IsSet() {
		localVarQueryParams.Add("netbios.enabled", parameterToString(localVarOptionals.NetbiosEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v CifsServiceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Creates a CIFS server. Each SVM can have one CIFS server.&lt;/br&gt; ### Important notes - The CIFS server name might or might not be the same as the SVM name. - The CIFS server name can contain up to 15 characters. - The CIFS server name does not support the following characters: @ # * ( ) &#x3D; + [ ] | ; : \&quot; , &lt; &gt;  / ? ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the CIFS server. * &#x60;name&#x60; -  Name of the CIFS server. * &#x60;ad_domain.fqdn&#x60; - Fully qualified domain name of the Windows Active Directory to which this CIFS server belongs. * &#x60;ad_domain.user&#x60; - User account with the access to add the CIFS server to the Active Directory. * &#x60;ad_domain.password&#x60; - Account password used to add this CIFS server to the Active Directory. ### Recommended optional properties * &#x60;comment&#x60; - Add a text comment of up to 48 characters about the CIFS server. * &#x60;netbios.aliases&#x60; - Add a comma-delimited list of one or more NetBIOS aliases for the CIFS server. * &#x60;netbios.wins_servers&#x60; - Add a list of Windows Internet Name Server (WINS) addresses that manage and map the NetBIOS name of the CIFS server to their network IP addresses. The IP addresses must be IPv4 addresses. ### Default property values If not specified in POST, the following default property values are assigned: * &#x60;ad_domain.organizational_unit&#x60; - _CN&#x3D;Computers_ * &#x60;enabled&#x60; - _true_ * &#x60;restrict_anonymous&#x60; - _no_enumeration_ * &#x60;smb_signing&#x60; - _false_ * &#x60;smb_encryption&#x60; - _false_ * &#x60;kdc_encryption&#x60; - _false_ * &#x60;default_unix_user&#x60; - _pcuser_ * &#x60;netbios_enabled&#x60; - _false_ However, if either \&quot;netbios.wins-server\&quot; or \&quot;netbios.aliases\&quot; is set during POST and if &#x60;netbios_enabled&#x60; is not specified then &#x60;netbios_enabled&#x60; is set to true. ### Related ONTAP commands * &#x60;vserver cifs server create&#x60; * &#x60;vserver cifs server options modify&#x60; * &#x60;vserver cifs security modify&#x60; * &#x60;vserver cifs server add-netbios-aliases&#x60; ### Learn more * [&#x60;DOC /protocols/cifs/services&#x60;](#docs-NAS-protocols_cifs_services) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *CifsServiceCreateOpts - Optional Parameters:
     * @param "Info" (optional.Interface of CifsService) -  Info specification

@return JobLinkResponse
*/

type CifsServiceCreateOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) CifsServiceCreate(ctx context.Context, localVarOptionals *CifsServiceCreateOpts) (JobLinkResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/cifs/services"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(CifsService)
		if !localVarOptionalInfook {
				return localVarReturnValue, nil, reportError("info should be CifsService")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Deletes a CIFS server and related CIFS configurations. ### Related ONTAP commands * &#x60;vserver cifs server delete&#x60; * &#x60;vserver cifs remove-netbios-aliases&#x60; ### Learn more * [&#x60;DOC /protocols/cifs/services&#x60;](#docs-NAS-protocols_cifs_services) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param optional nil or *CifsServiceDeleteOpts - Optional Parameters:
     * @param "Info" (optional.Interface of CifsServiceDelete) -  Info specification

@return JobLinkResponse
*/

type CifsServiceDeleteOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) CifsServiceDelete(ctx context.Context, svmUuid string, localVarOptionals *CifsServiceDeleteOpts) (JobLinkResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/cifs/services/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(CifsServiceDelete)
		if !localVarOptionalInfook {
				return localVarReturnValue, nil, reportError("info should be CifsServiceDelete")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves a CIFS server. ### Related ONTAP commands * &#x60;vserver cifs server show&#x60; * &#x60;vserver cifs server options show&#x60; * &#x60;vserver cifs server security show&#x60; ### Learn more * [&#x60;DOC /protocols/cifs/services&#x60;](#docs-NAS-protocols_cifs_services) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid
 * @param optional nil or *CifsServiceGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return CifsService
*/

type CifsServiceGetOpts struct { 
	Fields optional.Interface
}

func (a *NASApiService) CifsServiceGet(ctx context.Context, svmUuid string, localVarOptionals *CifsServiceGetOpts) (CifsService, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CifsService
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/cifs/services/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v CifsService
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Updates both the mandatory and optional parameters of the CIFS configuration. Ensure the CIFS server is administratively disabled when renaming the CIFS server or modifying the &lt;i&gt;ad_domain&lt;/i&gt; properties. ### Related ONTAP commands * &#x60;vserver cifs server modify&#x60; * &#x60;vserver cifs server options modify&#x60; * &#x60;vserver cifs security modify&#x60; * &#x60;vserver cifs server add-netbios-aliases&#x60; * &#x60;vserver cifs server remove-netbios-aliases&#x60; ### Learn more * [&#x60;DOC /protocols/cifs/services&#x60;](#docs-NAS-protocols_cifs_services) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param optional nil or *CifsServiceModifyOpts - Optional Parameters:
     * @param "Info" (optional.Interface of CifsService) -  Info specification

@return JobLinkResponse
*/

type CifsServiceModifyOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) CifsServiceModify(ctx context.Context, svmUuid string, localVarOptionals *CifsServiceModifyOpts) (JobLinkResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/cifs/services/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(CifsService)
		if !localVarOptionalInfook {
				return localVarReturnValue, nil, reportError("info should be CifsService")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 202 {
			var v JobLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves the share-level ACL on a CIFS share. ### Related ONTAP commands * &#x60;vserver cifs share access-control show&#x60; ### Learn more * [&#x60;DOC /protocols/cifs/shares/{svm.uuid}/{share}/acls&#x60;](#docs-NAS-protocols_cifs_shares_{svm.uuid}_{share}_acls) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param share CIFS Share Name
 * @param optional nil or *CifsShareAclCollectionGetOpts - Optional Parameters:
     * @param "Permission" (optional.String) -  Filter by permission
     * @param "Type_" (optional.String) -  Filter by type
     * @param "UserOrGroup" (optional.String) -  Filter by user_or_group
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return CifsShareAclResponse
*/

type CifsShareAclCollectionGetOpts struct { 
	Permission optional.String
	Type_ optional.String
	UserOrGroup optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NASApiService) CifsShareAclCollectionGet(ctx context.Context, svmUuid string, share string, localVarOptionals *CifsShareAclCollectionGetOpts) (CifsShareAclResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CifsShareAclResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/cifs/shares/{svm.uuid}/{share}/acls"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"share"+"}", fmt.Sprintf("%v", share), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Permission.IsSet() {
		localVarQueryParams.Add("permission", parameterToString(localVarOptionals.Permission.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserOrGroup.IsSet() {
		localVarQueryParams.Add("user_or_group", parameterToString(localVarOptionals.UserOrGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v CifsShareAclResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Creates a share-level ACL on a CIFS share. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the share acl. * &#x60;share&#x60; - Existing CIFS share in which to create the share acl. * &#x60;user_or_group&#x60; - Existing user or group name for which the acl is added on the CIFS share. * &#x60;permission&#x60; - Access rights that a user or group has on the defined CIFS share. ### Default property values * &#x60;type&#x60; - _windows_ ### Related ONTAP commands * &#x60;vserver cifs share access-control create&#x60; ### Learn more * [&#x60;DOC /protocols/cifs/shares/{svm.uuid}/{share}/acls&#x60;](#docs-NAS-protocols_cifs_shares_{svm.uuid}_{share}_acls) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param share CIFS Share Name
 * @param optional nil or *CifsShareAclCreateOpts - Optional Parameters:
     * @param "Info" (optional.Interface of CifsShareAcl) -  Info specification


*/

type CifsShareAclCreateOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) CifsShareAclCreate(ctx context.Context, svmUuid string, share string, localVarOptionals *CifsShareAclCreateOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/cifs/shares/{svm.uuid}/{share}/acls"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"share"+"}", fmt.Sprintf("%v", share), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(CifsShareAcl)
		if !localVarOptionalInfook {
				return nil, reportError("info should be CifsShareAcl")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Deletes a share-level ACL on a CIFS share. ### Related ONTAP commands * &#x60;vserver cifs share access-control delete&#x60; ### Learn more * [&#x60;DOC /protocols/cifs/shares/{svm.uuid}/{share}/acls&#x60;](#docs-NAS-protocols_cifs_shares_{svm.uuid}_{share}_acls) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param share Share name
 * @param userOrGroup User or group name
 * @param type_ User or group type


*/
func (a *NASApiService) CifsShareAclDelete(ctx context.Context, svmUuid string, share string, userOrGroup string, type_ string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/cifs/shares/{svm.uuid}/{share}/acls/{user_or_group}/{type}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"share"+"}", fmt.Sprintf("%v", share), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_or_group"+"}", fmt.Sprintf("%v", userOrGroup), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", fmt.Sprintf("%v", type_), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves the share-level ACL on CIFS share for a specified user or group. ### Related ONTAP commands * &#x60;vserver cifs share access-control show&#x60; ### Learn more * [&#x60;DOC /protocols/cifs/shares/{svm.uuid}/{share}/acls&#x60;](#docs-NAS-protocols_cifs_shares_{svm.uuid}_{share}_acls) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param share Share name
 * @param userOrGroup User or group name
 * @param type_ User or group type
 * @param optional nil or *CifsShareAclGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return CifsShareAcl
*/

type CifsShareAclGetOpts struct { 
	Fields optional.Interface
}

func (a *NASApiService) CifsShareAclGet(ctx context.Context, svmUuid string, share string, userOrGroup string, type_ string, localVarOptionals *CifsShareAclGetOpts) (CifsShareAcl, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CifsShareAcl
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/cifs/shares/{svm.uuid}/{share}/acls/{user_or_group}/{type}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"share"+"}", fmt.Sprintf("%v", share), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_or_group"+"}", fmt.Sprintf("%v", userOrGroup), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", fmt.Sprintf("%v", type_), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v CifsShareAcl
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Updates a share-level ACL on a CIFS share. ### Related ONTAP commands * &#x60;vserver cifs share access-control modify&#x60; ### Learn more * [&#x60;DOC /protocols/cifs/shares/{svm.uuid}/{share}/acls&#x60;](#docs-NAS-protocols_cifs_shares_{svm.uuid}_{share}_acls) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param share Share name
 * @param userOrGroup User or group name
 * @param type_ User or group type
 * @param optional nil or *CifsShareAclModifyOpts - Optional Parameters:
     * @param "Info" (optional.Interface of CifsShareAcl) -  Info specification


*/

type CifsShareAclModifyOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) CifsShareAclModify(ctx context.Context, svmUuid string, share string, userOrGroup string, type_ string, localVarOptionals *CifsShareAclModifyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/cifs/shares/{svm.uuid}/{share}/acls/{user_or_group}/{type}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"share"+"}", fmt.Sprintf("%v", share), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_or_group"+"}", fmt.Sprintf("%v", userOrGroup), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", fmt.Sprintf("%v", type_), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(CifsShareAcl)
		if !localVarOptionalInfook {
				return nil, reportError("info should be CifsShareAcl")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves CIFS shares. ### Related ONTAP commands * &#x60;vserver cifs share show&#x60; * &#x60;vserver cifs share properties show&#x60; ### Learn more * [&#x60;DOC /protocols/cifs/shares&#x60;](#docs-NAS-protocols_cifs_shares) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *CifsShareCollectionGetOpts - Optional Parameters:
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "Name" (optional.String) -  Filter by name
     * @param "UnixSymlink" (optional.String) -  Filter by unix_symlink
     * @param "Comment" (optional.String) -  Filter by comment
     * @param "VolumeName" (optional.String) -  Filter by volume.name
     * @param "VolumeUuid" (optional.String) -  Filter by volume.uuid
     * @param "AclsPermission" (optional.String) -  Filter by acls.permission
     * @param "AclsType" (optional.String) -  Filter by acls.type
     * @param "AclsUserOrGroup" (optional.String) -  Filter by acls.user_or_group
     * @param "Oplocks" (optional.Bool) -  Filter by oplocks
     * @param "Path" (optional.String) -  Filter by path
     * @param "Encryption" (optional.Bool) -  Filter by encryption
     * @param "HomeDirectory" (optional.Bool) -  Filter by home_directory
     * @param "AccessBasedEnumeration" (optional.Bool) -  Filter by access_based_enumeration
     * @param "ChangeNotify" (optional.Bool) -  Filter by change_notify
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return CifsShareResponse
*/

type CifsShareCollectionGetOpts struct { 
	SvmUuid optional.String
	SvmName optional.String
	Name optional.String
	UnixSymlink optional.String
	Comment optional.String
	VolumeName optional.String
	VolumeUuid optional.String
	AclsPermission optional.String
	AclsType optional.String
	AclsUserOrGroup optional.String
	Oplocks optional.Bool
	Path optional.String
	Encryption optional.Bool
	HomeDirectory optional.Bool
	AccessBasedEnumeration optional.Bool
	ChangeNotify optional.Bool
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NASApiService) CifsShareCollectionGet(ctx context.Context, localVarOptionals *CifsShareCollectionGetOpts) (CifsShareResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CifsShareResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/cifs/shares"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UnixSymlink.IsSet() {
		localVarQueryParams.Add("unix_symlink", parameterToString(localVarOptionals.UnixSymlink.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Comment.IsSet() {
		localVarQueryParams.Add("comment", parameterToString(localVarOptionals.Comment.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VolumeName.IsSet() {
		localVarQueryParams.Add("volume.name", parameterToString(localVarOptionals.VolumeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VolumeUuid.IsSet() {
		localVarQueryParams.Add("volume.uuid", parameterToString(localVarOptionals.VolumeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AclsPermission.IsSet() {
		localVarQueryParams.Add("acls.permission", parameterToString(localVarOptionals.AclsPermission.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AclsType.IsSet() {
		localVarQueryParams.Add("acls.type", parameterToString(localVarOptionals.AclsType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AclsUserOrGroup.IsSet() {
		localVarQueryParams.Add("acls.user_or_group", parameterToString(localVarOptionals.AclsUserOrGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Oplocks.IsSet() {
		localVarQueryParams.Add("oplocks", parameterToString(localVarOptionals.Oplocks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Path.IsSet() {
		localVarQueryParams.Add("path", parameterToString(localVarOptionals.Path.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Encryption.IsSet() {
		localVarQueryParams.Add("encryption", parameterToString(localVarOptionals.Encryption.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HomeDirectory.IsSet() {
		localVarQueryParams.Add("home_directory", parameterToString(localVarOptionals.HomeDirectory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AccessBasedEnumeration.IsSet() {
		localVarQueryParams.Add("access_based_enumeration", parameterToString(localVarOptionals.AccessBasedEnumeration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChangeNotify.IsSet() {
		localVarQueryParams.Add("change_notify", parameterToString(localVarOptionals.ChangeNotify.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v CifsShareResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Creates a CIFS share. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the CIFS share. * &#x60;name&#x60; - Name of the CIFS share. * &#x60;path&#x60; - Path in the owning SVM namespace that is shared through this share. ### Recommended optional properties * &#x60;comment&#x60; - Optionally choose to add a text comment of up to 256 characters about the CIFS share. * &#x60;acls&#x60; - Optionally choose to add share permissions that users and groups have on the CIFS share. ### Default property values If not specified in POST, the following default property values are assigned: * &#x60;home_directory&#x60; - _false_ * &#x60;oplocks&#x60; - _true_ * &#x60;access_based_enumeration&#x60; - _false_ * &#x60;change_notify&#x60; - _true_ * &#x60;encryption&#x60; - _false_ * &#x60;unix_symlink&#x60; - _local_ ### Related ONTAP commands * &#x60;vserver cifs share create&#x60; * &#x60;vserver cifs share properties add&#x60; * &#x60;vserver cifs share access-control create&#x60; ### Learn more * [&#x60;DOC /protocols/cifs/shares&#x60;](#docs-NAS-protocols_cifs_shares) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *CifsShareCreateOpts - Optional Parameters:
     * @param "Info" (optional.Interface of CifsShare) -  Info specification


*/

type CifsShareCreateOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) CifsShareCreate(ctx context.Context, localVarOptionals *CifsShareCreateOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/cifs/shares"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(CifsShare)
		if !localVarOptionalInfook {
				return nil, reportError("info should be CifsShare")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Deletes a CIFS share. ### Related ONTAP commands * &#x60;vserver cifs share delete&#x60; ### Learn more * [&#x60;DOC /protocols/cifs/shares&#x60;](#docs-NAS-protocols_cifs_shares) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param name Share Name


*/
func (a *NASApiService) CifsShareDelete(ctx context.Context, svmUuid string, name string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/cifs/shares/{svm.uuid}/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves a CIFS share. ### Related ONTAP commands * &#x60;vserver cifs share show&#x60; * &#x60;vserver cifs share properties show&#x60; ### Learn more * [&#x60;DOC /protocols/cifs/shares&#x60;](#docs-NAS-protocols_cifs_shares) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param name Share Name
 * @param optional nil or *CifsShareGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return CifsShare
*/

type CifsShareGetOpts struct { 
	Fields optional.Interface
}

func (a *NASApiService) CifsShareGet(ctx context.Context, svmUuid string, name string, localVarOptionals *CifsShareGetOpts) (CifsShare, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CifsShare
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/cifs/shares/{svm.uuid}/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v CifsShare
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Updates a CIFS share. ### Related ONTAP commands * &#x60;vserver cifs share modify&#x60; * &#x60;vserver cifs share properties add&#x60; * &#x60;vserver cifs share properties remove&#x60; ### Learn more * [&#x60;DOC /protocols/cifs/shares&#x60;](#docs-NAS-protocols_cifs_shares) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param name Share Name
 * @param optional nil or *CifsShareModifyOpts - Optional Parameters:
     * @param "Info" (optional.Interface of CifsShare) -  Info specification


*/

type CifsShareModifyOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) CifsShareModify(ctx context.Context, svmUuid string, name string, localVarOptionals *CifsShareModifyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/cifs/shares/{svm.uuid}/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(CifsShare)
		if !localVarOptionalInfook {
				return nil, reportError("info should be CifsShare")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves UNIX symbolic link mappings for CIFS clients. ### Related ONTAP commands * &#x60;vserver cifs symlink show&#x60; ### Learn more * [&#x60;DOC /protocols/cifs/unix-symlink-mapping&#x60;](#docs-NAS-protocols_cifs_unix-symlink-mapping) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *CifsSymlinkMappingCollectionGetOpts - Optional Parameters:
     * @param "TargetLocality" (optional.String) -  Filter by target.locality
     * @param "TargetHomeDirectory" (optional.Bool) -  Filter by target.home_directory
     * @param "TargetServer" (optional.String) -  Filter by target.server
     * @param "TargetShare" (optional.String) -  Filter by target.share
     * @param "TargetPath" (optional.String) -  Filter by target.path
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "UnixPath" (optional.String) -  Filter by unix_path
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return CifsSymlinkMappingResponse
*/

type CifsSymlinkMappingCollectionGetOpts struct { 
	TargetLocality optional.String
	TargetHomeDirectory optional.Bool
	TargetServer optional.String
	TargetShare optional.String
	TargetPath optional.String
	SvmUuid optional.String
	SvmName optional.String
	UnixPath optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NASApiService) CifsSymlinkMappingCollectionGet(ctx context.Context, localVarOptionals *CifsSymlinkMappingCollectionGetOpts) (CifsSymlinkMappingResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CifsSymlinkMappingResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/cifs/unix-symlink-mapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.TargetLocality.IsSet() {
		localVarQueryParams.Add("target.locality", parameterToString(localVarOptionals.TargetLocality.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TargetHomeDirectory.IsSet() {
		localVarQueryParams.Add("target.home_directory", parameterToString(localVarOptionals.TargetHomeDirectory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TargetServer.IsSet() {
		localVarQueryParams.Add("target.server", parameterToString(localVarOptionals.TargetServer.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TargetShare.IsSet() {
		localVarQueryParams.Add("target.share", parameterToString(localVarOptionals.TargetShare.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TargetPath.IsSet() {
		localVarQueryParams.Add("target.path", parameterToString(localVarOptionals.TargetPath.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UnixPath.IsSet() {
		localVarQueryParams.Add("unix_path", parameterToString(localVarOptionals.UnixPath.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v CifsSymlinkMappingResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Creates a UNIX symbolic link mapping for a CIFS client. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the CIFS unix-symlink-mapping. * &#x60;unix_path&#x60; - UNIX path to which the CIFS symlink mapping to be created. * &#x60;target.share&#x60; - CIFS share name on the destination CIFS server to which the UNIX symbolic link is pointing. * &#x60;target.path&#x60; - CIFS path on the destination to which the symbolic link maps. ### Default property values * &#x60;target.server&#x60; - _Local_NetBIOS_Server_Name_ * &#x60;locality&#x60; - _local_ * &#x60;home_directory&#x60; - _false_ ### Related ONTAP commands * &#x60;vserver cifs symlink create&#x60; ### Learn more * [&#x60;DOC /protocols/cifs/unix-symlink-mapping&#x60;](#docs-NAS-protocols_cifs_unix-symlink-mapping) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *CifsSymlinkMappingCreateOpts - Optional Parameters:
     * @param "Info" (optional.Interface of CifsSymlinkMapping) -  Info specification

@return CifsSymlinkMappingResponse
*/

type CifsSymlinkMappingCreateOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) CifsSymlinkMappingCreate(ctx context.Context, localVarOptionals *CifsSymlinkMappingCreateOpts) (CifsSymlinkMappingResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CifsSymlinkMappingResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/cifs/unix-symlink-mapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(CifsSymlinkMapping)
		if !localVarOptionalInfook {
				return localVarReturnValue, nil, reportError("info should be CifsSymlinkMapping")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v CifsSymlinkMappingResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Deletes the UNIX symbolic link mapping for CIFS clients. ### Related ONTAP commands * &#x60;vserver cifs symlink delete&#x60; ### Learn more * [&#x60;DOC /protocols/cifs/unix-symlink-mapping&#x60;](#docs-NAS-protocols_cifs_unix-symlink-mapping) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param unixPath UNIX symbolic link path


*/
func (a *NASApiService) CifsSymlinkMappingDelete(ctx context.Context, svmUuid string, unixPath string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/cifs/unix-symlink-mapping/{svm.uuid}/{unix_path}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"unix_path"+"}", fmt.Sprintf("%v", unixPath), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves a UNIX symbolic link mapping for CIFS clients. ### Related ONTAP commands * &#x60;vserver cifs symlink show&#x60; ### Learn more * [&#x60;DOC /protocols/cifs/unix-symlink-mapping&#x60;](#docs-NAS-protocols_cifs_unix-symlink-mapping) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param unixPath UNIX symbolic link path
 * @param optional nil or *CifsSymlinkMappingGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return CifsSymlinkMapping
*/

type CifsSymlinkMappingGetOpts struct { 
	Fields optional.Interface
}

func (a *NASApiService) CifsSymlinkMappingGet(ctx context.Context, svmUuid string, unixPath string, localVarOptionals *CifsSymlinkMappingGetOpts) (CifsSymlinkMapping, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CifsSymlinkMapping
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/cifs/unix-symlink-mapping/{svm.uuid}/{unix_path}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"unix_path"+"}", fmt.Sprintf("%v", unixPath), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v CifsSymlinkMapping
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Updates the UNIX symbolic link mapping for CIFS clients. ### Related ONTAP commands * &#x60;vserver cifs symlink modify&#x60; ### Learn more * [&#x60;DOC /protocols/cifs/unix-symlink-mapping&#x60;](#docs-NAS-protocols_cifs_unix-symlink-mapping) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param unixPath UNIX symbolic link path
 * @param optional nil or *CifsSymlinkMappingModifyOpts - Optional Parameters:
     * @param "Info" (optional.Interface of CifsSymlinkMapping) -  Info specification


*/

type CifsSymlinkMappingModifyOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) CifsSymlinkMappingModify(ctx context.Context, svmUuid string, unixPath string, localVarOptionals *CifsSymlinkMappingModifyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/cifs/unix-symlink-mapping/{svm.uuid}/{unix_path}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"unix_path"+"}", fmt.Sprintf("%v", unixPath), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(CifsSymlinkMapping)
		if !localVarOptionalInfook {
				return nil, reportError("info should be CifsSymlinkMapping")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves export policies. ### Related ONTAP commands * &#x60;vserver export-policy show&#x60; * &#x60;vserver export-policy rule show&#x60; ### Learn more * [&#x60;DOC /protocols/nfs/export-policies&#x60;](#docs-NAS-protocols_nfs_export-policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExportPolicyCollectionGetOpts - Optional Parameters:
     * @param "RulesProtocols" (optional.String) -  Filter by rules.protocols
     * @param "RulesAnonymousUser" (optional.String) -  Filter by rules.anonymous_user
     * @param "RulesRwRule" (optional.String) -  Filter by rules.rw_rule
     * @param "RulesIndex" (optional.Int32) -  Filter by rules.index
     * @param "RulesSuperuser" (optional.String) -  Filter by rules.superuser
     * @param "RulesRoRule" (optional.String) -  Filter by rules.ro_rule
     * @param "RulesClientsMatch" (optional.String) -  Filter by rules.clients.match
     * @param "Name" (optional.String) -  Filter by name
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "Id" (optional.Int32) -  Filter by id
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return ExportPolicyResponse
*/

type ExportPolicyCollectionGetOpts struct { 
	RulesProtocols optional.String
	RulesAnonymousUser optional.String
	RulesRwRule optional.String
	RulesIndex optional.Int32
	RulesSuperuser optional.String
	RulesRoRule optional.String
	RulesClientsMatch optional.String
	Name optional.String
	SvmUuid optional.String
	SvmName optional.String
	Id optional.Int32
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NASApiService) ExportPolicyCollectionGet(ctx context.Context, localVarOptionals *ExportPolicyCollectionGetOpts) (ExportPolicyResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ExportPolicyResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nfs/export-policies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.RulesProtocols.IsSet() {
		localVarQueryParams.Add("rules.protocols", parameterToString(localVarOptionals.RulesProtocols.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RulesAnonymousUser.IsSet() {
		localVarQueryParams.Add("rules.anonymous_user", parameterToString(localVarOptionals.RulesAnonymousUser.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RulesRwRule.IsSet() {
		localVarQueryParams.Add("rules.rw_rule", parameterToString(localVarOptionals.RulesRwRule.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RulesIndex.IsSet() {
		localVarQueryParams.Add("rules.index", parameterToString(localVarOptionals.RulesIndex.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RulesSuperuser.IsSet() {
		localVarQueryParams.Add("rules.superuser", parameterToString(localVarOptionals.RulesSuperuser.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RulesRoRule.IsSet() {
		localVarQueryParams.Add("rules.ro_rule", parameterToString(localVarOptionals.RulesRoRule.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RulesClientsMatch.IsSet() {
		localVarQueryParams.Add("rules.clients.match", parameterToString(localVarOptionals.RulesClientsMatch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ExportPolicyResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Creates an export policy. An SVM can have any number of export policies to define rules for which clients can access data exported by the SVM. A policy with no rules prohibits access. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create an export policy. * &#x60;name&#x60;  - Name of the export policy. ### Recommended optional properties * &#x60;rules&#x60;  - Rule(s) of an export policy. Used to create the export rule and populate the export policy with export rules in a single request. ### Related ONTAP commands * &#x60;vserver export-policy create&#x60; * &#x60;vserver export-policy rule create&#x60; ### Learn more * [&#x60;DOC /protocols/nfs/export-policies&#x60;](#docs-NAS-protocols_nfs_export-policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ExportPolicyCreateOpts - Optional Parameters:
     * @param "Info" (optional.Interface of ExportPolicy) -  Info specification

@return ExportPolicyResponse
*/

type ExportPolicyCreateOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) ExportPolicyCreate(ctx context.Context, localVarOptionals *ExportPolicyCreateOpts) (ExportPolicyResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ExportPolicyResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nfs/export-policies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(ExportPolicy)
		if !localVarOptionalInfook {
				return localVarReturnValue, nil, reportError("info should be ExportPolicy")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v ExportPolicyResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Deletes an export policy. ### Related ONTAP commands * &#x60;vserver export-policy delete&#x60; ### Learn more * [&#x60;DOC /protocols/nfs/export-policies&#x60;](#docs-NAS-protocols_nfs_export-policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Export Policy ID


*/
func (a *NASApiService) ExportPolicyDelete(ctx context.Context, id int32) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nfs/export-policies/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves an export policy. ### Related ONTAP commands * &#x60;vserver export-policy show&#x60; * &#x60;vserver export-policy rule show&#x60; ### Learn more * [&#x60;DOC /protocols/nfs/export-policies&#x60;](#docs-NAS-protocols_nfs_export-policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Export Policy ID
 * @param optional nil or *ExportPolicyGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return ExportPolicy
*/

type ExportPolicyGetOpts struct { 
	Fields optional.Interface
}

func (a *NASApiService) ExportPolicyGet(ctx context.Context, id int32, localVarOptionals *ExportPolicyGetOpts) (ExportPolicy, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ExportPolicy
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nfs/export-policies/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ExportPolicy
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Updates the properties of an export policy to change an export policy name or replace all export policy rules. ### Related ONTAP commands * &#x60;vserver export-policy rename&#x60; * &#x60;vserver export-policy rule delete&#x60; * &#x60;vserver export-policy rule create&#x60; ### Learn more * [&#x60;DOC /protocols/nfs/export-policies&#x60;](#docs-NAS-protocols_nfs_export-policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Export Policy ID
 * @param optional nil or *ExportPolicyModifyOpts - Optional Parameters:
     * @param "Info" (optional.Interface of ExportPolicy) -  Info specification


*/

type ExportPolicyModifyOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) ExportPolicyModify(ctx context.Context, id int32, localVarOptionals *ExportPolicyModifyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nfs/export-policies/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(ExportPolicy)
		if !localVarOptionalInfook {
				return nil, reportError("info should be ExportPolicy")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Creates an export policy rule client ### Required properties * &#x60;policy.id&#x60; - Existing export policy that contains export policy rules for the client being added. * &#x60;index&#x60;  - Existing export policy rule for which to create an export client. * &#x60;match&#x60;  - Base name for the export policy client. ### Related ONTAP commands * &#x60;vserver export-policy rule add-clientmatches&#x60; ### Learn more * [&#x60;DOC /protocols/nfs/export-policies&#x60;](#docs-NAS-protocols_nfs_export-policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyId Export Policy ID
 * @param index Export Rule Index
 * @param optional nil or *ExportRuleClientsCreateOpts - Optional Parameters:
     * @param "Info" (optional.Interface of ExportClient) -  Info specification

@return ExportClientResponse
*/

type ExportRuleClientsCreateOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) ExportRuleClientsCreate(ctx context.Context, policyId int32, index int32, localVarOptionals *ExportRuleClientsCreateOpts) (ExportClientResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ExportClientResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nfs/export-policies/{policy.id}/rules/{index}/clients"
	localVarPath = strings.Replace(localVarPath, "{"+"policy.id"+"}", fmt.Sprintf("%v", policyId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", fmt.Sprintf("%v", index), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(ExportClient)
		if !localVarOptionalInfook {
				return localVarReturnValue, nil, reportError("info should be ExportClient")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v ExportClientResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Deletes an export policy client ### Related ONTAP commands * &#x60;vserver export-policy rule remove-clientmatches&#x60; ### Learn more * [&#x60;DOC /protocols/nfs/export-policies&#x60;](#docs-NAS-protocols_nfs_export-policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyId Export Policy ID
 * @param index Export Rule Index
 * @param match Export Client Match


*/
func (a *NASApiService) ExportRuleClientsDelete(ctx context.Context, policyId int32, index int32, match string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nfs/export-policies/{policy.id}/rules/{index}/clients/{match}"
	localVarPath = strings.Replace(localVarPath, "{"+"policy.id"+"}", fmt.Sprintf("%v", policyId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", fmt.Sprintf("%v", index), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"match"+"}", fmt.Sprintf("%v", match), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves export policy rule clients. ### Learn more * [&#x60;DOC /protocols/nfs/export-policies&#x60;](#docs-NAS-protocols_nfs_export-policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyId Export Policy ID
 * @param index Export Rule Index

@return ExportClientResponse
*/
func (a *NASApiService) ExportRuleClientsGet(ctx context.Context, policyId int32, index int32) (ExportClientResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ExportClientResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nfs/export-policies/{policy.id}/rules/{index}/clients"
	localVarPath = strings.Replace(localVarPath, "{"+"policy.id"+"}", fmt.Sprintf("%v", policyId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", fmt.Sprintf("%v", index), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ExportClientResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves export policy rules. ### Related ONTAP commands * &#x60;vserver export-policy rule show&#x60; ### Learn more * [&#x60;DOC /protocols/nfs/export-policies&#x60;](#docs-NAS-protocols_nfs_export-policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyId Export Policy ID
 * @param optional nil or *ExportRuleCollectionGetOpts - Optional Parameters:
     * @param "Protocols" (optional.String) -  Filter by protocols
     * @param "AnonymousUser" (optional.String) -  Filter by anonymous_user
     * @param "RwRule" (optional.String) -  Filter by rw_rule
     * @param "Index" (optional.Int32) -  Filter by index
     * @param "Superuser" (optional.String) -  Filter by superuser
     * @param "RoRule" (optional.String) -  Filter by ro_rule
     * @param "ClientsMatch" (optional.String) -  Filter by clients.match
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return ExportRuleResponse
*/

type ExportRuleCollectionGetOpts struct { 
	Protocols optional.String
	AnonymousUser optional.String
	RwRule optional.String
	Index optional.Int32
	Superuser optional.String
	RoRule optional.String
	ClientsMatch optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NASApiService) ExportRuleCollectionGet(ctx context.Context, policyId int32, localVarOptionals *ExportRuleCollectionGetOpts) (ExportRuleResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ExportRuleResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nfs/export-policies/{policy.id}/rules"
	localVarPath = strings.Replace(localVarPath, "{"+"policy.id"+"}", fmt.Sprintf("%v", policyId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Protocols.IsSet() {
		localVarQueryParams.Add("protocols", parameterToString(localVarOptionals.Protocols.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AnonymousUser.IsSet() {
		localVarQueryParams.Add("anonymous_user", parameterToString(localVarOptionals.AnonymousUser.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RwRule.IsSet() {
		localVarQueryParams.Add("rw_rule", parameterToString(localVarOptionals.RwRule.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Index.IsSet() {
		localVarQueryParams.Add("index", parameterToString(localVarOptionals.Index.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Superuser.IsSet() {
		localVarQueryParams.Add("superuser", parameterToString(localVarOptionals.Superuser.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RoRule.IsSet() {
		localVarQueryParams.Add("ro_rule", parameterToString(localVarOptionals.RoRule.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClientsMatch.IsSet() {
		localVarQueryParams.Add("clients.match", parameterToString(localVarOptionals.ClientsMatch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ExportRuleResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Creates an export policy rule. ### Required properties * &#x60;policy.id&#x60;  - Existing export policy for which to create an export rule. * &#x60;clients.match&#x60;  - List of clients (hostnames, ipaddresses, netgroups, domains) to which the export rule applies. * &#x60;ro_rule&#x60;  - Used to specify the security type for read-only access to volumes that use the export rule. * &#x60;rw_rule&#x60;  - Used to specify the security type for read-write access to volumes that use the export rule. ### Default property values If not specified in POST, the following default property values are assigned: * &#x60;protocols&#x60; - _any_ * &#x60;anonymous_user&#x60; - _none_ * &#x60;superuser&#x60; - _any_ ### Related ONTAP commands * &#x60;vserver export-policy rule create&#x60; ### Learn more * [&#x60;DOC /protocols/nfs/export-policies&#x60;](#docs-NAS-protocols_nfs_export-policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyId Export Policy ID
 * @param optional nil or *ExportRuleCreateOpts - Optional Parameters:
     * @param "Info" (optional.Interface of ExportRule) -  Info specification

@return ExportRuleResponse
*/

type ExportRuleCreateOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) ExportRuleCreate(ctx context.Context, policyId int32, localVarOptionals *ExportRuleCreateOpts) (ExportRuleResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ExportRuleResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nfs/export-policies/{policy.id}/rules"
	localVarPath = strings.Replace(localVarPath, "{"+"policy.id"+"}", fmt.Sprintf("%v", policyId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(ExportRule)
		if !localVarOptionalInfook {
				return localVarReturnValue, nil, reportError("info should be ExportRule")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v ExportRuleResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Deletes an export policy rule. ### Related ONTAP commands * &#x60;vserver export-policy rule delete&#x60; ### Learn more * [&#x60;DOC /protocols/nfs/export-policies&#x60;](#docs-NAS-protocols_nfs_export-policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyId Export Policy ID
 * @param index Export Rule Index


*/
func (a *NASApiService) ExportRuleDelete(ctx context.Context, policyId int32, index int32) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nfs/export-policies/{policy.id}/rules/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"policy.id"+"}", fmt.Sprintf("%v", policyId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", fmt.Sprintf("%v", index), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves an export policy rule ### Related ONTAP commands * &#x60;vserver export-policy rule show&#x60; ### Learn more * [&#x60;DOC /protocols/nfs/export-policies&#x60;](#docs-NAS-protocols_nfs_export-policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyId Export Policy ID
 * @param index Export Rule Index
 * @param optional nil or *ExportRuleGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return ExportRule
*/

type ExportRuleGetOpts struct { 
	Fields optional.Interface
}

func (a *NASApiService) ExportRuleGet(ctx context.Context, policyId int32, index int32, localVarOptionals *ExportRuleGetOpts) (ExportRule, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ExportRule
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nfs/export-policies/{policy.id}/rules/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"policy.id"+"}", fmt.Sprintf("%v", policyId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", fmt.Sprintf("%v", index), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ExportRule
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Updates the properties of an export policy rule to change an export policy rule&#39;s index or fields. ### Related ONTAP commands * &#x60;vserver export-policy rule modify&#x60; * &#x60;vserver export-policy rule setindex&#x60; ### Learn more * [&#x60;DOC /protocols/nfs/export-policies&#x60;](#docs-NAS-protocols_nfs_export-policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyId Export Policy ID
 * @param index Export Rule Index
 * @param optional nil or *ExportRuleModifyOpts - Optional Parameters:
     * @param "NewIndex" (optional.Int32) -  New Export Rule Index
     * @param "Info" (optional.Interface of ExportRule) -  Info specification


*/

type ExportRuleModifyOpts struct { 
	NewIndex optional.Int32
	Info optional.Interface
}

func (a *NASApiService) ExportRuleModify(ctx context.Context, policyId int32, index int32, localVarOptionals *ExportRuleModifyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nfs/export-policies/{policy.id}/rules/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"policy.id"+"}", fmt.Sprintf("%v", policyId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", fmt.Sprintf("%v", index), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.NewIndex.IsSet() {
		localVarQueryParams.Add("new_index", parameterToString(localVarOptionals.NewIndex.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(ExportRule)
		if !localVarOptionalInfook {
				return nil, reportError("info should be ExportRule")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves an FPolicy configuration. ### Related ONTAP commands * &#x60;fpolicy show&#x60; * &#x60;fpolicy policy show&#x60; * &#x60;fpolicy policy scope show&#x60; * &#x60;fpolicy policy event show&#x60; * &#x60;fpolicy policy external-engine show&#x60; ### Learn more * [&#x60;DOC /protocols/fpolicy&#x60;](#docs-NAS-protocols_fpolicy) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *FpolicyCollectionGetOpts - Optional Parameters:
     * @param "EnginesSecondaryServers" (optional.String) -  Filter by engines.secondary_servers
     * @param "EnginesName" (optional.String) -  Filter by engines.name
     * @param "EnginesType" (optional.String) -  Filter by engines.type
     * @param "EnginesPrimaryServers" (optional.String) -  Filter by engines.primary_servers
     * @param "EnginesPort" (optional.Int32) -  Filter by engines.port
     * @param "PoliciesEnabled" (optional.Bool) -  Filter by policies.enabled
     * @param "PoliciesScopeExcludeExportPolicies" (optional.String) -  Filter by policies.scope.exclude_export_policies
     * @param "PoliciesScopeExcludeShares" (optional.String) -  Filter by policies.scope.exclude_shares
     * @param "PoliciesScopeIncludeExtension" (optional.String) -  Filter by policies.scope.include_extension
     * @param "PoliciesScopeExcludeExtension" (optional.String) -  Filter by policies.scope.exclude_extension
     * @param "PoliciesScopeIncludeShares" (optional.String) -  Filter by policies.scope.include_shares
     * @param "PoliciesScopeIncludeVolumes" (optional.String) -  Filter by policies.scope.include_volumes
     * @param "PoliciesScopeIncludeExportPolicies" (optional.String) -  Filter by policies.scope.include_export_policies
     * @param "PoliciesScopeExcludeVolumes" (optional.String) -  Filter by policies.scope.exclude_volumes
     * @param "PoliciesPriority" (optional.Int32) -  Filter by policies.priority
     * @param "PoliciesEngineName" (optional.String) -  Filter by policies.engine.name
     * @param "PoliciesEventsName" (optional.String) -  Filter by policies.events.name
     * @param "PoliciesName" (optional.String) -  Filter by policies.name
     * @param "PoliciesMandatory" (optional.Bool) -  Filter by policies.mandatory
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "EventsVolumeMonitoring" (optional.Bool) -  Filter by events.volume_monitoring
     * @param "EventsProtocol" (optional.String) -  Filter by events.protocol
     * @param "EventsFiltersMonitorAds" (optional.Bool) -  Filter by events.filters.monitor_ads
     * @param "EventsFiltersWriteWithSizeChange" (optional.Bool) -  Filter by events.filters.write_with_size_change
     * @param "EventsFiltersFirstRead" (optional.Bool) -  Filter by events.filters.first_read
     * @param "EventsFiltersSetattrWithModifyTimeChange" (optional.Bool) -  Filter by events.filters.setattr_with_modify_time_change
     * @param "EventsFiltersOfflineBit" (optional.Bool) -  Filter by events.filters.offline_bit
     * @param "EventsFiltersOpenWithWriteIntent" (optional.Bool) -  Filter by events.filters.open_with_write_intent
     * @param "EventsFiltersFirstWrite" (optional.Bool) -  Filter by events.filters.first_write
     * @param "EventsFiltersSetattrWithGroupChange" (optional.Bool) -  Filter by events.filters.setattr_with_group_change
     * @param "EventsFiltersSetattrWithAccessTimeChange" (optional.Bool) -  Filter by events.filters.setattr_with_access_time_change
     * @param "EventsFiltersSetattrWithModeChange" (optional.Bool) -  Filter by events.filters.setattr_with_mode_change
     * @param "EventsFiltersExcludeDirectory" (optional.Bool) -  Filter by events.filters.exclude_directory
     * @param "EventsFiltersSetattrWithOwnerChange" (optional.Bool) -  Filter by events.filters.setattr_with_owner_change
     * @param "EventsFiltersSetattrWithDaclChange" (optional.Bool) -  Filter by events.filters.setattr_with_dacl_change
     * @param "EventsFiltersCloseWithModification" (optional.Bool) -  Filter by events.filters.close_with_modification
     * @param "EventsFiltersOpenWithDeleteIntent" (optional.Bool) -  Filter by events.filters.open_with_delete_intent
     * @param "EventsFiltersSetattrWithSaclChange" (optional.Bool) -  Filter by events.filters.setattr_with_sacl_change
     * @param "EventsFiltersSetattrWithAllocationSizeChange" (optional.Bool) -  Filter by events.filters.setattr_with_allocation_size_change
     * @param "EventsFiltersCloseWithoutModification" (optional.Bool) -  Filter by events.filters.close_without_modification
     * @param "EventsFiltersSetattrWithSizeChange" (optional.Bool) -  Filter by events.filters.setattr_with_size_change
     * @param "EventsFiltersCloseWithRead" (optional.Bool) -  Filter by events.filters.close_with_read
     * @param "EventsFiltersSetattrWithCreationTimeChange" (optional.Bool) -  Filter by events.filters.setattr_with_creation_time_change
     * @param "EventsName" (optional.String) -  Filter by events.name
     * @param "EventsFileOperationsLookup" (optional.Bool) -  Filter by events.file_operations.lookup
     * @param "EventsFileOperationsDeleteDir" (optional.Bool) -  Filter by events.file_operations.delete_dir
     * @param "EventsFileOperationsCreate" (optional.Bool) -  Filter by events.file_operations.create
     * @param "EventsFileOperationsRead" (optional.Bool) -  Filter by events.file_operations.read
     * @param "EventsFileOperationsRenameDir" (optional.Bool) -  Filter by events.file_operations.rename_dir
     * @param "EventsFileOperationsWrite" (optional.Bool) -  Filter by events.file_operations.write
     * @param "EventsFileOperationsGetattr" (optional.Bool) -  Filter by events.file_operations.getattr
     * @param "EventsFileOperationsSymlink" (optional.Bool) -  Filter by events.file_operations.symlink
     * @param "EventsFileOperationsLink" (optional.Bool) -  Filter by events.file_operations.link
     * @param "EventsFileOperationsRename" (optional.Bool) -  Filter by events.file_operations.rename
     * @param "EventsFileOperationsSetattr" (optional.Bool) -  Filter by events.file_operations.setattr
     * @param "EventsFileOperationsCreateDir" (optional.Bool) -  Filter by events.file_operations.create_dir
     * @param "EventsFileOperationsOpen" (optional.Bool) -  Filter by events.file_operations.open
     * @param "EventsFileOperationsDelete" (optional.Bool) -  Filter by events.file_operations.delete
     * @param "EventsFileOperationsClose" (optional.Bool) -  Filter by events.file_operations.close
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return FpolicyResponse
*/

type FpolicyCollectionGetOpts struct { 
	EnginesSecondaryServers optional.String
	EnginesName optional.String
	EnginesType optional.String
	EnginesPrimaryServers optional.String
	EnginesPort optional.Int32
	PoliciesEnabled optional.Bool
	PoliciesScopeExcludeExportPolicies optional.String
	PoliciesScopeExcludeShares optional.String
	PoliciesScopeIncludeExtension optional.String
	PoliciesScopeExcludeExtension optional.String
	PoliciesScopeIncludeShares optional.String
	PoliciesScopeIncludeVolumes optional.String
	PoliciesScopeIncludeExportPolicies optional.String
	PoliciesScopeExcludeVolumes optional.String
	PoliciesPriority optional.Int32
	PoliciesEngineName optional.String
	PoliciesEventsName optional.String
	PoliciesName optional.String
	PoliciesMandatory optional.Bool
	SvmUuid optional.String
	SvmName optional.String
	EventsVolumeMonitoring optional.Bool
	EventsProtocol optional.String
	EventsFiltersMonitorAds optional.Bool
	EventsFiltersWriteWithSizeChange optional.Bool
	EventsFiltersFirstRead optional.Bool
	EventsFiltersSetattrWithModifyTimeChange optional.Bool
	EventsFiltersOfflineBit optional.Bool
	EventsFiltersOpenWithWriteIntent optional.Bool
	EventsFiltersFirstWrite optional.Bool
	EventsFiltersSetattrWithGroupChange optional.Bool
	EventsFiltersSetattrWithAccessTimeChange optional.Bool
	EventsFiltersSetattrWithModeChange optional.Bool
	EventsFiltersExcludeDirectory optional.Bool
	EventsFiltersSetattrWithOwnerChange optional.Bool
	EventsFiltersSetattrWithDaclChange optional.Bool
	EventsFiltersCloseWithModification optional.Bool
	EventsFiltersOpenWithDeleteIntent optional.Bool
	EventsFiltersSetattrWithSaclChange optional.Bool
	EventsFiltersSetattrWithAllocationSizeChange optional.Bool
	EventsFiltersCloseWithoutModification optional.Bool
	EventsFiltersSetattrWithSizeChange optional.Bool
	EventsFiltersCloseWithRead optional.Bool
	EventsFiltersSetattrWithCreationTimeChange optional.Bool
	EventsName optional.String
	EventsFileOperationsLookup optional.Bool
	EventsFileOperationsDeleteDir optional.Bool
	EventsFileOperationsCreate optional.Bool
	EventsFileOperationsRead optional.Bool
	EventsFileOperationsRenameDir optional.Bool
	EventsFileOperationsWrite optional.Bool
	EventsFileOperationsGetattr optional.Bool
	EventsFileOperationsSymlink optional.Bool
	EventsFileOperationsLink optional.Bool
	EventsFileOperationsRename optional.Bool
	EventsFileOperationsSetattr optional.Bool
	EventsFileOperationsCreateDir optional.Bool
	EventsFileOperationsOpen optional.Bool
	EventsFileOperationsDelete optional.Bool
	EventsFileOperationsClose optional.Bool
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NASApiService) FpolicyCollectionGet(ctx context.Context, localVarOptionals *FpolicyCollectionGetOpts) (FpolicyResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FpolicyResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/fpolicy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.EnginesSecondaryServers.IsSet() {
		localVarQueryParams.Add("engines.secondary_servers", parameterToString(localVarOptionals.EnginesSecondaryServers.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnginesName.IsSet() {
		localVarQueryParams.Add("engines.name", parameterToString(localVarOptionals.EnginesName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnginesType.IsSet() {
		localVarQueryParams.Add("engines.type", parameterToString(localVarOptionals.EnginesType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnginesPrimaryServers.IsSet() {
		localVarQueryParams.Add("engines.primary_servers", parameterToString(localVarOptionals.EnginesPrimaryServers.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnginesPort.IsSet() {
		localVarQueryParams.Add("engines.port", parameterToString(localVarOptionals.EnginesPort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PoliciesEnabled.IsSet() {
		localVarQueryParams.Add("policies.enabled", parameterToString(localVarOptionals.PoliciesEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PoliciesScopeExcludeExportPolicies.IsSet() {
		localVarQueryParams.Add("policies.scope.exclude_export_policies", parameterToString(localVarOptionals.PoliciesScopeExcludeExportPolicies.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PoliciesScopeExcludeShares.IsSet() {
		localVarQueryParams.Add("policies.scope.exclude_shares", parameterToString(localVarOptionals.PoliciesScopeExcludeShares.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PoliciesScopeIncludeExtension.IsSet() {
		localVarQueryParams.Add("policies.scope.include_extension", parameterToString(localVarOptionals.PoliciesScopeIncludeExtension.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PoliciesScopeExcludeExtension.IsSet() {
		localVarQueryParams.Add("policies.scope.exclude_extension", parameterToString(localVarOptionals.PoliciesScopeExcludeExtension.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PoliciesScopeIncludeShares.IsSet() {
		localVarQueryParams.Add("policies.scope.include_shares", parameterToString(localVarOptionals.PoliciesScopeIncludeShares.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PoliciesScopeIncludeVolumes.IsSet() {
		localVarQueryParams.Add("policies.scope.include_volumes", parameterToString(localVarOptionals.PoliciesScopeIncludeVolumes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PoliciesScopeIncludeExportPolicies.IsSet() {
		localVarQueryParams.Add("policies.scope.include_export_policies", parameterToString(localVarOptionals.PoliciesScopeIncludeExportPolicies.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PoliciesScopeExcludeVolumes.IsSet() {
		localVarQueryParams.Add("policies.scope.exclude_volumes", parameterToString(localVarOptionals.PoliciesScopeExcludeVolumes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PoliciesPriority.IsSet() {
		localVarQueryParams.Add("policies.priority", parameterToString(localVarOptionals.PoliciesPriority.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PoliciesEngineName.IsSet() {
		localVarQueryParams.Add("policies.engine.name", parameterToString(localVarOptionals.PoliciesEngineName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PoliciesEventsName.IsSet() {
		localVarQueryParams.Add("policies.events.name", parameterToString(localVarOptionals.PoliciesEventsName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PoliciesName.IsSet() {
		localVarQueryParams.Add("policies.name", parameterToString(localVarOptionals.PoliciesName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PoliciesMandatory.IsSet() {
		localVarQueryParams.Add("policies.mandatory", parameterToString(localVarOptionals.PoliciesMandatory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsVolumeMonitoring.IsSet() {
		localVarQueryParams.Add("events.volume_monitoring", parameterToString(localVarOptionals.EventsVolumeMonitoring.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsProtocol.IsSet() {
		localVarQueryParams.Add("events.protocol", parameterToString(localVarOptionals.EventsProtocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFiltersMonitorAds.IsSet() {
		localVarQueryParams.Add("events.filters.monitor_ads", parameterToString(localVarOptionals.EventsFiltersMonitorAds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFiltersWriteWithSizeChange.IsSet() {
		localVarQueryParams.Add("events.filters.write_with_size_change", parameterToString(localVarOptionals.EventsFiltersWriteWithSizeChange.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFiltersFirstRead.IsSet() {
		localVarQueryParams.Add("events.filters.first_read", parameterToString(localVarOptionals.EventsFiltersFirstRead.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFiltersSetattrWithModifyTimeChange.IsSet() {
		localVarQueryParams.Add("events.filters.setattr_with_modify_time_change", parameterToString(localVarOptionals.EventsFiltersSetattrWithModifyTimeChange.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFiltersOfflineBit.IsSet() {
		localVarQueryParams.Add("events.filters.offline_bit", parameterToString(localVarOptionals.EventsFiltersOfflineBit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFiltersOpenWithWriteIntent.IsSet() {
		localVarQueryParams.Add("events.filters.open_with_write_intent", parameterToString(localVarOptionals.EventsFiltersOpenWithWriteIntent.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFiltersFirstWrite.IsSet() {
		localVarQueryParams.Add("events.filters.first_write", parameterToString(localVarOptionals.EventsFiltersFirstWrite.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFiltersSetattrWithGroupChange.IsSet() {
		localVarQueryParams.Add("events.filters.setattr_with_group_change", parameterToString(localVarOptionals.EventsFiltersSetattrWithGroupChange.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFiltersSetattrWithAccessTimeChange.IsSet() {
		localVarQueryParams.Add("events.filters.setattr_with_access_time_change", parameterToString(localVarOptionals.EventsFiltersSetattrWithAccessTimeChange.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFiltersSetattrWithModeChange.IsSet() {
		localVarQueryParams.Add("events.filters.setattr_with_mode_change", parameterToString(localVarOptionals.EventsFiltersSetattrWithModeChange.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFiltersExcludeDirectory.IsSet() {
		localVarQueryParams.Add("events.filters.exclude_directory", parameterToString(localVarOptionals.EventsFiltersExcludeDirectory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFiltersSetattrWithOwnerChange.IsSet() {
		localVarQueryParams.Add("events.filters.setattr_with_owner_change", parameterToString(localVarOptionals.EventsFiltersSetattrWithOwnerChange.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFiltersSetattrWithDaclChange.IsSet() {
		localVarQueryParams.Add("events.filters.setattr_with_dacl_change", parameterToString(localVarOptionals.EventsFiltersSetattrWithDaclChange.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFiltersCloseWithModification.IsSet() {
		localVarQueryParams.Add("events.filters.close_with_modification", parameterToString(localVarOptionals.EventsFiltersCloseWithModification.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFiltersOpenWithDeleteIntent.IsSet() {
		localVarQueryParams.Add("events.filters.open_with_delete_intent", parameterToString(localVarOptionals.EventsFiltersOpenWithDeleteIntent.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFiltersSetattrWithSaclChange.IsSet() {
		localVarQueryParams.Add("events.filters.setattr_with_sacl_change", parameterToString(localVarOptionals.EventsFiltersSetattrWithSaclChange.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFiltersSetattrWithAllocationSizeChange.IsSet() {
		localVarQueryParams.Add("events.filters.setattr_with_allocation_size_change", parameterToString(localVarOptionals.EventsFiltersSetattrWithAllocationSizeChange.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFiltersCloseWithoutModification.IsSet() {
		localVarQueryParams.Add("events.filters.close_without_modification", parameterToString(localVarOptionals.EventsFiltersCloseWithoutModification.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFiltersSetattrWithSizeChange.IsSet() {
		localVarQueryParams.Add("events.filters.setattr_with_size_change", parameterToString(localVarOptionals.EventsFiltersSetattrWithSizeChange.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFiltersCloseWithRead.IsSet() {
		localVarQueryParams.Add("events.filters.close_with_read", parameterToString(localVarOptionals.EventsFiltersCloseWithRead.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFiltersSetattrWithCreationTimeChange.IsSet() {
		localVarQueryParams.Add("events.filters.setattr_with_creation_time_change", parameterToString(localVarOptionals.EventsFiltersSetattrWithCreationTimeChange.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsName.IsSet() {
		localVarQueryParams.Add("events.name", parameterToString(localVarOptionals.EventsName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFileOperationsLookup.IsSet() {
		localVarQueryParams.Add("events.file_operations.lookup", parameterToString(localVarOptionals.EventsFileOperationsLookup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFileOperationsDeleteDir.IsSet() {
		localVarQueryParams.Add("events.file_operations.delete_dir", parameterToString(localVarOptionals.EventsFileOperationsDeleteDir.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFileOperationsCreate.IsSet() {
		localVarQueryParams.Add("events.file_operations.create", parameterToString(localVarOptionals.EventsFileOperationsCreate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFileOperationsRead.IsSet() {
		localVarQueryParams.Add("events.file_operations.read", parameterToString(localVarOptionals.EventsFileOperationsRead.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFileOperationsRenameDir.IsSet() {
		localVarQueryParams.Add("events.file_operations.rename_dir", parameterToString(localVarOptionals.EventsFileOperationsRenameDir.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFileOperationsWrite.IsSet() {
		localVarQueryParams.Add("events.file_operations.write", parameterToString(localVarOptionals.EventsFileOperationsWrite.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFileOperationsGetattr.IsSet() {
		localVarQueryParams.Add("events.file_operations.getattr", parameterToString(localVarOptionals.EventsFileOperationsGetattr.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFileOperationsSymlink.IsSet() {
		localVarQueryParams.Add("events.file_operations.symlink", parameterToString(localVarOptionals.EventsFileOperationsSymlink.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFileOperationsLink.IsSet() {
		localVarQueryParams.Add("events.file_operations.link", parameterToString(localVarOptionals.EventsFileOperationsLink.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFileOperationsRename.IsSet() {
		localVarQueryParams.Add("events.file_operations.rename", parameterToString(localVarOptionals.EventsFileOperationsRename.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFileOperationsSetattr.IsSet() {
		localVarQueryParams.Add("events.file_operations.setattr", parameterToString(localVarOptionals.EventsFileOperationsSetattr.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFileOperationsCreateDir.IsSet() {
		localVarQueryParams.Add("events.file_operations.create_dir", parameterToString(localVarOptionals.EventsFileOperationsCreateDir.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFileOperationsOpen.IsSet() {
		localVarQueryParams.Add("events.file_operations.open", parameterToString(localVarOptionals.EventsFileOperationsOpen.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFileOperationsDelete.IsSet() {
		localVarQueryParams.Add("events.file_operations.delete", parameterToString(localVarOptionals.EventsFileOperationsDelete.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsFileOperationsClose.IsSet() {
		localVarQueryParams.Add("events.file_operations.close", parameterToString(localVarOptionals.EventsFileOperationsClose.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FpolicyResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Creates an FPolicy configuration. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the FPolicy configuration. ### Recommended optional properties * &#x60;engines&#x60; -  External server to which the notifications will be sent. * &#x60;events&#x60; - File operations to monitor. * &#x60;policies&#x60; - Policy configuration which acts as a container for FPolicy event and FPolicy engine. * &#x60;scope&#x60; - Scope of the policy. Can be limited to exports, volumes, shares or file extensions. ### Default property values If not specified in POST, the following default property values are assigned: * &#x60;engines.type&#x60; - _synchronous_ * &#x60;policies.engine&#x60; - _native_ * &#x60;policies.mandatory&#x60; -  _true_ * &#x60;events.volume_monitoring&#x60; - _false_ * &#x60;events.file_operations.*&#x60; - _false_ * &#x60;events.filters.*&#x60; - _false_ ### Related ONTAP commands * &#x60;fpolicy policy event create&#x60; * &#x60;fpolicy policy external-engine create&#x60; * &#x60;fpolicy policy create&#x60; * &#x60;fpolicy policy scope create&#x60; * &#x60;fpolicy enable&#x60; ### Learn more * [&#x60;DOC /protocols/fpolicy&#x60;](#docs-NAS-protocols_fpolicy) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *FpolicyCreateOpts - Optional Parameters:
     * @param "Info" (optional.Interface of Fpolicy) -  Info specification

@return FpolicyResponse
*/

type FpolicyCreateOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) FpolicyCreate(ctx context.Context, localVarOptionals *FpolicyCreateOpts) (FpolicyResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FpolicyResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/fpolicy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(Fpolicy)
		if !localVarOptionalInfook {
				return localVarReturnValue, nil, reportError("info should be Fpolicy")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v FpolicyResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Deletes the FPolicy configuration for the specified SVM. Before deleting the FPolicy configuration, ensure that all policies belonging to the SVM are disabled. ### Related ONTAP commands * &#x60;fpolicy delete&#x60; * &#x60;fpolicy policy scope delete&#x60; * &#x60;fpolicy policy delete&#x60; * &#x60;fpolicy policy event delete&#x60; * &#x60;fpolicy policy external-engine delete&#x60; ### Learn more * [&#x60;DOC /protocols/fpolicy&#x60;](#docs-NAS-protocols_fpolicy) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.


*/
func (a *NASApiService) FpolicyDelete(ctx context.Context, svmUuid string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/fpolicy/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves FPolicy engine configurations of all the engines for a specified SVM. ONTAP allows creation of cluster-level FPolicy engines that act as a template for all the SVMs belonging to the cluster. These cluster-level FPolicy engines are also retrieved for the specified SVM. ### Related ONTAP commands * &#x60;fpolicy policy external-engine show&#x60; ### Learn more * [&#x60;DOC /protocols/fpolicy/{svm.uuid}/engines&#x60;](#docs-NAS-protocols_fpolicy_{svm.uuid}_engines) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param optional nil or *FpolicyEngineCollectionGetOpts - Optional Parameters:
     * @param "SecondaryServers" (optional.String) -  Filter by secondary_servers
     * @param "Name" (optional.String) -  Filter by name
     * @param "Type_" (optional.String) -  Filter by type
     * @param "PrimaryServers" (optional.String) -  Filter by primary_servers
     * @param "Port" (optional.Int32) -  Filter by port
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return FpolicyEngineResponse
*/

type FpolicyEngineCollectionGetOpts struct { 
	SecondaryServers optional.String
	Name optional.String
	Type_ optional.String
	PrimaryServers optional.String
	Port optional.Int32
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NASApiService) FpolicyEngineCollectionGet(ctx context.Context, svmUuid string, localVarOptionals *FpolicyEngineCollectionGetOpts) (FpolicyEngineResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FpolicyEngineResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/fpolicy/{svm.uuid}/engines"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.SecondaryServers.IsSet() {
		localVarQueryParams.Add("secondary_servers", parameterToString(localVarOptionals.SecondaryServers.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PrimaryServers.IsSet() {
		localVarQueryParams.Add("primary_servers", parameterToString(localVarOptionals.PrimaryServers.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Port.IsSet() {
		localVarQueryParams.Add("port", parameterToString(localVarOptionals.Port.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FpolicyEngineResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Creates an FPolicy engine configuration for a specified SVM. FPolicy engine creation is allowed only on data SVMs. ### Required properties * &#x60;svm.uuid&#x60; - Existing SVM in which to create the FPolicy engine. * &#x60;name&#x60; - Name of external engine. * &#x60;port&#x60; - Port number of the FPolicy server application. * &#x60;primary_servers&#x60; - List of primary FPolicy servers to which the node will send notifications. ### Recommended optional properties * &#x60;secondary_servers&#x60; - It is recommended to configure secondary FPolicy server to which the node will send notifications when the primary server is down. ### Default property values * &#x60;type&#x60; - _synchronous_ ### Related ONTAP commands * &#x60;fpolicy policy external-engine create&#x60; ### Learn more * [&#x60;DOC /protocols/fpolicy/{svm.uuid}/engines&#x60;](#docs-NAS-protocols_fpolicy_{svm.uuid}_engines) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param optional nil or *FpolicyEngineCreateOpts - Optional Parameters:
     * @param "Info" (optional.Interface of FpolicyEngine) -  Info specification

@return FpolicyEngineResponse
*/

type FpolicyEngineCreateOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) FpolicyEngineCreate(ctx context.Context, svmUuid string, localVarOptionals *FpolicyEngineCreateOpts) (FpolicyEngineResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FpolicyEngineResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/fpolicy/{svm.uuid}/engines"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(FpolicyEngine)
		if !localVarOptionalInfook {
				return localVarReturnValue, nil, reportError("info should be FpolicyEngine")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v FpolicyEngineResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Deletes the FPolicy external engine configuration. Deletion of an FPolicy engine that is attached to one or more FPolicy policies is not allowed. ### Related ONTAP commands * &#x60;fpolicy policy external-engine modify&#x60; ### Learn more * [&#x60;DOC /protocols/fpolicy/{svm.uuid}/engines&#x60;](#docs-NAS-protocols_fpolicy_{svm.uuid}_engines) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param name


*/
func (a *NASApiService) FpolicyEngineDelete(ctx context.Context, svmUuid string, name string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/fpolicy/{svm.uuid}/engines/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves a particular FPolicy engine configuration of a specifed SVM. A cluster-level FPolicy engine configuration cannot be retrieved for a data SVM. ### Related ONTAP commands * &#x60;fpolicy policy external-engine show&#x60; ### Learn more * [&#x60;DOC /protocols/fpolicy/{svm.uuid}/engines&#x60;](#docs-NAS-protocols_fpolicy_{svm.uuid}_engines) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param name
 * @param optional nil or *FpolicyEngineGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return FpolicyEngine
*/

type FpolicyEngineGetOpts struct { 
	Fields optional.Interface
}

func (a *NASApiService) FpolicyEngineGet(ctx context.Context, svmUuid string, name string, localVarOptionals *FpolicyEngineGetOpts) (FpolicyEngine, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FpolicyEngine
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/fpolicy/{svm.uuid}/engines/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FpolicyEngine
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Updates a specific FPolicy engine configuration of an SVM. Modification of an FPolicy engine that is attached to one or more enabled FPolicy policies is not allowed. ### Related ONTAP commands * &#x60;fpolicy policy external-engine modify&#x60; ### Learn more * [&#x60;DOC /protocols/fpolicy/{svm.uuid}/engines&#x60;](#docs-NAS-protocols_fpolicy_{svm.uuid}_engines) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param name
 * @param optional nil or *FpolicyEngineModifyOpts - Optional Parameters:
     * @param "Info" (optional.Interface of FpolicyEngine) -  Info specification


*/

type FpolicyEngineModifyOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) FpolicyEngineModify(ctx context.Context, svmUuid string, name string, localVarOptionals *FpolicyEngineModifyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/fpolicy/{svm.uuid}/engines/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(FpolicyEngine)
		if !localVarOptionalInfook {
				return nil, reportError("info should be FpolicyEngine")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves FPolicy event configurations for all events for a specified SVM. ONTAP allows the creation of cluster-level FPolicy events that act as a template for all the data SVMs belonging to the cluster. These cluster-level FPolicy events are also retrieved for the specified SVM. ### Related ONTAP commands * &#x60;fpolicy policy event show&#x60; ### Learn more * [&#x60;DOC /protocols/fpolicy/{svm.uuid}/events&#x60;](#docs-NAS-protocols_fpolicy_{svm.uuid}_events) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param optional nil or *FpolicyEventCollectionGetOpts - Optional Parameters:
     * @param "VolumeMonitoring" (optional.Bool) -  Filter by volume_monitoring
     * @param "Protocol" (optional.String) -  Filter by protocol
     * @param "FiltersMonitorAds" (optional.Bool) -  Filter by filters.monitor_ads
     * @param "FiltersWriteWithSizeChange" (optional.Bool) -  Filter by filters.write_with_size_change
     * @param "FiltersFirstRead" (optional.Bool) -  Filter by filters.first_read
     * @param "FiltersSetattrWithModifyTimeChange" (optional.Bool) -  Filter by filters.setattr_with_modify_time_change
     * @param "FiltersOfflineBit" (optional.Bool) -  Filter by filters.offline_bit
     * @param "FiltersOpenWithWriteIntent" (optional.Bool) -  Filter by filters.open_with_write_intent
     * @param "FiltersFirstWrite" (optional.Bool) -  Filter by filters.first_write
     * @param "FiltersSetattrWithGroupChange" (optional.Bool) -  Filter by filters.setattr_with_group_change
     * @param "FiltersSetattrWithAccessTimeChange" (optional.Bool) -  Filter by filters.setattr_with_access_time_change
     * @param "FiltersSetattrWithModeChange" (optional.Bool) -  Filter by filters.setattr_with_mode_change
     * @param "FiltersExcludeDirectory" (optional.Bool) -  Filter by filters.exclude_directory
     * @param "FiltersSetattrWithOwnerChange" (optional.Bool) -  Filter by filters.setattr_with_owner_change
     * @param "FiltersSetattrWithDaclChange" (optional.Bool) -  Filter by filters.setattr_with_dacl_change
     * @param "FiltersCloseWithModification" (optional.Bool) -  Filter by filters.close_with_modification
     * @param "FiltersOpenWithDeleteIntent" (optional.Bool) -  Filter by filters.open_with_delete_intent
     * @param "FiltersSetattrWithSaclChange" (optional.Bool) -  Filter by filters.setattr_with_sacl_change
     * @param "FiltersSetattrWithAllocationSizeChange" (optional.Bool) -  Filter by filters.setattr_with_allocation_size_change
     * @param "FiltersCloseWithoutModification" (optional.Bool) -  Filter by filters.close_without_modification
     * @param "FiltersSetattrWithSizeChange" (optional.Bool) -  Filter by filters.setattr_with_size_change
     * @param "FiltersCloseWithRead" (optional.Bool) -  Filter by filters.close_with_read
     * @param "FiltersSetattrWithCreationTimeChange" (optional.Bool) -  Filter by filters.setattr_with_creation_time_change
     * @param "Name" (optional.String) -  Filter by name
     * @param "FileOperationsLookup" (optional.Bool) -  Filter by file_operations.lookup
     * @param "FileOperationsDeleteDir" (optional.Bool) -  Filter by file_operations.delete_dir
     * @param "FileOperationsCreate" (optional.Bool) -  Filter by file_operations.create
     * @param "FileOperationsRead" (optional.Bool) -  Filter by file_operations.read
     * @param "FileOperationsRenameDir" (optional.Bool) -  Filter by file_operations.rename_dir
     * @param "FileOperationsWrite" (optional.Bool) -  Filter by file_operations.write
     * @param "FileOperationsGetattr" (optional.Bool) -  Filter by file_operations.getattr
     * @param "FileOperationsSymlink" (optional.Bool) -  Filter by file_operations.symlink
     * @param "FileOperationsLink" (optional.Bool) -  Filter by file_operations.link
     * @param "FileOperationsRename" (optional.Bool) -  Filter by file_operations.rename
     * @param "FileOperationsSetattr" (optional.Bool) -  Filter by file_operations.setattr
     * @param "FileOperationsCreateDir" (optional.Bool) -  Filter by file_operations.create_dir
     * @param "FileOperationsOpen" (optional.Bool) -  Filter by file_operations.open
     * @param "FileOperationsDelete" (optional.Bool) -  Filter by file_operations.delete
     * @param "FileOperationsClose" (optional.Bool) -  Filter by file_operations.close
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return FpolicyEventResponse
*/

type FpolicyEventCollectionGetOpts struct { 
	VolumeMonitoring optional.Bool
	Protocol optional.String
	FiltersMonitorAds optional.Bool
	FiltersWriteWithSizeChange optional.Bool
	FiltersFirstRead optional.Bool
	FiltersSetattrWithModifyTimeChange optional.Bool
	FiltersOfflineBit optional.Bool
	FiltersOpenWithWriteIntent optional.Bool
	FiltersFirstWrite optional.Bool
	FiltersSetattrWithGroupChange optional.Bool
	FiltersSetattrWithAccessTimeChange optional.Bool
	FiltersSetattrWithModeChange optional.Bool
	FiltersExcludeDirectory optional.Bool
	FiltersSetattrWithOwnerChange optional.Bool
	FiltersSetattrWithDaclChange optional.Bool
	FiltersCloseWithModification optional.Bool
	FiltersOpenWithDeleteIntent optional.Bool
	FiltersSetattrWithSaclChange optional.Bool
	FiltersSetattrWithAllocationSizeChange optional.Bool
	FiltersCloseWithoutModification optional.Bool
	FiltersSetattrWithSizeChange optional.Bool
	FiltersCloseWithRead optional.Bool
	FiltersSetattrWithCreationTimeChange optional.Bool
	Name optional.String
	FileOperationsLookup optional.Bool
	FileOperationsDeleteDir optional.Bool
	FileOperationsCreate optional.Bool
	FileOperationsRead optional.Bool
	FileOperationsRenameDir optional.Bool
	FileOperationsWrite optional.Bool
	FileOperationsGetattr optional.Bool
	FileOperationsSymlink optional.Bool
	FileOperationsLink optional.Bool
	FileOperationsRename optional.Bool
	FileOperationsSetattr optional.Bool
	FileOperationsCreateDir optional.Bool
	FileOperationsOpen optional.Bool
	FileOperationsDelete optional.Bool
	FileOperationsClose optional.Bool
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NASApiService) FpolicyEventCollectionGet(ctx context.Context, svmUuid string, localVarOptionals *FpolicyEventCollectionGetOpts) (FpolicyEventResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FpolicyEventResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/fpolicy/{svm.uuid}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.VolumeMonitoring.IsSet() {
		localVarQueryParams.Add("volume_monitoring", parameterToString(localVarOptionals.VolumeMonitoring.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Protocol.IsSet() {
		localVarQueryParams.Add("protocol", parameterToString(localVarOptionals.Protocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersMonitorAds.IsSet() {
		localVarQueryParams.Add("filters.monitor_ads", parameterToString(localVarOptionals.FiltersMonitorAds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersWriteWithSizeChange.IsSet() {
		localVarQueryParams.Add("filters.write_with_size_change", parameterToString(localVarOptionals.FiltersWriteWithSizeChange.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersFirstRead.IsSet() {
		localVarQueryParams.Add("filters.first_read", parameterToString(localVarOptionals.FiltersFirstRead.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersSetattrWithModifyTimeChange.IsSet() {
		localVarQueryParams.Add("filters.setattr_with_modify_time_change", parameterToString(localVarOptionals.FiltersSetattrWithModifyTimeChange.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersOfflineBit.IsSet() {
		localVarQueryParams.Add("filters.offline_bit", parameterToString(localVarOptionals.FiltersOfflineBit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersOpenWithWriteIntent.IsSet() {
		localVarQueryParams.Add("filters.open_with_write_intent", parameterToString(localVarOptionals.FiltersOpenWithWriteIntent.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersFirstWrite.IsSet() {
		localVarQueryParams.Add("filters.first_write", parameterToString(localVarOptionals.FiltersFirstWrite.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersSetattrWithGroupChange.IsSet() {
		localVarQueryParams.Add("filters.setattr_with_group_change", parameterToString(localVarOptionals.FiltersSetattrWithGroupChange.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersSetattrWithAccessTimeChange.IsSet() {
		localVarQueryParams.Add("filters.setattr_with_access_time_change", parameterToString(localVarOptionals.FiltersSetattrWithAccessTimeChange.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersSetattrWithModeChange.IsSet() {
		localVarQueryParams.Add("filters.setattr_with_mode_change", parameterToString(localVarOptionals.FiltersSetattrWithModeChange.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersExcludeDirectory.IsSet() {
		localVarQueryParams.Add("filters.exclude_directory", parameterToString(localVarOptionals.FiltersExcludeDirectory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersSetattrWithOwnerChange.IsSet() {
		localVarQueryParams.Add("filters.setattr_with_owner_change", parameterToString(localVarOptionals.FiltersSetattrWithOwnerChange.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersSetattrWithDaclChange.IsSet() {
		localVarQueryParams.Add("filters.setattr_with_dacl_change", parameterToString(localVarOptionals.FiltersSetattrWithDaclChange.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersCloseWithModification.IsSet() {
		localVarQueryParams.Add("filters.close_with_modification", parameterToString(localVarOptionals.FiltersCloseWithModification.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersOpenWithDeleteIntent.IsSet() {
		localVarQueryParams.Add("filters.open_with_delete_intent", parameterToString(localVarOptionals.FiltersOpenWithDeleteIntent.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersSetattrWithSaclChange.IsSet() {
		localVarQueryParams.Add("filters.setattr_with_sacl_change", parameterToString(localVarOptionals.FiltersSetattrWithSaclChange.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersSetattrWithAllocationSizeChange.IsSet() {
		localVarQueryParams.Add("filters.setattr_with_allocation_size_change", parameterToString(localVarOptionals.FiltersSetattrWithAllocationSizeChange.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersCloseWithoutModification.IsSet() {
		localVarQueryParams.Add("filters.close_without_modification", parameterToString(localVarOptionals.FiltersCloseWithoutModification.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersSetattrWithSizeChange.IsSet() {
		localVarQueryParams.Add("filters.setattr_with_size_change", parameterToString(localVarOptionals.FiltersSetattrWithSizeChange.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersCloseWithRead.IsSet() {
		localVarQueryParams.Add("filters.close_with_read", parameterToString(localVarOptionals.FiltersCloseWithRead.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FiltersSetattrWithCreationTimeChange.IsSet() {
		localVarQueryParams.Add("filters.setattr_with_creation_time_change", parameterToString(localVarOptionals.FiltersSetattrWithCreationTimeChange.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FileOperationsLookup.IsSet() {
		localVarQueryParams.Add("file_operations.lookup", parameterToString(localVarOptionals.FileOperationsLookup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FileOperationsDeleteDir.IsSet() {
		localVarQueryParams.Add("file_operations.delete_dir", parameterToString(localVarOptionals.FileOperationsDeleteDir.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FileOperationsCreate.IsSet() {
		localVarQueryParams.Add("file_operations.create", parameterToString(localVarOptionals.FileOperationsCreate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FileOperationsRead.IsSet() {
		localVarQueryParams.Add("file_operations.read", parameterToString(localVarOptionals.FileOperationsRead.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FileOperationsRenameDir.IsSet() {
		localVarQueryParams.Add("file_operations.rename_dir", parameterToString(localVarOptionals.FileOperationsRenameDir.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FileOperationsWrite.IsSet() {
		localVarQueryParams.Add("file_operations.write", parameterToString(localVarOptionals.FileOperationsWrite.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FileOperationsGetattr.IsSet() {
		localVarQueryParams.Add("file_operations.getattr", parameterToString(localVarOptionals.FileOperationsGetattr.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FileOperationsSymlink.IsSet() {
		localVarQueryParams.Add("file_operations.symlink", parameterToString(localVarOptionals.FileOperationsSymlink.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FileOperationsLink.IsSet() {
		localVarQueryParams.Add("file_operations.link", parameterToString(localVarOptionals.FileOperationsLink.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FileOperationsRename.IsSet() {
		localVarQueryParams.Add("file_operations.rename", parameterToString(localVarOptionals.FileOperationsRename.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FileOperationsSetattr.IsSet() {
		localVarQueryParams.Add("file_operations.setattr", parameterToString(localVarOptionals.FileOperationsSetattr.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FileOperationsCreateDir.IsSet() {
		localVarQueryParams.Add("file_operations.create_dir", parameterToString(localVarOptionals.FileOperationsCreateDir.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FileOperationsOpen.IsSet() {
		localVarQueryParams.Add("file_operations.open", parameterToString(localVarOptionals.FileOperationsOpen.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FileOperationsDelete.IsSet() {
		localVarQueryParams.Add("file_operations.delete", parameterToString(localVarOptionals.FileOperationsDelete.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FileOperationsClose.IsSet() {
		localVarQueryParams.Add("file_operations.close", parameterToString(localVarOptionals.FileOperationsClose.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FpolicyEventResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Creates an FPolicy event configuration for a specified SVM. FPolicy event creation is allowed only on data SVMs. When a protocol is specified, you must specify a file operation or a file operation and filters. ### Required properties * &#x60;svm.uuid&#x60; - Existing SVM in which to create the FPolicy event. * &#x60;name&#x60; - Name of the FPolicy event. ### Recommended optional properties * &#x60;file-operations&#x60; - List of file operations to monitor. * &#x60;protocol&#x60; - Protocol for which the file operations should be monitored. * &#x60;filters&#x60; - List of filters for the specified file operations. ### Default property values If not specified in POST, the following default property values are assigned: * &#x60;file_operations.*&#x60; - _false_ * &#x60;filters.*&#x60; - _false_ * &#x60;volume-monitoring&#x60; - _false_ ### Related ONTAP commands * &#x60;fpolicy policy event create&#x60; ### Learn more * [&#x60;DOC /protocols/fpolicy/{svm.uuid}/events&#x60;](#docs-NAS-protocols_fpolicy_{svm.uuid}_events) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param optional nil or *FpolicyEventCreateOpts - Optional Parameters:
     * @param "Info" (optional.Interface of FpolicyEvent) -  Info specification

@return FpolicyEventResponse
*/

type FpolicyEventCreateOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) FpolicyEventCreate(ctx context.Context, svmUuid string, localVarOptionals *FpolicyEventCreateOpts) (FpolicyEventResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FpolicyEventResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/fpolicy/{svm.uuid}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(FpolicyEvent)
		if !localVarOptionalInfook {
				return localVarReturnValue, nil, reportError("info should be FpolicyEvent")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v FpolicyEventResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Deletes a specific FPolicy event configuration for an SVM. A cluster-level FPolicy event configuration cannot be modified for a data SVM through REST. An FPolicy event that is attached to an FPolicy policy cannot be deleted. ### Related ONTAP commands * &#x60;fpolicy policy event delete&#x60; ### Learn more * [&#x60;DOC /protocols/fpolicy/{svm.uuid}/events&#x60;](#docs-NAS-protocols_fpolicy_{svm.uuid}_events) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param name


*/
func (a *NASApiService) FpolicyEventDelete(ctx context.Context, svmUuid string, name string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/fpolicy/{svm.uuid}/events/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Updates a specific FPolicy event configuration for an SVM. A cluster-level FPolicy event configuration cannot be modified for a data SVM through REST. When the file operations and filters fields are modified, the previous values are retained and new values are added to the list of previous values. To remove a particular file operation or filter, set its value to false in the request. ### Related ONTAP commands * &#x60;fpolicy policy event modify&#x60; ### Learn more * [&#x60;DOC /protocols/fpolicy/{svm.uuid}/events&#x60;](#docs-NAS-protocols_fpolicy_{svm.uuid}_events) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param name
 * @param optional nil or *FpolicyEventModifyOpts - Optional Parameters:
     * @param "Info" (optional.Interface of FpolicyEvent) -  Info specification


*/

type FpolicyEventModifyOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) FpolicyEventModify(ctx context.Context, svmUuid string, name string, localVarOptionals *FpolicyEventModifyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/fpolicy/{svm.uuid}/events/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(FpolicyEvent)
		if !localVarOptionalInfook {
				return nil, reportError("info should be FpolicyEvent")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves a specific FPolicy event configuration for an SVM. A cluster-level FPolicy event configuration cannot be retrieved for a data SVM through a REST API. ### Related ONTAP commands * &#x60;fpolicy policy event show&#x60; ### Learn more * [&#x60;DOC /protocols/fpolicy/{svm.uuid}/events&#x60;](#docs-NAS-protocols_fpolicy_{svm.uuid}_events) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param name
 * @param optional nil or *FpolicyEventsGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return FpolicyEvent
*/

type FpolicyEventsGetOpts struct { 
	Fields optional.Interface
}

func (a *NASApiService) FpolicyEventsGet(ctx context.Context, svmUuid string, name string, localVarOptionals *FpolicyEventsGetOpts) (FpolicyEvent, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FpolicyEvent
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/fpolicy/{svm.uuid}/events/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FpolicyEvent
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves an FPolicy configuration of an SVM. ### Related ONTAP commands * &#x60;fpolicy show&#x60; * &#x60;fpolicy policy show&#x60; * &#x60;fpolicy policy scope show&#x60; * &#x60;fpolicy policy event show&#x60; * &#x60;fpolicy policy external-engine show&#x60; ### Learn more * [&#x60;DOC /protocols/fpolicy&#x60;](#docs-NAS-protocols_fpolicy) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param optional nil or *FpolicyGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return Fpolicy
*/

type FpolicyGetOpts struct { 
	Fields optional.Interface
}

func (a *NASApiService) FpolicyGet(ctx context.Context, svmUuid string, localVarOptionals *FpolicyGetOpts) (Fpolicy, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Fpolicy
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/fpolicy/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Fpolicy
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves the FPolicy policy configuration of an SVM. ONTAP allows the creation of a cluster level FPolicy policy that acts as a template for all the data SVMs belonging to the cluster. This cluster level FPolicy policy is also retrieved for the specified SVM. ### Related ONTAP commands * &#x60;fpolicy policy show&#x60; * &#x60;fpolicy policy scope show&#x60; ### Learn more * [&#x60;DOC /protocols/fpolicy/{svm.uuid}/policies&#x60;](#docs-NAS-protocols_fpolicy_{svm.uuid}_policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param optional nil or *FpolicyPolicyCollectionGetOpts - Optional Parameters:
     * @param "Enabled" (optional.Bool) -  Filter by enabled
     * @param "ScopeExcludeExportPolicies" (optional.String) -  Filter by scope.exclude_export_policies
     * @param "ScopeExcludeShares" (optional.String) -  Filter by scope.exclude_shares
     * @param "ScopeIncludeExtension" (optional.String) -  Filter by scope.include_extension
     * @param "ScopeExcludeExtension" (optional.String) -  Filter by scope.exclude_extension
     * @param "ScopeIncludeShares" (optional.String) -  Filter by scope.include_shares
     * @param "ScopeIncludeVolumes" (optional.String) -  Filter by scope.include_volumes
     * @param "ScopeIncludeExportPolicies" (optional.String) -  Filter by scope.include_export_policies
     * @param "ScopeExcludeVolumes" (optional.String) -  Filter by scope.exclude_volumes
     * @param "Priority" (optional.Int32) -  Filter by priority
     * @param "EngineName" (optional.String) -  Filter by engine.name
     * @param "EventsName" (optional.String) -  Filter by events.name
     * @param "Name" (optional.String) -  Filter by name
     * @param "Mandatory" (optional.Bool) -  Filter by mandatory
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return FpolicyPolicyResponse
*/

type FpolicyPolicyCollectionGetOpts struct { 
	Enabled optional.Bool
	ScopeExcludeExportPolicies optional.String
	ScopeExcludeShares optional.String
	ScopeIncludeExtension optional.String
	ScopeExcludeExtension optional.String
	ScopeIncludeShares optional.String
	ScopeIncludeVolumes optional.String
	ScopeIncludeExportPolicies optional.String
	ScopeExcludeVolumes optional.String
	Priority optional.Int32
	EngineName optional.String
	EventsName optional.String
	Name optional.String
	Mandatory optional.Bool
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NASApiService) FpolicyPolicyCollectionGet(ctx context.Context, svmUuid string, localVarOptionals *FpolicyPolicyCollectionGetOpts) (FpolicyPolicyResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FpolicyPolicyResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/fpolicy/{svm.uuid}/policies"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarQueryParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScopeExcludeExportPolicies.IsSet() {
		localVarQueryParams.Add("scope.exclude_export_policies", parameterToString(localVarOptionals.ScopeExcludeExportPolicies.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScopeExcludeShares.IsSet() {
		localVarQueryParams.Add("scope.exclude_shares", parameterToString(localVarOptionals.ScopeExcludeShares.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScopeIncludeExtension.IsSet() {
		localVarQueryParams.Add("scope.include_extension", parameterToString(localVarOptionals.ScopeIncludeExtension.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScopeExcludeExtension.IsSet() {
		localVarQueryParams.Add("scope.exclude_extension", parameterToString(localVarOptionals.ScopeExcludeExtension.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScopeIncludeShares.IsSet() {
		localVarQueryParams.Add("scope.include_shares", parameterToString(localVarOptionals.ScopeIncludeShares.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScopeIncludeVolumes.IsSet() {
		localVarQueryParams.Add("scope.include_volumes", parameterToString(localVarOptionals.ScopeIncludeVolumes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScopeIncludeExportPolicies.IsSet() {
		localVarQueryParams.Add("scope.include_export_policies", parameterToString(localVarOptionals.ScopeIncludeExportPolicies.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScopeExcludeVolumes.IsSet() {
		localVarQueryParams.Add("scope.exclude_volumes", parameterToString(localVarOptionals.ScopeExcludeVolumes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Priority.IsSet() {
		localVarQueryParams.Add("priority", parameterToString(localVarOptionals.Priority.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EngineName.IsSet() {
		localVarQueryParams.Add("engine.name", parameterToString(localVarOptionals.EngineName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventsName.IsSet() {
		localVarQueryParams.Add("events.name", parameterToString(localVarOptionals.EventsName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Mandatory.IsSet() {
		localVarQueryParams.Add("mandatory", parameterToString(localVarOptionals.Mandatory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FpolicyPolicyResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Creates an FPolicy policy configuration for the specified SVM. To create an FPolicy policy, you must specify the policy scope and the FPolicy events to be monitored. &lt;/br&gt;Important notes: * A single policy can monitor multiple events. * An FPolicy engine is an optional field whose default value is set to native. A native engine can be used to simply block the file access based on the file extensions specified in the policy scope. * To enable a policy, the policy priority  must be specified. If the priority is not specified, the policy is created but it is not enabled. * The \&quot;mandatory\&quot; field, if set to true, blocks the file access when the primary or secondary FPolicy servers are down. ### Required properties * &#x60;svm.uuid&#x60; - Existing SVM in which to create the FPolicy policy. * &#x60;events&#x60; - Name of the events to monitior. * &#x60;name&#x60; - Name of the FPolicy policy. * &#x60;scope&#x60; - Scope of the policy. Can be limited to exports, volumes, shares or file extensions. * &#x60;priority&#x60;- Priority of the policy (ranging from 1 to 10). ### Default property values * &#x60;mandatory&#x60; - _true_ * &#x60;engine&#x60; - _native_ ### Related ONTAP commands * &#x60;fpolicy policy scope create&#x60; * &#x60;fpolicy policy create&#x60; * &#x60;fpolicy enable&#x60; ### Learn more * [&#x60;DOC /protocols/fpolicy/{svm.uuid}/policies&#x60;](#docs-NAS-protocols_fpolicy_{svm.uuid}_policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param optional nil or *FpolicyPolicyCreateOpts - Optional Parameters:
     * @param "Info" (optional.Interface of FpolicyPolicy) -  Info specification

@return FpolicyPolicyResponse
*/

type FpolicyPolicyCreateOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) FpolicyPolicyCreate(ctx context.Context, svmUuid string, localVarOptionals *FpolicyPolicyCreateOpts) (FpolicyPolicyResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FpolicyPolicyResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/fpolicy/{svm.uuid}/policies"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(FpolicyPolicy)
		if !localVarOptionalInfook {
				return localVarReturnValue, nil, reportError("info should be FpolicyPolicy")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v FpolicyPolicyResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Deletes a particular FPolicy policy configuration for a specified SVM. To delete a policy, you must first disable the policy. ### Related ONTAP commands * &#x60;fpolicy policy scope delete&#x60; * &#x60;fpolicy policy delete&#x60; ### Learn more * [&#x60;DOC /protocols/fpolicy/{svm.uuid}/policies&#x60;](#docs-NAS-protocols_fpolicy_{svm.uuid}_policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param name


*/
func (a *NASApiService) FpolicyPolicyDelete(ctx context.Context, svmUuid string, name string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/fpolicy/{svm.uuid}/policies/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves a particular FPolicy policy configuration for a specified SVM. Cluster-level FPolicy policy configuration details cannot be retrieved for a data SVM. ### Related ONTAP commands * &#x60;fpolicy policy show&#x60; * &#x60;fpolicy policy scope show&#x60; * &#x60;fpolicy show&#x60; ### Learn more * [&#x60;DOC /protocols/fpolicy/{svm.uuid}/policies&#x60;](#docs-NAS-protocols_fpolicy_{svm.uuid}_policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param name
 * @param optional nil or *FpolicyPolicyGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return FpolicyPolicy
*/

type FpolicyPolicyGetOpts struct { 
	Fields optional.Interface
}

func (a *NASApiService) FpolicyPolicyGet(ctx context.Context, svmUuid string, name string, localVarOptionals *FpolicyPolicyGetOpts) (FpolicyPolicy, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FpolicyPolicy
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/fpolicy/{svm.uuid}/policies/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FpolicyPolicy
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Updates a particular FPolicy policy configuration for a specified SVM. PATCH can be used to enable or disable the policy. When enabling a policy, you must specify the policy priority. The policy priority of the policy is not required when disabling the policy. If the policy is enabled, the FPolicy policy engine cannot be modified. ### Related ONTAP commands * &#x60;fpolicy policy modify&#x60; * &#x60;fpolicy policy scope modify&#x60; * &#x60;fpolicy enable&#x60; * &#x60;fpolicy disable&#x60; ### Learn more * [&#x60;DOC /protocols/fpolicy/{svm.uuid}/policies&#x60;](#docs-NAS-protocols_fpolicy_{svm.uuid}_policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param name
 * @param optional nil or *FpolicyPolicyModifyOpts - Optional Parameters:
     * @param "Info" (optional.Interface of FpolicyPolicy) -  Info specification


*/

type FpolicyPolicyModifyOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) FpolicyPolicyModify(ctx context.Context, svmUuid string, name string, localVarOptionals *FpolicyPolicyModifyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/fpolicy/{svm.uuid}/policies/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(FpolicyPolicy)
		if !localVarOptionalInfook {
				return nil, reportError("info should be FpolicyPolicy")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves Kerberos interfaces. ### Related ONTAP commands * &#x60;vserver nfs kerberos interface show&#x60; ### Learn more * [&#x60;DOC /protocols/nfs/kerberos/interfaces&#x60;](#docs-NAS-protocols_nfs_kerberos_interfaces) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *KerberosInterfaceCollectionGetOpts - Optional Parameters:
     * @param "EncryptionTypes" (optional.String) -  Filter by encryption_types
     * @param "InterfaceName" (optional.String) -  Filter by interface.name
     * @param "InterfaceUuid" (optional.String) -  Filter by interface.uuid
     * @param "InterfaceIpAddress" (optional.String) -  Filter by interface.ip.address
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "Enabled" (optional.Bool) -  Filter by enabled
     * @param "Spn" (optional.String) -  Filter by spn
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return KerberosInterfaceResponse
*/

type KerberosInterfaceCollectionGetOpts struct { 
	EncryptionTypes optional.String
	InterfaceName optional.String
	InterfaceUuid optional.String
	InterfaceIpAddress optional.String
	SvmUuid optional.String
	SvmName optional.String
	Enabled optional.Bool
	Spn optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NASApiService) KerberosInterfaceCollectionGet(ctx context.Context, localVarOptionals *KerberosInterfaceCollectionGetOpts) (KerberosInterfaceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue KerberosInterfaceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nfs/kerberos/interfaces"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.EncryptionTypes.IsSet() {
		localVarQueryParams.Add("encryption_types", parameterToString(localVarOptionals.EncryptionTypes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InterfaceName.IsSet() {
		localVarQueryParams.Add("interface.name", parameterToString(localVarOptionals.InterfaceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InterfaceUuid.IsSet() {
		localVarQueryParams.Add("interface.uuid", parameterToString(localVarOptionals.InterfaceUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InterfaceIpAddress.IsSet() {
		localVarQueryParams.Add("interface.ip.address", parameterToString(localVarOptionals.InterfaceIpAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarQueryParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Spn.IsSet() {
		localVarQueryParams.Add("spn", parameterToString(localVarOptionals.Spn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v KerberosInterfaceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves a Kerberos interface. ### Related ONTAP commands * &#x60;vserver nfs kerberos interface show&#x60; ### Learn more * [&#x60;DOC /protocols/nfs/kerberos/interfaces&#x60;](#docs-NAS-protocols_nfs_kerberos_interfaces) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Network interface UUID
 * @param optional nil or *KerberosInterfaceGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return KerberosInterface
*/

type KerberosInterfaceGetOpts struct { 
	Fields optional.Interface
}

func (a *NASApiService) KerberosInterfaceGet(ctx context.Context, uuid string, localVarOptionals *KerberosInterfaceGetOpts) (KerberosInterface, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue KerberosInterface
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nfs/kerberos/interfaces/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v KerberosInterface
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Updates the properties of a Kerberos interface. ### Related ONTAP commands * &#x60;vserver nfs kerberos interface modify&#x60; * &#x60;vserver nfs kerberos interface enable&#x60; * &#x60;vserver nfs kerberos interface disable&#x60; ### Learn more * [&#x60;DOC /protocols/nfs/kerberos/interfaces&#x60;](#docs-NAS-protocols_nfs_kerberos_interfaces) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param uuid Network interface UUID
 * @param optional nil or *KerberosInterfaceModifyOpts - Optional Parameters:
     * @param "Info" (optional.Interface of KerberosInterface) -  Info specification


*/

type KerberosInterfaceModifyOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) KerberosInterfaceModify(ctx context.Context, uuid string, localVarOptionals *KerberosInterfaceModifyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nfs/kerberos/interfaces/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", fmt.Sprintf("%v", uuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(KerberosInterface)
		if !localVarOptionalInfook {
				return nil, reportError("info should be KerberosInterface")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves Kerberos realms. ### Related ONTAP commands * &#x60;vserver nfs kerberos realm show&#x60; ### Learn more * [&#x60;DOC /protocols/nfs/kerberos/realms&#x60;](#docs-NAS-protocols_nfs_kerberos_realms) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *KerberosRealmCollectionGetOpts - Optional Parameters:
     * @param "AdServerName" (optional.String) -  Filter by ad_server.name
     * @param "AdServerAddress" (optional.String) -  Filter by ad_server.address
     * @param "KdcVendor" (optional.String) -  Filter by kdc.vendor
     * @param "KdcIp" (optional.String) -  Filter by kdc.ip
     * @param "KdcPort" (optional.Int32) -  Filter by kdc.port
     * @param "Comment" (optional.String) -  Filter by comment
     * @param "EncryptionTypes" (optional.String) -  Filter by encryption_types
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "Name" (optional.String) -  Filter by name
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return KerberosRealmResponse
*/

type KerberosRealmCollectionGetOpts struct { 
	AdServerName optional.String
	AdServerAddress optional.String
	KdcVendor optional.String
	KdcIp optional.String
	KdcPort optional.Int32
	Comment optional.String
	EncryptionTypes optional.String
	SvmUuid optional.String
	SvmName optional.String
	Name optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NASApiService) KerberosRealmCollectionGet(ctx context.Context, localVarOptionals *KerberosRealmCollectionGetOpts) (KerberosRealmResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue KerberosRealmResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nfs/kerberos/realms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.AdServerName.IsSet() {
		localVarQueryParams.Add("ad_server.name", parameterToString(localVarOptionals.AdServerName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AdServerAddress.IsSet() {
		localVarQueryParams.Add("ad_server.address", parameterToString(localVarOptionals.AdServerAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.KdcVendor.IsSet() {
		localVarQueryParams.Add("kdc.vendor", parameterToString(localVarOptionals.KdcVendor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.KdcIp.IsSet() {
		localVarQueryParams.Add("kdc.ip", parameterToString(localVarOptionals.KdcIp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.KdcPort.IsSet() {
		localVarQueryParams.Add("kdc.port", parameterToString(localVarOptionals.KdcPort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Comment.IsSet() {
		localVarQueryParams.Add("comment", parameterToString(localVarOptionals.Comment.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EncryptionTypes.IsSet() {
		localVarQueryParams.Add("encryption_types", parameterToString(localVarOptionals.EncryptionTypes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v KerberosRealmResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Creates a Kerberos realm. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM on which to create the Kerberos realm. * &#x60;name&#x60; - Base name for the Kerberos realm. * &#x60;kdc.vendor&#x60; - Vendor of the Key Distribution Center (KDC) server for this Kerberos realm. If the configuration uses a Microsoft Active Directory domain for authentication, this field nust be &#x60;microsoft&#x60;. * &#x60;kdc.ip&#x60; - IP address of the KDC server for this Kerberos realm. ### Recommended optional properties * &#x60;ad_server.name&#x60; - Host name of the Active Directory Domain Controller (DC). This is a mandatory parameter if the kdc-vendor is &#x60;microsoft&#x60;. * &#x60;ad_server.address&#x60; - IP address of the Active Directory Domain Controller (DC). This is a mandatory parameter if the kdc-vendor is &#x60;microsoft&#x60;. ### Default property values If not specified in POST, the following default property value is assigned: * &#x60;kdc.port&#x60; - _88_ ### Related ONTAP commands * &#x60;vserver nfs kerberos realm create&#x60; ### Learn more * [&#x60;DOC /protocols/nfs/kerberos/realms&#x60;](#docs-NAS-protocols_nfs_kerberos_realms) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *KerberosRealmCreateOpts - Optional Parameters:
     * @param "Info" (optional.Interface of KerberosRealm) -  Info specification


*/

type KerberosRealmCreateOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) KerberosRealmCreate(ctx context.Context, localVarOptionals *KerberosRealmCreateOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nfs/kerberos/realms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(KerberosRealm)
		if !localVarOptionalInfook {
				return nil, reportError("info should be KerberosRealm")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Deletes a Kerberos realm. * &#x60;vserver nfs kerberos realm delete&#x60; ### Learn more * [&#x60;DOC /protocols/nfs/kerberos/realms&#x60;](#docs-NAS-protocols_nfs_kerberos_realms) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid SVM UUID
 * @param name Kerberos realm


*/
func (a *NASApiService) KerberosRealmDelete(ctx context.Context, svmUuid string, name string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nfs/kerberos/realms/{svm.uuid}/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves a Kerberos realm. * &#x60;vserver nfs kerberos realm show&#x60; ### Learn more * [&#x60;DOC /protocols/nfs/kerberos/realms&#x60;](#docs-NAS-protocols_nfs_kerberos_realms) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid SVM UUID
 * @param name Kerberos realm
 * @param optional nil or *KerberosRealmGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return KerberosRealm
*/

type KerberosRealmGetOpts struct { 
	Fields optional.Interface
}

func (a *NASApiService) KerberosRealmGet(ctx context.Context, svmUuid string, name string, localVarOptionals *KerberosRealmGetOpts) (KerberosRealm, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue KerberosRealm
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nfs/kerberos/realms/{svm.uuid}/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v KerberosRealm
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Updates the properties of a Kerberos realm. * &#x60;vserver nfs kerberos realm modify&#x60; ### Learn more * [&#x60;DOC /protocols/nfs/kerberos/realms&#x60;](#docs-NAS-protocols_nfs_kerberos_realms) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid SVM UUID
 * @param name Kerberos realm
 * @param optional nil or *KerberosRealmModifyOpts - Optional Parameters:
     * @param "Info" (optional.Interface of KerberosRealm) -  Info specification


*/

type KerberosRealmModifyOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) KerberosRealmModify(ctx context.Context, svmUuid string, name string, localVarOptionals *KerberosRealmModifyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nfs/kerberos/realms/{svm.uuid}/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(KerberosRealm)
		if !localVarOptionalInfook {
				return nil, reportError("info should be KerberosRealm")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves the NFS configuration of SVMs. ### Related ONTAP commands * &#x60;vserver nfs show&#x60; * &#x60;vserver nfs status&#x60; ### Learn more * [&#x60;DOC /protocols/nfs/services&#x60;](#docs-NAS-protocols_nfs_services) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *NfsCollectionGetOpts - Optional Parameters:
     * @param "State" (optional.String) -  Filter by state
     * @param "ProtocolV40Enabled" (optional.Bool) -  Filter by protocol.v40_enabled
     * @param "ProtocolV4IdDomain" (optional.String) -  Filter by protocol.v4_id_domain
     * @param "ProtocolV3Enabled" (optional.Bool) -  Filter by protocol.v3_enabled
     * @param "ProtocolV41Enabled" (optional.Bool) -  Filter by protocol.v41_enabled
     * @param "ProtocolV40FeaturesReadDelegationEnabled" (optional.Bool) -  Filter by protocol.v40_features.read_delegation_enabled
     * @param "ProtocolV40FeaturesWriteDelegationEnabled" (optional.Bool) -  Filter by protocol.v40_features.write_delegation_enabled
     * @param "ProtocolV40FeaturesAclEnabled" (optional.Bool) -  Filter by protocol.v40_features.acl_enabled
     * @param "ProtocolV41FeaturesAclEnabled" (optional.Bool) -  Filter by protocol.v41_features.acl_enabled
     * @param "ProtocolV41FeaturesReadDelegationEnabled" (optional.Bool) -  Filter by protocol.v41_features.read_delegation_enabled
     * @param "ProtocolV41FeaturesPnfsEnabled" (optional.Bool) -  Filter by protocol.v41_features.pnfs_enabled
     * @param "ProtocolV41FeaturesWriteDelegationEnabled" (optional.Bool) -  Filter by protocol.v41_features.write_delegation_enabled
     * @param "Enabled" (optional.Bool) -  Filter by enabled
     * @param "VstorageEnabled" (optional.Bool) -  Filter by vstorage_enabled
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "TransportTcpEnabled" (optional.Bool) -  Filter by transport.tcp_enabled
     * @param "TransportUdpEnabled" (optional.Bool) -  Filter by transport.udp_enabled
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return NfsServiceResponse
*/

type NfsCollectionGetOpts struct { 
	State optional.String
	ProtocolV40Enabled optional.Bool
	ProtocolV4IdDomain optional.String
	ProtocolV3Enabled optional.Bool
	ProtocolV41Enabled optional.Bool
	ProtocolV40FeaturesReadDelegationEnabled optional.Bool
	ProtocolV40FeaturesWriteDelegationEnabled optional.Bool
	ProtocolV40FeaturesAclEnabled optional.Bool
	ProtocolV41FeaturesAclEnabled optional.Bool
	ProtocolV41FeaturesReadDelegationEnabled optional.Bool
	ProtocolV41FeaturesPnfsEnabled optional.Bool
	ProtocolV41FeaturesWriteDelegationEnabled optional.Bool
	Enabled optional.Bool
	VstorageEnabled optional.Bool
	SvmUuid optional.String
	SvmName optional.String
	TransportTcpEnabled optional.Bool
	TransportUdpEnabled optional.Bool
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnTimeout optional.Int32
	ReturnRecords optional.Bool
	OrderBy optional.Interface
}

func (a *NASApiService) NfsCollectionGet(ctx context.Context, localVarOptionals *NfsCollectionGetOpts) (NfsServiceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NfsServiceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nfs/services"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolV40Enabled.IsSet() {
		localVarQueryParams.Add("protocol.v40_enabled", parameterToString(localVarOptionals.ProtocolV40Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolV4IdDomain.IsSet() {
		localVarQueryParams.Add("protocol.v4_id_domain", parameterToString(localVarOptionals.ProtocolV4IdDomain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolV3Enabled.IsSet() {
		localVarQueryParams.Add("protocol.v3_enabled", parameterToString(localVarOptionals.ProtocolV3Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolV41Enabled.IsSet() {
		localVarQueryParams.Add("protocol.v41_enabled", parameterToString(localVarOptionals.ProtocolV41Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolV40FeaturesReadDelegationEnabled.IsSet() {
		localVarQueryParams.Add("protocol.v40_features.read_delegation_enabled", parameterToString(localVarOptionals.ProtocolV40FeaturesReadDelegationEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolV40FeaturesWriteDelegationEnabled.IsSet() {
		localVarQueryParams.Add("protocol.v40_features.write_delegation_enabled", parameterToString(localVarOptionals.ProtocolV40FeaturesWriteDelegationEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolV40FeaturesAclEnabled.IsSet() {
		localVarQueryParams.Add("protocol.v40_features.acl_enabled", parameterToString(localVarOptionals.ProtocolV40FeaturesAclEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolV41FeaturesAclEnabled.IsSet() {
		localVarQueryParams.Add("protocol.v41_features.acl_enabled", parameterToString(localVarOptionals.ProtocolV41FeaturesAclEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolV41FeaturesReadDelegationEnabled.IsSet() {
		localVarQueryParams.Add("protocol.v41_features.read_delegation_enabled", parameterToString(localVarOptionals.ProtocolV41FeaturesReadDelegationEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolV41FeaturesPnfsEnabled.IsSet() {
		localVarQueryParams.Add("protocol.v41_features.pnfs_enabled", parameterToString(localVarOptionals.ProtocolV41FeaturesPnfsEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProtocolV41FeaturesWriteDelegationEnabled.IsSet() {
		localVarQueryParams.Add("protocol.v41_features.write_delegation_enabled", parameterToString(localVarOptionals.ProtocolV41FeaturesWriteDelegationEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarQueryParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VstorageEnabled.IsSet() {
		localVarQueryParams.Add("vstorage_enabled", parameterToString(localVarOptionals.VstorageEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransportTcpEnabled.IsSet() {
		localVarQueryParams.Add("transport.tcp_enabled", parameterToString(localVarOptionals.TransportTcpEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TransportUdpEnabled.IsSet() {
		localVarQueryParams.Add("transport.udp_enabled", parameterToString(localVarOptionals.TransportUdpEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NfsServiceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Creates an NFS configuration for an SVM. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM for which to create the NFS configuration. ### Default property values If not specified in POST, the following default property values are assigned: * &#x60;enabled&#x60; - _true_ * &#x60;state&#x60; - online * &#x60;transport.udp_enabled&#x60; - _true_ * &#x60;transport.tcp_enabled&#x60; - _true_ * &#x60;protocol.v3_enabled&#x60; - _true_ * &#x60;protocol.v4_id_domain&#x60; - defaultv4iddomain.com * &#x60;protocol.v4_enabled&#x60; - _false_ * &#x60;protocol.v41_enabled&#x60; - _false_ * &#x60;protocol.v40_features.acl_enabled&#x60; - _false_ * &#x60;protocol.v40_features.read_delegation_enabled&#x60; - _false_ * &#x60;protocol.v40_features.write_delegation_enabled&#x60; - _false_ * &#x60;protocol.v41_features.acl_enabled&#x60; - _false_ * &#x60;protocol.v41_features.read_delegation_enabled&#x60; - _false_ * &#x60;protocol.v41_features.write_delegation_enabled&#x60; - _false_ * &#x60;protocol.v41_features.pnfs_enabled&#x60; - _false_ * &#x60;vstorage_enabled&#x60; - _false_ ### Related ONTAP commands * &#x60;vserver nfs create&#x60; ### Learn more * [&#x60;DOC /protocols/nfs/services&#x60;](#docs-NAS-protocols_nfs_services) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *NfsCreateOpts - Optional Parameters:
     * @param "Info" (optional.Interface of NfsService) -  Info Specification

@return NfsServiceResponse
*/

type NfsCreateOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) NfsCreate(ctx context.Context, localVarOptionals *NfsCreateOpts) (NfsServiceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NfsServiceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nfs/services"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(NfsService)
		if !localVarOptionalInfook {
				return localVarReturnValue, nil, reportError("info should be NfsService")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v NfsServiceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Deletes the NFS configuration of an SVM. ### Related ONTAP commands * &#x60;vserver nfs delete&#x60; ### Learn more * [&#x60;DOC /protocols/nfs/services&#x60;](#docs-NAS-protocols_nfs_services) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid


*/
func (a *NASApiService) NfsDelete(ctx context.Context, svmUuid string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nfs/services/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves the NFS configuration of an SVM. ### Related ONTAP commands * &#x60;vserver nfs show&#x60; * &#x60;vserver nfs status&#x60; ### Learn more * [&#x60;DOC /protocols/nfs/services&#x60;](#docs-NAS-protocols_nfs_services) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid
 * @param optional nil or *NfsGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return NfsService
*/

type NfsGetOpts struct { 
	Fields optional.Interface
}

func (a *NASApiService) NfsGet(ctx context.Context, svmUuid string, localVarOptionals *NfsGetOpts) (NfsService, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NfsService
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nfs/services/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v NfsService
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Updates the NFS configuration of an SVM. ### Related ONTAP commands * &#x60;vserver nfs modify&#x60; * &#x60;vserver nfs on&#x60; * &#x60;vserver nfs off&#x60; * &#x60;vserver nfs start&#x60; * &#x60;vserver nfs stop&#x60; ### Learn more * [&#x60;DOC /protocols/nfs/services&#x60;](#docs-NAS-protocols_nfs_services) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid
 * @param optional nil or *NfsModifyOpts - Optional Parameters:
     * @param "Info" (optional.Interface of NfsService) -  Info Specification


*/

type NfsModifyOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) NfsModify(ctx context.Context, svmUuid string, localVarOptionals *NfsModifyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/nfs/services/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(NfsService)
		if !localVarOptionalInfook {
				return nil, reportError("info should be NfsService")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves the Vscan configuration. This includes scanner-pools, On-Access policies, On-Demand policies, and information about whether a Vscan is enabled or disabled on an SVM.&lt;br/&gt; Important notes: * There can be only one Vscan configuration enabled for an SVM at any time. * You can only query using &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60;. ### Related ONTAP commands * &#x60;vserver vscan show&#x60; * &#x60;vserver vscan scanner-pool show&#x60; * &#x60;vserver vscan scanner-pool servers show&#x60; * &#x60;vserver vscan scanner-pool privileged-users show&#x60; * &#x60;vserver vscan scanner-pool show-active&#x60; * &#x60;vserver vscan on-access-policy show&#x60; * &#x60;vserver vscan on-access-policy file-ext-to-exclude show&#x60; * &#x60;vserver vscan on-access-policy file-ext-to-include show&#x60; * &#x60;vserver vscan on-access-policy paths-to-exclude show&#x60; * &#x60;vserver vscan on-demand-task show&#x60; ### Learn more * [&#x60;DOC /protocols/vscan&#x60;](#docs-NAS-protocols_vscan) * [&#x60;DOC /protocols/vscan/{svm.uuid}/scanner-pools&#x60;](#docs-NAS-protocols_vscan_{svm.uuid}_scanner-pools) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *VscanCollectionGetOpts - Optional Parameters:
     * @param "OnDemandPoliciesScopeScanWithoutExtension" (optional.Bool) -  Filter by on_demand_policies.scope.scan_without_extension
     * @param "OnDemandPoliciesScopeExcludePaths" (optional.String) -  Filter by on_demand_policies.scope.exclude_paths
     * @param "OnDemandPoliciesScopeExcludeExtensions" (optional.String) -  Filter by on_demand_policies.scope.exclude_extensions
     * @param "OnDemandPoliciesScopeIncludeExtensions" (optional.String) -  Filter by on_demand_policies.scope.include_extensions
     * @param "OnDemandPoliciesScopeMaxFileSize" (optional.Int32) -  Filter by on_demand_policies.scope.max_file_size
     * @param "OnDemandPoliciesName" (optional.String) -  Filter by on_demand_policies.name
     * @param "OnDemandPoliciesScanPaths" (optional.String) -  Filter by on_demand_policies.scan_paths
     * @param "OnDemandPoliciesLogPath" (optional.String) -  Filter by on_demand_policies.log_path
     * @param "OnDemandPoliciesScheduleUuid" (optional.String) -  Filter by on_demand_policies.schedule.uuid
     * @param "OnDemandPoliciesScheduleName" (optional.String) -  Filter by on_demand_policies.schedule.name
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "ScannerPoolsPrivilegedUsers" (optional.String) -  Filter by scanner_pools.privileged_users
     * @param "ScannerPoolsName" (optional.String) -  Filter by scanner_pools.name
     * @param "ScannerPoolsClusterUuid" (optional.String) -  Filter by scanner_pools.cluster.uuid
     * @param "ScannerPoolsClusterName" (optional.String) -  Filter by scanner_pools.cluster.name
     * @param "ScannerPoolsServers" (optional.String) -  Filter by scanner_pools.servers
     * @param "ScannerPoolsRole" (optional.String) -  Filter by scanner_pools.role
     * @param "OnAccessPoliciesScopeScanReadonlyVolumes" (optional.Bool) -  Filter by on_access_policies.scope.scan_readonly_volumes
     * @param "OnAccessPoliciesScopeIncludeExtensions" (optional.String) -  Filter by on_access_policies.scope.include_extensions
     * @param "OnAccessPoliciesScopeMaxFileSize" (optional.Int32) -  Filter by on_access_policies.scope.max_file_size
     * @param "OnAccessPoliciesScopeExcludeExtensions" (optional.String) -  Filter by on_access_policies.scope.exclude_extensions
     * @param "OnAccessPoliciesScopeOnlyExecuteAccess" (optional.Bool) -  Filter by on_access_policies.scope.only_execute_access
     * @param "OnAccessPoliciesScopeScanWithoutExtension" (optional.Bool) -  Filter by on_access_policies.scope.scan_without_extension
     * @param "OnAccessPoliciesScopeExcludePaths" (optional.String) -  Filter by on_access_policies.scope.exclude_paths
     * @param "OnAccessPoliciesEnabled" (optional.Bool) -  Filter by on_access_policies.enabled
     * @param "OnAccessPoliciesName" (optional.String) -  Filter by on_access_policies.name
     * @param "OnAccessPoliciesMandatory" (optional.Bool) -  Filter by on_access_policies.mandatory
     * @param "Enabled" (optional.Bool) -  Filter by enabled
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return VscanResponse
*/

type VscanCollectionGetOpts struct { 
	OnDemandPoliciesScopeScanWithoutExtension optional.Bool
	OnDemandPoliciesScopeExcludePaths optional.String
	OnDemandPoliciesScopeExcludeExtensions optional.String
	OnDemandPoliciesScopeIncludeExtensions optional.String
	OnDemandPoliciesScopeMaxFileSize optional.Int32
	OnDemandPoliciesName optional.String
	OnDemandPoliciesScanPaths optional.String
	OnDemandPoliciesLogPath optional.String
	OnDemandPoliciesScheduleUuid optional.String
	OnDemandPoliciesScheduleName optional.String
	SvmUuid optional.String
	SvmName optional.String
	ScannerPoolsPrivilegedUsers optional.String
	ScannerPoolsName optional.String
	ScannerPoolsClusterUuid optional.String
	ScannerPoolsClusterName optional.String
	ScannerPoolsServers optional.String
	ScannerPoolsRole optional.String
	OnAccessPoliciesScopeScanReadonlyVolumes optional.Bool
	OnAccessPoliciesScopeIncludeExtensions optional.String
	OnAccessPoliciesScopeMaxFileSize optional.Int32
	OnAccessPoliciesScopeExcludeExtensions optional.String
	OnAccessPoliciesScopeOnlyExecuteAccess optional.Bool
	OnAccessPoliciesScopeScanWithoutExtension optional.Bool
	OnAccessPoliciesScopeExcludePaths optional.String
	OnAccessPoliciesEnabled optional.Bool
	OnAccessPoliciesName optional.String
	OnAccessPoliciesMandatory optional.Bool
	Enabled optional.Bool
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NASApiService) VscanCollectionGet(ctx context.Context, localVarOptionals *VscanCollectionGetOpts) (VscanResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue VscanResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/vscan"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.OnDemandPoliciesScopeScanWithoutExtension.IsSet() {
		localVarQueryParams.Add("on_demand_policies.scope.scan_without_extension", parameterToString(localVarOptionals.OnDemandPoliciesScopeScanWithoutExtension.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OnDemandPoliciesScopeExcludePaths.IsSet() {
		localVarQueryParams.Add("on_demand_policies.scope.exclude_paths", parameterToString(localVarOptionals.OnDemandPoliciesScopeExcludePaths.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OnDemandPoliciesScopeExcludeExtensions.IsSet() {
		localVarQueryParams.Add("on_demand_policies.scope.exclude_extensions", parameterToString(localVarOptionals.OnDemandPoliciesScopeExcludeExtensions.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OnDemandPoliciesScopeIncludeExtensions.IsSet() {
		localVarQueryParams.Add("on_demand_policies.scope.include_extensions", parameterToString(localVarOptionals.OnDemandPoliciesScopeIncludeExtensions.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OnDemandPoliciesScopeMaxFileSize.IsSet() {
		localVarQueryParams.Add("on_demand_policies.scope.max_file_size", parameterToString(localVarOptionals.OnDemandPoliciesScopeMaxFileSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OnDemandPoliciesName.IsSet() {
		localVarQueryParams.Add("on_demand_policies.name", parameterToString(localVarOptionals.OnDemandPoliciesName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OnDemandPoliciesScanPaths.IsSet() {
		localVarQueryParams.Add("on_demand_policies.scan_paths", parameterToString(localVarOptionals.OnDemandPoliciesScanPaths.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OnDemandPoliciesLogPath.IsSet() {
		localVarQueryParams.Add("on_demand_policies.log_path", parameterToString(localVarOptionals.OnDemandPoliciesLogPath.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OnDemandPoliciesScheduleUuid.IsSet() {
		localVarQueryParams.Add("on_demand_policies.schedule.uuid", parameterToString(localVarOptionals.OnDemandPoliciesScheduleUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OnDemandPoliciesScheduleName.IsSet() {
		localVarQueryParams.Add("on_demand_policies.schedule.name", parameterToString(localVarOptionals.OnDemandPoliciesScheduleName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScannerPoolsPrivilegedUsers.IsSet() {
		localVarQueryParams.Add("scanner_pools.privileged_users", parameterToString(localVarOptionals.ScannerPoolsPrivilegedUsers.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScannerPoolsName.IsSet() {
		localVarQueryParams.Add("scanner_pools.name", parameterToString(localVarOptionals.ScannerPoolsName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScannerPoolsClusterUuid.IsSet() {
		localVarQueryParams.Add("scanner_pools.cluster.uuid", parameterToString(localVarOptionals.ScannerPoolsClusterUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScannerPoolsClusterName.IsSet() {
		localVarQueryParams.Add("scanner_pools.cluster.name", parameterToString(localVarOptionals.ScannerPoolsClusterName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScannerPoolsServers.IsSet() {
		localVarQueryParams.Add("scanner_pools.servers", parameterToString(localVarOptionals.ScannerPoolsServers.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScannerPoolsRole.IsSet() {
		localVarQueryParams.Add("scanner_pools.role", parameterToString(localVarOptionals.ScannerPoolsRole.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OnAccessPoliciesScopeScanReadonlyVolumes.IsSet() {
		localVarQueryParams.Add("on_access_policies.scope.scan_readonly_volumes", parameterToString(localVarOptionals.OnAccessPoliciesScopeScanReadonlyVolumes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OnAccessPoliciesScopeIncludeExtensions.IsSet() {
		localVarQueryParams.Add("on_access_policies.scope.include_extensions", parameterToString(localVarOptionals.OnAccessPoliciesScopeIncludeExtensions.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OnAccessPoliciesScopeMaxFileSize.IsSet() {
		localVarQueryParams.Add("on_access_policies.scope.max_file_size", parameterToString(localVarOptionals.OnAccessPoliciesScopeMaxFileSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OnAccessPoliciesScopeExcludeExtensions.IsSet() {
		localVarQueryParams.Add("on_access_policies.scope.exclude_extensions", parameterToString(localVarOptionals.OnAccessPoliciesScopeExcludeExtensions.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OnAccessPoliciesScopeOnlyExecuteAccess.IsSet() {
		localVarQueryParams.Add("on_access_policies.scope.only_execute_access", parameterToString(localVarOptionals.OnAccessPoliciesScopeOnlyExecuteAccess.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OnAccessPoliciesScopeScanWithoutExtension.IsSet() {
		localVarQueryParams.Add("on_access_policies.scope.scan_without_extension", parameterToString(localVarOptionals.OnAccessPoliciesScopeScanWithoutExtension.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OnAccessPoliciesScopeExcludePaths.IsSet() {
		localVarQueryParams.Add("on_access_policies.scope.exclude_paths", parameterToString(localVarOptionals.OnAccessPoliciesScopeExcludePaths.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OnAccessPoliciesEnabled.IsSet() {
		localVarQueryParams.Add("on_access_policies.enabled", parameterToString(localVarOptionals.OnAccessPoliciesEnabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OnAccessPoliciesName.IsSet() {
		localVarQueryParams.Add("on_access_policies.name", parameterToString(localVarOptionals.OnAccessPoliciesName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OnAccessPoliciesMandatory.IsSet() {
		localVarQueryParams.Add("on_access_policies.mandatory", parameterToString(localVarOptionals.OnAccessPoliciesMandatory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarQueryParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v VscanResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Deletes a Vscan configuration.&lt;br/&gt; Important notes: * The Vscan DELETE endpoint deletes all of the Vscan configuration of an SVM. It first disables the Vscan and then deletes all of the SVM scanner-pools, On-Access policies, and On-Demand policies. * Any active Vscan On-Access policy must first be disabled on an SVM before performing the Vscan delete operation on that SVM. ### Related ONTAP commands * &#x60;vserver vscan scanner-pool delete&#x60; * &#x60;vserver vscan on-access-policy delete&#x60; * &#x60;vserver vscan on-demand-policy delete&#x60; ### Learn more * [&#x60;DOC /protocols/vscan&#x60;](#docs-NAS-protocols_vscan) * [&#x60;DOC /protocols/vscan/{svm.uuid}/scanner-pools&#x60;](#docs-NAS-protocols_vscan_{svm.uuid}_scanner-pools) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.


*/
func (a *NASApiService) VscanConfigDelete(ctx context.Context, svmUuid string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/vscan/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Creates a Vscan configuration, which includes a list of scanner-pools, Vscan On-Access policies and Vscan On-Demand policies. Defines whether the Vscan configuration youre creating is enabled or disabled for a specified SVM.&lt;br/&gt; Important notes: * There can be only one Vscan configuration enabled for an SVM at any time. * There needs to be at least one active scanner-pool and one enabled On-Access policy for Vscan to be enabled successfully. * By default, a Vscan is enabled when its created. * By default, the Vscan On-Access policies created from this endpoint are in the disabled state. You can use the On-Access policy PATCH endpoint to enable a particular On-Access policy. In ONTAP 9.6, only one Vscan On-Access policy can be enabled and only one Vscan On-Demand policy can be scheduled on an SVM. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the Vscan configuration. ### Recommended optional properties * &#x60;scanner_pools&#x60; - There must be at least one active scanner-pool for Vscan configuration. Created either through Vscan POST operation or scanner-pools POST operation. ### Default property values If not specified in POST, the following default property value is assigned: * &#x60;enabled&#x60; - _true_ ### Related ONTAP commands * &#x60;vserver vscan enable&#x60; * &#x60;vserver vscan scanner-pool create&#x60; * &#x60;vserver vscan scanner-pool apply-policy&#x60; * &#x60;vserver vscan scanner-pool servers add&#x60; * &#x60;vserver vscan scanner-pool privileged-users add&#x60; * &#x60;vserver vscan on-access-policy create&#x60; * &#x60;vserver vscan on-access-policy file-ext-to-exclude add&#x60; * &#x60;vserver vscan on-access-policy file-ext-to-include add&#x60; * &#x60;vserver vscan on-access-policy paths-to-exclude add&#x60; * &#x60;vserver vscan on-demand-task create&#x60; ### Learn more * [&#x60;DOC /protocols/vscan&#x60;](#docs-NAS-protocols_vscan) * [&#x60;DOC /protocols/vscan/{svm.uuid}/scanner-pools&#x60;](#docs-NAS-protocols_vscan_{svm.uuid}_scanner-pools) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *VscanCreateOpts - Optional Parameters:
     * @param "Info" (optional.Interface of Vscan) -  Info specification

@return VscanResponse
*/

type VscanCreateOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) VscanCreate(ctx context.Context, localVarOptionals *VscanCreateOpts) (VscanResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue VscanResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/vscan"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(Vscan)
		if !localVarOptionalInfook {
				return localVarReturnValue, nil, reportError("info should be Vscan")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v VscanResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves the Vscan configuration for a specified SVM. This includes scanner-pools, On-Access policies, On-Demand policies, and information about whether a Vscan is enabled or disabled on an SVM.&lt;br/&gt; Important note: * There can be only one Vscan configuration enabled for an SVM at any time. ### Related ONTAP commands * &#x60;vserver vscan show&#x60; * &#x60;vserver vscan scanner-pool show&#x60; * &#x60;vserver vscan scanner-pool servers show&#x60; * &#x60;vserver vscan scanner-pool privileged-users show&#x60; * &#x60;vserver vscan scanner-pool show-active&#x60; * &#x60;vserver vscan on-access-policy show&#x60; * &#x60;vserver vscan on-access-policy file-ext-to-exclude show&#x60; * &#x60;vserver vscan on-access-policy file-ext-to-include show&#x60; * &#x60;vserver vscan on-access-policy paths-to-exclude show&#x60; * &#x60;vserver vscan on-demand-task show&#x60; ### Learn more * [&#x60;DOC /protocols/vscan&#x60;](#docs-NAS-protocols_vscan) * [&#x60;DOC /protocols/vscan/{svm.uuid}/scanner-pools&#x60;](#docs-NAS-protocols_vscan_{svm.uuid}_scanner-pools) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param optional nil or *VscanGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return Vscan
*/

type VscanGetOpts struct { 
	Fields optional.Interface
}

func (a *NASApiService) VscanGet(ctx context.Context, svmUuid string, localVarOptionals *VscanGetOpts) (Vscan, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Vscan
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/vscan/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Vscan
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Updates the Vscan configuration of an SVM. Allows you to either enable or disable a Vscan, and allows you to clear the Vscan cache that stores the past scanning data for an SVM.&lt;br/&gt; Important note: * The Vscan PATCH endpoint does not allow you to modify scanner-pools, On-Demand policies or On-Access policies. Those modifications can only be done through their respective endpoints. ### Related ONTAP commands * &#x60;vserver vscan enable&#x60; * &#x60;vserver vscan disable&#x60; * &#x60;vserver vscan reset&#x60; ### Learn more * [&#x60;DOC /protocols/vscan&#x60;](#docs-NAS-protocols_vscan) * [&#x60;DOC /protocols/vscan/{svm.uuid}/scanner-pools&#x60;](#docs-NAS-protocols_vscan_{svm.uuid}_scanner-pools) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param optional nil or *VscanModifyOpts - Optional Parameters:
     * @param "Info" (optional.Interface of Vscan) -  Info specification


*/

type VscanModifyOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) VscanModify(ctx context.Context, svmUuid string, localVarOptionals *VscanModifyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/vscan/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(Vscan)
		if !localVarOptionalInfook {
				return nil, reportError("info should be Vscan")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Creates a Vscan On-Access policy. Created only on a data SVM. &lt;/b&gt;Important notes: * The policy needs to be enabled on an SVM before its files can be scanned. * Only one On-Access policy can be enabled on an SVM at a time. By default, the policy is enabled on creation. * If the Vscan On-Access policy has been created successfully on an SVM but cannot be enabled due to an error, the Vscan On-Access policy configurations are saved. The Vscan On-Access policy is then enabled using the PATCH operation. ### Required properties * &#x60;svm.uuid&#x60; - Existing SVM in which to create the Vscan On-Access policy. * &#x60;name&#x60; - Name of the Vscan On-Access policy. Maximum length is 256 characters. ### Default property values If not specified in POST, the following default property values are assigned: * &#x60;enabled&#x60; - _true_ * &#x60;mandatory&#x60; - _true_ * &#x60;include_extensions&#x60; - _*_ * &#x60;max_file_size&#x60; - _2147483648_ * &#x60;only_execute_access&#x60; - _false_ * &#x60;scan_readonly_volumes&#x60; - _false_ * &#x60;scan_without_extension&#x60; - _true_ ### Related ONTAP commands * &#x60;vserver vscan on-access-policy create&#x60; * &#x60;vserver vscan on-access-policy enable&#x60; * &#x60;vserver vscan on-access-policy disable&#x60; * &#x60;vserver vscan on-access-policy file-ext-to-include add&#x60; * &#x60;vserver vscan on-access-policy file-ext-to-exclude add&#x60; * &#x60;vserver vscan on-access-policy paths-to-exclude add&#x60; ### Learn more * [&#x60;DOC /protocols/vscan/{svm.uuid}/on-access-policies&#x60;](#docs-NAS-protocols_vscan_{svm.uuid}_on-access-policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param optional nil or *VscanOnAccessCreateOpts - Optional Parameters:
     * @param "Info" (optional.Interface of VscanOnAccess) -  Info specification

@return VscanOnAccessResponse
*/

type VscanOnAccessCreateOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) VscanOnAccessCreate(ctx context.Context, svmUuid string, localVarOptionals *VscanOnAccessCreateOpts) (VscanOnAccessResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue VscanOnAccessResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/vscan/{svm.uuid}/on-access-policies"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(VscanOnAccess)
		if !localVarOptionalInfook {
				return localVarReturnValue, nil, reportError("info should be VscanOnAccess")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v VscanOnAccessResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Deletes the anti-virus On-Access policy configuration. ### Related ONTAP commands * &#x60;vserver vscan on-access-policy delete&#x60; ### Learn more * [&#x60;DOC /protocols/vscan/{svm.uuid}/on-access-policies&#x60;](#docs-NAS-protocols_vscan_{svm.uuid}_on-access-policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param name


*/
func (a *NASApiService) VscanOnAccessDelete(ctx context.Context, svmUuid string, name string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/vscan/{svm.uuid}/on-access-policies/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves the Vscan On-Access policy configuration of an SVM. ### Related ONTAP commands * &#x60;vserver vscan on-access-policy show&#x60; * &#x60;vserver vscan on-access-policy file-ext-to-include show&#x60; * &#x60;vserver vscan on-access-policy file-ext-to-exclude show&#x60; * &#x60;vserver vscan on-access-policy paths-to-exclude show&#x60; ### Learn more * [&#x60;DOC /protocols/vscan/{svm.uuid}/on-access-policies&#x60;](#docs-NAS-protocols_vscan_{svm.uuid}_on-access-policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param name
 * @param optional nil or *VscanOnAccessGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return VscanOnAccess
*/

type VscanOnAccessGetOpts struct { 
	Fields optional.Interface
}

func (a *NASApiService) VscanOnAccessGet(ctx context.Context, svmUuid string, name string, localVarOptionals *VscanOnAccessGetOpts) (VscanOnAccess, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue VscanOnAccess
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/vscan/{svm.uuid}/on-access-policies/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v VscanOnAccess
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Updates the Vscan On-Access policy configuration and/or enables/disables the Vscan On-Access policy of an SVM. Configurations for an On-Access policy associated with an administrative SVM cannot be modified, although the policy associated with an administrative SVM can be enabled or disabled. ### Related ONTAP commands * &#x60;vserver vscan on-access-policy modify&#x60; * &#x60;vserver vscan on-access-policy enable&#x60; * &#x60;vserver vscan on-access-policy disable&#x60; * &#x60;vserver vscan on-access-policy file-ext-to-include add&#x60; * &#x60;vserver vscan on-access-policy file-ext-to-exclude add&#x60; * &#x60;vserver vscan on-access-policy paths-to-exclude add&#x60; * &#x60;vserver vscan on-access-policy file-ext-to-include remove&#x60; * &#x60;vserver vscan on-access-policy file-ext-to-exclude remove&#x60; * &#x60;vserver vscan on-access-policy paths-to-exclude remove&#x60; ### Learn more * [&#x60;DOC /protocols/vscan/{svm.uuid}/on-access-policies&#x60;](#docs-NAS-protocols_vscan_{svm.uuid}_on-access-policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param name
 * @param optional nil or *VscanOnAccessModifyOpts - Optional Parameters:
     * @param "Info" (optional.Interface of VscanOnAccess) -  Info specification


*/

type VscanOnAccessModifyOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) VscanOnAccessModify(ctx context.Context, svmUuid string, name string, localVarOptionals *VscanOnAccessModifyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/vscan/{svm.uuid}/on-access-policies/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(VscanOnAccess)
		if !localVarOptionalInfook {
				return nil, reportError("info should be VscanOnAccess")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves the Vscan On-Access policy. ### Related ONTAP commands * &#x60;vserver vscan on-access-policy show&#x60; * &#x60;vserver vscan on-access-policy file-ext-to-include show&#x60; * &#x60;vserver vscan on-access-policy file-ext-to-exclude show&#x60; * &#x60;vserver vscan on-access-policy paths-to-exclude show&#x60; ### Learn more * [&#x60;DOC /protocols/vscan/{svm.uuid}/on-access-policies&#x60;](#docs-NAS-protocols_vscan_{svm.uuid}_on-access-policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param optional nil or *VscanOnAccessPolicyCollectionGetOpts - Optional Parameters:
     * @param "ScopeScanReadonlyVolumes" (optional.Bool) -  Filter by scope.scan_readonly_volumes
     * @param "ScopeIncludeExtensions" (optional.String) -  Filter by scope.include_extensions
     * @param "ScopeMaxFileSize" (optional.Int32) -  Filter by scope.max_file_size
     * @param "ScopeExcludeExtensions" (optional.String) -  Filter by scope.exclude_extensions
     * @param "ScopeOnlyExecuteAccess" (optional.Bool) -  Filter by scope.only_execute_access
     * @param "ScopeScanWithoutExtension" (optional.Bool) -  Filter by scope.scan_without_extension
     * @param "ScopeExcludePaths" (optional.String) -  Filter by scope.exclude_paths
     * @param "Enabled" (optional.Bool) -  Filter by enabled
     * @param "Name" (optional.String) -  Filter by name
     * @param "Mandatory" (optional.Bool) -  Filter by mandatory
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return VscanOnAccessResponse
*/

type VscanOnAccessPolicyCollectionGetOpts struct { 
	ScopeScanReadonlyVolumes optional.Bool
	ScopeIncludeExtensions optional.String
	ScopeMaxFileSize optional.Int32
	ScopeExcludeExtensions optional.String
	ScopeOnlyExecuteAccess optional.Bool
	ScopeScanWithoutExtension optional.Bool
	ScopeExcludePaths optional.String
	Enabled optional.Bool
	Name optional.String
	Mandatory optional.Bool
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NASApiService) VscanOnAccessPolicyCollectionGet(ctx context.Context, svmUuid string, localVarOptionals *VscanOnAccessPolicyCollectionGetOpts) (VscanOnAccessResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue VscanOnAccessResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/vscan/{svm.uuid}/on-access-policies"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ScopeScanReadonlyVolumes.IsSet() {
		localVarQueryParams.Add("scope.scan_readonly_volumes", parameterToString(localVarOptionals.ScopeScanReadonlyVolumes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScopeIncludeExtensions.IsSet() {
		localVarQueryParams.Add("scope.include_extensions", parameterToString(localVarOptionals.ScopeIncludeExtensions.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScopeMaxFileSize.IsSet() {
		localVarQueryParams.Add("scope.max_file_size", parameterToString(localVarOptionals.ScopeMaxFileSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScopeExcludeExtensions.IsSet() {
		localVarQueryParams.Add("scope.exclude_extensions", parameterToString(localVarOptionals.ScopeExcludeExtensions.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScopeOnlyExecuteAccess.IsSet() {
		localVarQueryParams.Add("scope.only_execute_access", parameterToString(localVarOptionals.ScopeOnlyExecuteAccess.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScopeScanWithoutExtension.IsSet() {
		localVarQueryParams.Add("scope.scan_without_extension", parameterToString(localVarOptionals.ScopeScanWithoutExtension.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScopeExcludePaths.IsSet() {
		localVarQueryParams.Add("scope.exclude_paths", parameterToString(localVarOptionals.ScopeExcludePaths.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Enabled.IsSet() {
		localVarQueryParams.Add("enabled", parameterToString(localVarOptionals.Enabled.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Mandatory.IsSet() {
		localVarQueryParams.Add("mandatory", parameterToString(localVarOptionals.Mandatory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v VscanOnAccessResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Creates a Vscan On-Demand policy. Created only on a data SVM. &lt;/br&gt; Important notes:   * Only one policy can be scheduled at a time on an SVM. Use schedule name or schedule uuid to schedule an On-Demand policy.   * Scanning must be enabled on the SVM before the policy is scheduled to run.   * The exclude_extensions setting overrides the include_extensions setting. Set scan_without_extension to true to scan files without extensions. ### Required properties * &#x60;svm.uuid&#x60; - Existing SVM in which to create the Vscan On-Demand policy. * &#x60;name&#x60; - Name of the Vscan On-Demand policy. Maximum length is 256 characters. * &#x60;log_path&#x60; - Path from the Vserver root where the On-Demand policy report is created. * &#x60;scan_paths&#x60; - List of paths that need to be scanned. ### Recommended optional properties * &#x60;schedule&#x60; - Scan schedule. It is recommended to set the schedule property, as it dictates when to scan for viruses. ### Default property values If not specified in POST, the following default property values are assigned: * &#x60;include_extensions&#x60; - _*_ * &#x60;max_file_size&#x60; - _10737418240_ * &#x60;scan_without_extension&#x60; - _true_ ### Related ONTAP commands * &#x60;vserver vscan on-demand-task create&#x60; * &#x60;vserver vscan on-demand-task schedule&#x60; ### Learn more * [&#x60;DOC /protocols/vscan/{svm.uuid}/on-demand-policies&#x60;](#docs-NAS-protocols_vscan_{svm.uuid}_on-demand-policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param optional nil or *VscanOnDemandCreateOpts - Optional Parameters:
     * @param "Info" (optional.Interface of VscanOnDemand) -  Info specification

@return VscanOnDemandResponse
*/

type VscanOnDemandCreateOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) VscanOnDemandCreate(ctx context.Context, svmUuid string, localVarOptionals *VscanOnDemandCreateOpts) (VscanOnDemandResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue VscanOnDemandResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/vscan/{svm.uuid}/on-demand-policies"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(VscanOnDemand)
		if !localVarOptionalInfook {
				return localVarReturnValue, nil, reportError("info should be VscanOnDemand")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v VscanOnDemandResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Deletes the Vscan On-Demand configuration. ### Related ONTAP commands * &#x60;vserver vscan on-demand-task delete&#x60; ### Learn more * [&#x60;DOC /protocols/vscan/{svm.uuid}/on-demand-policies&#x60;](#docs-NAS-protocols_vscan_{svm.uuid}_on-demand-policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param name


*/
func (a *NASApiService) VscanOnDemandDelete(ctx context.Context, svmUuid string, name string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/vscan/{svm.uuid}/on-demand-policies/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves the Vscan On-Demand configuration of an SVM. ### Related ONTAP commands * &#x60;vserver vscan on-demand-task show&#x60; ### Learn more * [&#x60;DOC /protocols/vscan/{svm.uuid}/on-demand-policies&#x60;](#docs-NAS-protocols_vscan_{svm.uuid}_on-demand-policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param name
 * @param optional nil or *VscanOnDemandGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return VscanOnDemand
*/

type VscanOnDemandGetOpts struct { 
	Fields optional.Interface
}

func (a *NASApiService) VscanOnDemandGet(ctx context.Context, svmUuid string, name string, localVarOptionals *VscanOnDemandGetOpts) (VscanOnDemand, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue VscanOnDemand
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/vscan/{svm.uuid}/on-demand-policies/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v VscanOnDemand
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Updates the Vscan On-Demand policy configuration of an SVM. Use schedule name or schedule UUID to schedule an On-Demand scan. ### Related ONTAP commands * &#x60;vserver vscan on-demand-task modify&#x60; * &#x60;vserver vscan on-demand-task schedule&#x60; * &#x60;vserver vscan on-demand-task unschedule&#x60; ### Learn more * [&#x60;DOC /protocols/vscan/{svm.uuid}/on-demand-policies&#x60;](#docs-NAS-protocols_vscan_{svm.uuid}_on-demand-policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param name
 * @param optional nil or *VscanOnDemandModifyOpts - Optional Parameters:
     * @param "Info" (optional.Interface of VscanOnDemand) -  Info specification


*/

type VscanOnDemandModifyOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) VscanOnDemandModify(ctx context.Context, svmUuid string, name string, localVarOptionals *VscanOnDemandModifyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/vscan/{svm.uuid}/on-demand-policies/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(VscanOnDemand)
		if !localVarOptionalInfook {
				return nil, reportError("info should be VscanOnDemand")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves the Vscan On-Demand policy. ### Related ONTAP commands * &#x60;vserver vscan on-demand-task show&#x60; ### Learn more * [&#x60;DOC /protocols/vscan/{svm.uuid}/on-demand-policies&#x60;](#docs-NAS-protocols_vscan_{svm.uuid}_on-demand-policies) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param optional nil or *VscanOnDemandPolicyCollectionGetOpts - Optional Parameters:
     * @param "ScopeScanWithoutExtension" (optional.Bool) -  Filter by scope.scan_without_extension
     * @param "ScopeExcludePaths" (optional.String) -  Filter by scope.exclude_paths
     * @param "ScopeExcludeExtensions" (optional.String) -  Filter by scope.exclude_extensions
     * @param "ScopeIncludeExtensions" (optional.String) -  Filter by scope.include_extensions
     * @param "ScopeMaxFileSize" (optional.Int32) -  Filter by scope.max_file_size
     * @param "Name" (optional.String) -  Filter by name
     * @param "ScanPaths" (optional.String) -  Filter by scan_paths
     * @param "LogPath" (optional.String) -  Filter by log_path
     * @param "ScheduleUuid" (optional.String) -  Filter by schedule.uuid
     * @param "ScheduleName" (optional.String) -  Filter by schedule.name
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return VscanOnDemandResponse
*/

type VscanOnDemandPolicyCollectionGetOpts struct { 
	ScopeScanWithoutExtension optional.Bool
	ScopeExcludePaths optional.String
	ScopeExcludeExtensions optional.String
	ScopeIncludeExtensions optional.String
	ScopeMaxFileSize optional.Int32
	Name optional.String
	ScanPaths optional.String
	LogPath optional.String
	ScheduleUuid optional.String
	ScheduleName optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NASApiService) VscanOnDemandPolicyCollectionGet(ctx context.Context, svmUuid string, localVarOptionals *VscanOnDemandPolicyCollectionGetOpts) (VscanOnDemandResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue VscanOnDemandResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/vscan/{svm.uuid}/on-demand-policies"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ScopeScanWithoutExtension.IsSet() {
		localVarQueryParams.Add("scope.scan_without_extension", parameterToString(localVarOptionals.ScopeScanWithoutExtension.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScopeExcludePaths.IsSet() {
		localVarQueryParams.Add("scope.exclude_paths", parameterToString(localVarOptionals.ScopeExcludePaths.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScopeExcludeExtensions.IsSet() {
		localVarQueryParams.Add("scope.exclude_extensions", parameterToString(localVarOptionals.ScopeExcludeExtensions.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScopeIncludeExtensions.IsSet() {
		localVarQueryParams.Add("scope.include_extensions", parameterToString(localVarOptionals.ScopeIncludeExtensions.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScopeMaxFileSize.IsSet() {
		localVarQueryParams.Add("scope.max_file_size", parameterToString(localVarOptionals.ScopeMaxFileSize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScanPaths.IsSet() {
		localVarQueryParams.Add("scan_paths", parameterToString(localVarOptionals.ScanPaths.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LogPath.IsSet() {
		localVarQueryParams.Add("log_path", parameterToString(localVarOptionals.LogPath.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScheduleUuid.IsSet() {
		localVarQueryParams.Add("schedule.uuid", parameterToString(localVarOptionals.ScheduleUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScheduleName.IsSet() {
		localVarQueryParams.Add("schedule.name", parameterToString(localVarOptionals.ScheduleName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v VscanOnDemandResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves the Vscan scanner-pool configuration of an SVM. ### Related ONTAP commands * &#x60;vserver vscan scanner-pool show&#x60; * &#x60;vserver vscan scanner-pool privileged-users show&#x60; * &#x60;vserver vscan scanner-pool servers show&#x60; * &#x60;vserver vscan scanner-pool show-active&#x60; ### Learn more * [&#x60;DOC /protocols/vscan/{svm.uuid}/scanner-pools&#x60;](#docs-NAS-protocols_vscan_{svm.uuid}_scanner-pools) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param optional nil or *VscanScannerCollectionGetOpts - Optional Parameters:
     * @param "PrivilegedUsers" (optional.String) -  Filter by privileged_users
     * @param "Name" (optional.String) -  Filter by name
     * @param "ClusterUuid" (optional.String) -  Filter by cluster.uuid
     * @param "ClusterName" (optional.String) -  Filter by cluster.name
     * @param "Servers" (optional.String) -  Filter by servers
     * @param "Role" (optional.String) -  Filter by role
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return VscanScannerPoolResponse
*/

type VscanScannerCollectionGetOpts struct { 
	PrivilegedUsers optional.String
	Name optional.String
	ClusterUuid optional.String
	ClusterName optional.String
	Servers optional.String
	Role optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NASApiService) VscanScannerCollectionGet(ctx context.Context, svmUuid string, localVarOptionals *VscanScannerCollectionGetOpts) (VscanScannerPoolResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue VscanScannerPoolResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/vscan/{svm.uuid}/scanner-pools"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.PrivilegedUsers.IsSet() {
		localVarQueryParams.Add("privileged_users", parameterToString(localVarOptionals.PrivilegedUsers.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClusterUuid.IsSet() {
		localVarQueryParams.Add("cluster.uuid", parameterToString(localVarOptionals.ClusterUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClusterName.IsSet() {
		localVarQueryParams.Add("cluster.name", parameterToString(localVarOptionals.ClusterName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Servers.IsSet() {
		localVarQueryParams.Add("servers", parameterToString(localVarOptionals.Servers.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Role.IsSet() {
		localVarQueryParams.Add("role", parameterToString(localVarOptionals.Role.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v VscanScannerPoolResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Creates a Vscan scanner-pool configuration for a specified SVM. A scanner-pool can be created with all fields specified or only mandatory fields specified.&lt;br/&gt; Important notes: * A scanner-pool must have servers and privileged users specified. * If the role or cluster is not specified, the scanner-pool is created on the local cluster with the role set as primary. *&#x60;Only one of the fields cluster-uuid or cluster-name is required. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the Vscan configuration. * &#x60;name&#x60; - Scanner-pool name. * &#x60;privileged_users&#x60; - List of privileged users. * &#x60;servers&#x60; - List of server IP addresses or FQDNs. ### Recommended optional properties * &#x60;role&#x60; - Setting a role for a scanner-pool is recommended. * &#x60;cluster&#x60; - Passing the cluster name or UUID (or both) in a multi-cluster environment is recommended. ### Default property values If not specified in POST, the following default property values are assigned: * &#x60;role&#x60; - _primary_ * &#x60;cluster.name&#x60; - Local cluster name. * &#x60;cluster.uuid&#x60; - Local cluster UUID. ### Related ONTAP commands * &#x60;vserver vscan scanner-pool create&#x60; * &#x60;vserver vscan scanner-pool apply-policy&#x60; * &#x60;vserver vscan scanner-pool privileged-users add&#x60; * &#x60;vserver vscan scanner-pool servers add&#x60; ### Learn more * [&#x60;DOC /protocols/vscan/{svm.uuid}/scanner-pools&#x60;](#docs-NAS-protocols_vscan_{svm.uuid}_scanner-pools) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param optional nil or *VscanScannerCreateOpts - Optional Parameters:
     * @param "Info" (optional.Interface of VscanScannerPool) -  Info specification

@return VscanScannerPoolResponse
*/

type VscanScannerCreateOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) VscanScannerCreate(ctx context.Context, svmUuid string, localVarOptionals *VscanScannerCreateOpts) (VscanScannerPoolResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue VscanScannerPoolResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/vscan/{svm.uuid}/scanner-pools"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(VscanScannerPool)
		if !localVarOptionalInfook {
				return localVarReturnValue, nil, reportError("info should be VscanScannerPool")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 201 {
			var v VscanScannerPoolResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Deletes a Vscan scanner-pool configuration.&lt;br/&gt; Important notes: * The Vscan scanner-pool DELETE endpoint deletes all of the Vscan scanner-pools for a specified SVM. * If a Vscan is enabled, it requires at least one scanner-pool to be in the active state. Therefore, Vscan must be disabled on the specified SVM so that all of the scanner-pools configured on that SVM can be deleted. ### Related ONTAP commands * &#x60;vserver vscan scanner-pool delete&#x60; ### Learn more * [&#x60;DOC /protocols/vscan/{svm.uuid}/scanner-pools&#x60;](#docs-NAS-protocols_vscan_{svm.uuid}_scanner-pools) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param name


*/
func (a *NASApiService) VscanScannerDelete(ctx context.Context, svmUuid string, name string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/vscan/{svm.uuid}/scanner-pools/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves the configuration of a specified scanner-pool of an SVM. ### Related ONTAP commands * &#x60;vserver vscan scanner-pool show&#x60; * &#x60;vserver vscan scanner-pool privileged-users show&#x60; * &#x60;vserver vscan scanner-pool servers show&#x60; * &#x60;vserver vscan scanner-pool show-active&#x60; ### Learn more * [&#x60;DOC /protocols/vscan/{svm.uuid}/scanner-pools&#x60;](#docs-NAS-protocols_vscan_{svm.uuid}_scanner-pools) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param name
 * @param optional nil or *VscanScannerGetOpts - Optional Parameters:
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.

@return VscanScannerPool
*/

type VscanScannerGetOpts struct { 
	Fields optional.Interface
}

func (a *NASApiService) VscanScannerGet(ctx context.Context, svmUuid string, name string, localVarOptionals *VscanScannerGetOpts) (VscanScannerPool, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue VscanScannerPool
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/vscan/{svm.uuid}/scanner-pools/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v VscanScannerPool
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
NASApiService
Updates the Vscan scanner-pool configuration of an SVM.&lt;br/&gt; Important notes: * Along with servers and privileged-users, the role of a scanner-pool can also be updated with the cluster on which a scanner-pool is allowed. * If role is specified and cluster isn&#39;t, then role is applied to the local cluster. ### Related ONTAP commands * &#x60;vserver vscan scanner-pool modify&#x60; * &#x60;vserver vscan scanner-pool apply-policy&#x60; * &#x60;vserver vscan scanner-pool privileged-users add&#x60; * &#x60;vserver vscan scanner-pool privileged-users remove&#x60; * &#x60;vserver vscan scanner-pool servers remove&#x60; * &#x60;vserver vscan scanner-pool servers add&#x60; ### Learn more * [&#x60;DOC /protocols/vscan/{svm.uuid}/scanner-pools&#x60;](#docs-NAS-protocols_vscan_{svm.uuid}_scanner-pools) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param name
 * @param optional nil or *VscanScannerModifyOpts - Optional Parameters:
     * @param "Info" (optional.Interface of VscanScannerPool) -  Info specification


*/

type VscanScannerModifyOpts struct { 
	Info optional.Interface
}

func (a *NASApiService) VscanScannerModify(ctx context.Context, svmUuid string, name string, localVarOptionals *VscanScannerModifyOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Patch")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/vscan/{svm.uuid}/scanner-pools/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", fmt.Sprintf("%v", svmUuid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", fmt.Sprintf("%v", name), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(VscanScannerPool)
		if !localVarOptionalInfook {
				return nil, reportError("info should be VscanScannerPool")
		}
		localVarPostBody = &localVarOptionalInfo
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NASApiService
Retrieves a Vscan server status. ### Related ONTAP commands * &#x60;vserver vscan connection-status show-all&#x60; ### Learn more * [&#x60;DOC /protocols/vscan/server-status&#x60;](#docs-NAS-protocols_vscan_server-status) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *VscanServerStatusGetOpts - Optional Parameters:
     * @param "State" (optional.String) -  Filter by state
     * @param "Ip" (optional.String) -  Filter by ip
     * @param "Version" (optional.String) -  Filter by version
     * @param "DisconnectedReason" (optional.String) -  Filter by disconnected_reason
     * @param "Type_" (optional.String) -  Filter by type
     * @param "NodeUuid" (optional.String) -  Filter by node.uuid
     * @param "NodeName" (optional.String) -  Filter by node.name
     * @param "Vendor" (optional.String) -  Filter by vendor
     * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
     * @param "SvmName" (optional.String) -  Filter by svm.name
     * @param "UpdateTime" (optional.String) -  Filter by update_time
     * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
     * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
     * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
     * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
     * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is &#39;asc&#39; for ascending.

@return VscanServerStatusResponse
*/

type VscanServerStatusGetOpts struct { 
	State optional.String
	Ip optional.String
	Version optional.String
	DisconnectedReason optional.String
	Type_ optional.String
	NodeUuid optional.String
	NodeName optional.String
	Vendor optional.String
	SvmUuid optional.String
	SvmName optional.String
	UpdateTime optional.String
	Fields optional.Interface
	MaxRecords optional.Int32
	ReturnRecords optional.Bool
	ReturnTimeout optional.Int32
	OrderBy optional.Interface
}

func (a *NASApiService) VscanServerStatusGet(ctx context.Context, localVarOptionals *VscanServerStatusGetOpts) (VscanServerStatusResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue VscanServerStatusResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/protocols/vscan/server-status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ip.IsSet() {
		localVarQueryParams.Add("ip", parameterToString(localVarOptionals.Ip.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Version.IsSet() {
		localVarQueryParams.Add("version", parameterToString(localVarOptionals.Version.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DisconnectedReason.IsSet() {
		localVarQueryParams.Add("disconnected_reason", parameterToString(localVarOptionals.DisconnectedReason.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NodeUuid.IsSet() {
		localVarQueryParams.Add("node.uuid", parameterToString(localVarOptionals.NodeUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NodeName.IsSet() {
		localVarQueryParams.Add("node.name", parameterToString(localVarOptionals.NodeName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Vendor.IsSet() {
		localVarQueryParams.Add("vendor", parameterToString(localVarOptionals.Vendor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UpdateTime.IsSet() {
		localVarQueryParams.Add("update_time", parameterToString(localVarOptionals.UpdateTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v VscanServerStatusResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 0 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
