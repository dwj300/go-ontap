/*
 * ONTAP REST API
 *
 * ONTAP 9.6 adds support for an expansive RESTful API. The documentation below provides information about the types of API calls available to you, as well as details about using each API endpoint. You can learn more about the ONTAP REST API and ONTAP in the ONTAP 9 Documentation Center:  http://docs.netapp.com/ontap-9/topic/com.netapp.doc.dot-rest-api/home.html. NetApp welcomes your comments and suggestions about the ONTAP REST API and the documentation for its use.</br> **Using the ONTAP 9.6 REST API online documentation** Each API method includes usage examples, as well as a model that displays all the required and optional properties supported by the method. Click the _Model_ link, available with each API method, to see all the required and optional properties supported by each method. 
 *
 * API version: v1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package ontap

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// NameServicesApiService NameServicesApi service
type NameServicesApiService service

// DnsCollectionGetOpts Optional parameters for the method 'DnsCollectionGet'
type DnsCollectionGetOpts struct {
    Domains optional.String
    SvmUuid optional.String
    SvmName optional.String
    Servers optional.String
    Fields optional.Interface
    MaxRecords optional.Int32
    ReturnRecords optional.Bool
    ReturnTimeout optional.Int32
    OrderBy optional.Interface
}

/*
DnsCollectionGet Method for DnsCollectionGet
Retrieves the DNS configurations of all data SVMs. DNS configuration for the cluster is retrieved and managed via [&#x60;/api/cluster&#x60;](#docs-cluster-cluster). ### Related ONTAP commands * &#x60;vserver services name-service dns show&#x60; * &#x60;vserver services name-service dns check&#x60; ### Learn more * [&#x60;DOC /name-services/dns&#x60;](#docs-name-services-name-services_dns) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DnsCollectionGetOpts - Optional Parameters:
 * @param "Domains" (optional.String) -  Filter by domains
 * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
 * @param "SvmName" (optional.String) -  Filter by svm.name
 * @param "Servers" (optional.String) -  Filter by servers
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return DnsResponse
*/
func (a *NameServicesApiService) DnsCollectionGet(ctx _context.Context, localVarOptionals *DnsCollectionGetOpts) (DnsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DnsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/name-services/dns"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Domains.IsSet() {
		localVarQueryParams.Add("domains", parameterToString(localVarOptionals.Domains.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Servers.IsSet() {
		localVarQueryParams.Add("servers", parameterToString(localVarOptionals.Servers.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v DnsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// DnsCreateOpts Optional parameters for the method 'DnsCreate'
type DnsCreateOpts struct {
    Info optional.Interface
}

/*
DnsCreate Method for DnsCreate
Creates DNS domain and server configurations for an SVM.&lt;br/&gt; ### Important notes - Each SVM can have only one DNS configuration. - The domain name and the servers fields cannot be empty. - IPv6 must be enabled if IPv6 family addresses are specified in the &#x60;servers&#x60; field. - Configuring more than one DNS server is recommended to avoid a single point of failure. - The DNS server specified using the &#x60;servers&#x60; field is validated during this operation.&lt;br/&gt; &lt;/br&gt; The validation fails in the following scenarios:&lt;br/&gt; 1. The server is not a DNS server. 2. The server does not exist. 3. The server is unreachable.&lt;br/&gt;  ### Learn more * [&#x60;DOC /name-services/dns&#x60;](#docs-name-services-name-services_dns)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DnsCreateOpts - Optional Parameters:
 * @param "Info" (optional.Interface of Dns) -  Info specification
@return DnsResponse
*/
func (a *NameServicesApiService) DnsCreate(ctx _context.Context, localVarOptionals *DnsCreateOpts) (DnsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DnsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/name-services/dns"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(Dns)
		if !localVarOptionalInfook {
			return localVarReturnValue, nil, reportError("info should be Dns")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 201 {
			var v DnsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
DnsDelete Method for DnsDelete
Deletes DNS domain configuration of the specified SVM. ### Related ONTAP commands * &#x60;vserver services name-service dns delete&#x60; ### Learn more * [&#x60;DOC /name-services/dns&#x60;](#docs-name-services-name-services_dns) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
*/
func (a *NameServicesApiService) DnsDelete(ctx _context.Context, svmUuid string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/name-services/dns/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", _neturl.QueryEscape(parameterToString(svmUuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// DnsGetOpts Optional parameters for the method 'DnsGet'
type DnsGetOpts struct {
    Fields optional.Interface
}

/*
DnsGet Method for DnsGet
Retrieves DNS domain and server configuration of an SVM. By default, both DNS domains and servers are displayed. DNS configuration for the cluster is retrieved and managed via [&#x60;/api/cluster&#x60;](#docs-cluster-cluster). ### Related ONTAP commands * &#x60;vserver services name-service dns show&#x60; * &#x60;vserver services name-service dns check&#x60; ### Learn more * [&#x60;DOC /name-services/dns&#x60;](#docs-name-services-name-services_dns) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param optional nil or *DnsGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return Dns
*/
func (a *NameServicesApiService) DnsGet(ctx _context.Context, svmUuid string, localVarOptionals *DnsGetOpts) (Dns, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Dns
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/name-services/dns/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", _neturl.QueryEscape(parameterToString(svmUuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Dns
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// DnsModifyOpts Optional parameters for the method 'DnsModify'
type DnsModifyOpts struct {
    Info optional.Interface
}

/*
DnsModify Method for DnsModify
Updates DNS domain and server configurations of an SVM. ### Important notes - Both DNS domains and servers can be modified. - The domains and servers fields cannot be empty. - IPv6 must be enabled if IPv6 family addresses are specified for the &#x60;servers&#x60; field. - The DNS server specified using the &#x60;servers&#x60; field is validated during this operation.&lt;br/&gt; The validation fails in the following scenarios:&lt;br/&gt; 1. The server is not a DNS server. 2. The server does not exist. 3. The server is unreachable.&lt;br/&gt;  ### Learn more * [&#x60;DOC /name-services/dns&#x60;](#docs-name-services-name-services_dns)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param optional nil or *DnsModifyOpts - Optional Parameters:
 * @param "Info" (optional.Interface of Dns) -  Info specification
*/
func (a *NameServicesApiService) DnsModify(ctx _context.Context, svmUuid string, localVarOptionals *DnsModifyOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/name-services/dns/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", _neturl.QueryEscape(parameterToString(svmUuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(Dns)
		if !localVarOptionalInfook {
			return nil, reportError("info should be Dns")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// LdapCollectionGetOpts Optional parameters for the method 'LdapCollectionGet'
type LdapCollectionGetOpts struct {
    Fields optional.Interface
    MaxRecords optional.Int32
    ReturnRecords optional.Bool
    ReturnTimeout optional.Int32
    OrderBy optional.Interface
}

/*
LdapCollectionGet Method for LdapCollectionGet
Retrieves the LDAP configurations for all SVMs.  ### Learn more * [&#x60;DOC /name-services/ldap&#x60;](#docs-name-services-name-services_ldap)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *LdapCollectionGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return LdapServiceResponse
*/
func (a *NameServicesApiService) LdapCollectionGet(ctx _context.Context, localVarOptionals *LdapCollectionGetOpts) (LdapServiceResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LdapServiceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/name-services/ldap"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v LdapServiceResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// LdapCreateOpts Optional parameters for the method 'LdapCreate'
type LdapCreateOpts struct {
    Info optional.Interface
}

/*
LdapCreate Method for LdapCreate
Creates an LDAP configuration for an SVM. ### Important notes * Each SVM can have one LDAP configuration. * The LDAP servers and Active Directory domain are mutually exclusive fields. These fields cannot be empty. At any point in time, either the LDAP servers or Active Directory domain must be populated. * IPv6 must be enabled if IPv6 family addresses are specified.&lt;/br&gt; #### The following parameters are optional: - preferred AD servers - schema - port - min_bind_level - bind_password - base_scope - use_start_tls - session_security&lt;/br&gt; Configuring more than one LDAP server is recommended to avoid a single point of failure. Both FQDNs and IP addresses are supported for the \&quot;servers\&quot; field. The Acitve Directory domain or LDAP servers are validated as part of this operation.&lt;/br&gt; LDAP validation fails in the following scenarios:&lt;br/&gt; 1. The server does not have LDAP installed. 2. The server or Active Directory domain is invalid. 3. The server or Active Directory domain is unreachable.&lt;br/&gt;  ### Learn more * [&#x60;DOC /name-services/ldap&#x60;](#docs-name-services-name-services_ldap)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *LdapCreateOpts - Optional Parameters:
 * @param "Info" (optional.Interface of LdapService) -  Info specification
@return LdapServiceResponse
*/
func (a *NameServicesApiService) LdapCreate(ctx _context.Context, localVarOptionals *LdapCreateOpts) (LdapServiceResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LdapServiceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/name-services/ldap"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(LdapService)
		if !localVarOptionalInfook {
			return localVarReturnValue, nil, reportError("info should be LdapService")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 201 {
			var v LdapServiceResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
LdapDelete Method for LdapDelete
Deletes the LDAP configuration of the specified SVM. LDAP can be removed as a source from the ns-switch if LDAP is not used as a source for lookups.  ### Learn more * [&#x60;DOC /name-services/ldap&#x60;](#docs-name-services-name-services_ldap)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
*/
func (a *NameServicesApiService) LdapDelete(ctx _context.Context, svmUuid string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/name-services/ldap/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", _neturl.QueryEscape(parameterToString(svmUuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// LdapGetOpts Optional parameters for the method 'LdapGet'
type LdapGetOpts struct {
    Fields optional.Interface
}

/*
LdapGet Method for LdapGet
Retrieves LDAP configuration for an SVM. All parameters for the LDAP configuration are displayed by default.  ### Learn more * [&#x60;DOC /name-services/ldap&#x60;](#docs-name-services-name-services_ldap)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param optional nil or *LdapGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return LdapService
*/
func (a *NameServicesApiService) LdapGet(ctx _context.Context, svmUuid string, localVarOptionals *LdapGetOpts) (LdapService, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LdapService
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/name-services/ldap/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", _neturl.QueryEscape(parameterToString(svmUuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v LdapService
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// LdapModifyOpts Optional parameters for the method 'LdapModify'
type LdapModifyOpts struct {
    Info optional.Interface
}

/*
LdapModify Method for LdapModify
Updates an LDAP configuration of an SVM. ### Important notes * Both mandatory and optional parameters of the LDAP configuration can be updated. * The LDAP servers and Active Directory domain are mutually exclusive fields. These fields cannot be empty. At any point in time, either the LDAP servers or Active Directory domain must be populated. * IPv6 must be enabled if IPv6 family addresses are specified.&lt;br/&gt; &lt;/br&gt;Configuring more than one LDAP server is recommended to avoid a sinlge point of failure. Both FQDNs and IP addresses are supported for the \&quot;servers\&quot; field. The Active Directory domain or LDAP servers are validated as part of this operation.&lt;br/&gt; LDAP validation fails in the following scenarios:&lt;br/&gt; 1. The server does not have LDAP installed. 2. The server or Active Directory domain is invalid. 3. The server or Active Directory domain is unreachable&lt;br/&gt;  ### Learn more * [&#x60;DOC /name-services/ldap&#x60;](#docs-name-services-name-services_ldap)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param optional nil or *LdapModifyOpts - Optional Parameters:
 * @param "Info" (optional.Interface of LdapService) -  Info specification
*/
func (a *NameServicesApiService) LdapModify(ctx _context.Context, svmUuid string, localVarOptionals *LdapModifyOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/name-services/ldap/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", _neturl.QueryEscape(parameterToString(svmUuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(LdapService)
		if !localVarOptionalInfook {
			return nil, reportError("info should be LdapService")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// NameMappingCollectionGetOpts Optional parameters for the method 'NameMappingCollectionGet'
type NameMappingCollectionGetOpts struct {
    SvmUuid optional.String
    SvmName optional.String
    ClientMatch optional.String
    Replacement optional.String
    Direction optional.String
    Pattern optional.String
    Index optional.Int32
    Fields optional.Interface
    MaxRecords optional.Int32
    ReturnRecords optional.Bool
    ReturnTimeout optional.Int32
    OrderBy optional.Interface
}

/*
NameMappingCollectionGet Method for NameMappingCollectionGet
Retrieves the name mapping configuration for all SVMs. ### Related ONTAP commands * &#x60;vserver name-mapping show&#x60; ### Learn more * [&#x60;DOC /name-services/name-mappings&#x60;](#docs-name-services-name-services_name-mappings) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *NameMappingCollectionGetOpts - Optional Parameters:
 * @param "SvmUuid" (optional.String) -  Filter by svm.uuid
 * @param "SvmName" (optional.String) -  Filter by svm.name
 * @param "ClientMatch" (optional.String) -  Filter by client_match
 * @param "Replacement" (optional.String) -  Filter by replacement
 * @param "Direction" (optional.String) -  Filter by direction
 * @param "Pattern" (optional.String) -  Filter by pattern
 * @param "Index" (optional.Int32) -  Filter by index
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return NameMappingResponse
*/
func (a *NameServicesApiService) NameMappingCollectionGet(ctx _context.Context, localVarOptionals *NameMappingCollectionGetOpts) (NameMappingResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NameMappingResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/name-services/name-mappings"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.SvmUuid.IsSet() {
		localVarQueryParams.Add("svm.uuid", parameterToString(localVarOptionals.SvmUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SvmName.IsSet() {
		localVarQueryParams.Add("svm.name", parameterToString(localVarOptionals.SvmName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClientMatch.IsSet() {
		localVarQueryParams.Add("client_match", parameterToString(localVarOptionals.ClientMatch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Replacement.IsSet() {
		localVarQueryParams.Add("replacement", parameterToString(localVarOptionals.Replacement.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Direction.IsSet() {
		localVarQueryParams.Add("direction", parameterToString(localVarOptionals.Direction.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Pattern.IsSet() {
		localVarQueryParams.Add("pattern", parameterToString(localVarOptionals.Pattern.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Index.IsSet() {
		localVarQueryParams.Add("index", parameterToString(localVarOptionals.Index.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v NameMappingResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// NameMappingCreateOpts Optional parameters for the method 'NameMappingCreate'
type NameMappingCreateOpts struct {
    Info optional.Interface
}

/*
NameMappingCreate Method for NameMappingCreate
Creates name mappings for an SVM. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the name mapping. * &#x60;index&#x60; - Name mapping&#39;s position in the priority list. * &#x60;direction&#x60; - Direction of the name mapping. * &#x60;pattern&#x60; - Pattern to match to. Maximum length is 256 characters. * &#x60;replacement&#x60; - Replacement pattern to match to. Maximum length is 256 characters. ### Recommended optional properties * &#x60;client_match&#x60; - Hostname or IP address added to match the pattern to the client&#39;s workstation IP address. ### Related ONTAP commands * &#x60;vserver name-mapping create&#x60; * &#x60;vserver name-mapping insert&#x60; ### Learn more * [&#x60;DOC /name-services/name-mappings&#x60;](#docs-name-services-name-services_name-mappings) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *NameMappingCreateOpts - Optional Parameters:
 * @param "Info" (optional.Interface of NameMapping) -  Info specification
@return NameMappingResponse
*/
func (a *NameServicesApiService) NameMappingCreate(ctx _context.Context, localVarOptionals *NameMappingCreateOpts) (NameMappingResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NameMappingResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/name-services/name-mappings"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(NameMapping)
		if !localVarOptionalInfook {
			return localVarReturnValue, nil, reportError("info should be NameMapping")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 201 {
			var v NameMappingResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
NameMappingDelete Method for NameMappingDelete
Deletes the name mapping configuration. ### Related ONTAP commands * &#x60;vserver name-mapping delete&#x60; ### Learn more * [&#x60;DOC /name-services/name-mappings&#x60;](#docs-name-services-name-services_name-mappings) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param direction Direction
 * @param index Position of the entry in the list
*/
func (a *NameServicesApiService) NameMappingDelete(ctx _context.Context, svmUuid string, direction string, index int32) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/name-services/name-mappings/{svm.uuid}/{direction}/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", _neturl.QueryEscape(parameterToString(svmUuid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"direction"+"}", _neturl.QueryEscape(parameterToString(direction, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", _neturl.QueryEscape(parameterToString(index, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// NameMappingModifyOpts Optional parameters for the method 'NameMappingModify'
type NameMappingModifyOpts struct {
    Info optional.Interface
}

/*
NameMappingModify Method for NameMappingModify
Updates the name mapping configuration of an SVM. ### Related ONTAP commands * &#x60;vserver name-mapping insert&#x60; * &#x60;vserver name-mapping modify&#x60; ### Learn more * [&#x60;DOC /name-services/name-mappings&#x60;](#docs-name-services-name-services_name-mappings) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param direction Direction
 * @param index Position of the entry in the list
 * @param optional nil or *NameMappingModifyOpts - Optional Parameters:
 * @param "Info" (optional.Interface of NameMapping) -  Info specification
*/
func (a *NameServicesApiService) NameMappingModify(ctx _context.Context, svmUuid string, direction string, index int32, localVarOptionals *NameMappingModifyOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/name-services/name-mappings/{svm.uuid}/{direction}/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", _neturl.QueryEscape(parameterToString(svmUuid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"direction"+"}", _neturl.QueryEscape(parameterToString(direction, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", _neturl.QueryEscape(parameterToString(index, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(NameMapping)
		if !localVarOptionalInfook {
			return nil, reportError("info should be NameMapping")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// NameMappingPositionGetOpts Optional parameters for the method 'NameMappingPositionGet'
type NameMappingPositionGetOpts struct {
    Fields optional.Interface
}

/*
NameMappingPositionGet Method for NameMappingPositionGet
Retrieves the name mapping configuration of an SVM. ### Related ONTAP commands * &#x60;vserver name-mapping show&#x60; ### Learn more * [&#x60;DOC /name-services/name-mappings&#x60;](#docs-name-services-name-services_name-mappings) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param direction Direction
 * @param index Position of the entry in the list
 * @param optional nil or *NameMappingPositionGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return NameMapping
*/
func (a *NameServicesApiService) NameMappingPositionGet(ctx _context.Context, svmUuid string, direction string, index int32, localVarOptionals *NameMappingPositionGetOpts) (NameMapping, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NameMapping
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/name-services/name-mappings/{svm.uuid}/{direction}/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", _neturl.QueryEscape(parameterToString(svmUuid, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"direction"+"}", _neturl.QueryEscape(parameterToString(direction, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", _neturl.QueryEscape(parameterToString(index, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v NameMapping
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// NisCollectionGetOpts Optional parameters for the method 'NisCollectionGet'
type NisCollectionGetOpts struct {
    Fields optional.Interface
    MaxRecords optional.Int32
    ReturnRecords optional.Bool
    ReturnTimeout optional.Int32
    OrderBy optional.Interface
}

/*
NisCollectionGet Method for NisCollectionGet
Retrieves NIS domain configurations of all the SVMs. The bound_servers field indicates the successfully bound NIS servers. Lookups and authentications fail if there are no bound servers. ### Related ONTAP commands * &#x60;vserver services name-service nis-domain show&#x60; * &#x60;vserver services name-service nis-domain show-bound&#x60; ### Learn more * [&#x60;DOC /name-services/nis&#x60;](#docs-name-services-name-services_nis) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *NisCollectionGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
 * @param "MaxRecords" (optional.Int32) -  Limit the number of records returned.
 * @param "ReturnRecords" (optional.Bool) -  The default is true for GET calls.  When set to false, only the number of records is returned.
 * @param "ReturnTimeout" (optional.Int32) -  The number of seconds to allow the call to execute before returning.  When iterating over a collection, the default is 15 seconds.  ONTAP returns earlier if either max records or the end of the collection is reached.
 * @param "OrderBy" (optional.Interface of []string) -  Order results by specified fields and optional [asc|desc] direction. Default direction is 'asc' for ascending.
@return NisServiceResponse
*/
func (a *NameServicesApiService) NisCollectionGet(ctx _context.Context, localVarOptionals *NisCollectionGetOpts) (NisServiceResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NisServiceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/name-services/nis"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MaxRecords.IsSet() {
		localVarQueryParams.Add("max_records", parameterToString(localVarOptionals.MaxRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnRecords.IsSet() {
		localVarQueryParams.Add("return_records", parameterToString(localVarOptionals.ReturnRecords.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnTimeout.IsSet() {
		localVarQueryParams.Add("return_timeout", parameterToString(localVarOptionals.ReturnTimeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OrderBy.IsSet() {
		localVarQueryParams.Add("order_by", parameterToString(localVarOptionals.OrderBy.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v NisServiceResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// NisCreateOpts Optional parameters for the method 'NisCreate'
type NisCreateOpts struct {
    Info optional.Interface
}

/*
NisCreate Method for NisCreate
Creates an NIS domain and server confguration for a data SVM. NIS configuration for the cluster is managed via [&#x60;/api/security/authentication/cluster/nis&#x60;](#docs-security-security_authentication_cluster_nis).&lt;br/&gt; ### Important notes   - Each SVM can have one NIS domain configuration.   - Multiple SVMs can be configured with the same NIS domain. Specify the NIS domain and NIS servers as input.Domain name and servers fields cannot be empty.   - Both FQDNs and IP addresses are supported for the servers field.   - IPv6 must be enabled if IPv6 family addresses are specified in the servers field.   - A maximum of ten NIS servers are supported. ### Required properties * &#x60;svm.uuid&#x60; or &#x60;svm.name&#x60; - Existing SVM in which to create the NIS configuration. * &#x60;domain&#x60; - NIS domain to which the configuration belongs. * &#x60;servers&#x60; - List of NIS server IP addresses. ### Related ONTAP commands * &#x60;vserver services name-service nis-domain create&#x60; ### Learn more * [&#x60;DOC /name-services/nis&#x60;](#docs-name-services-name-services_nis) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *NisCreateOpts - Optional Parameters:
 * @param "Info" (optional.Interface of NisService) -  Info specification
@return NisServiceResponse
*/
func (a *NameServicesApiService) NisCreate(ctx _context.Context, localVarOptionals *NisCreateOpts) (NisServiceResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NisServiceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/name-services/nis"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(NisService)
		if !localVarOptionalInfook {
			return localVarReturnValue, nil, reportError("info should be NisService")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 201 {
			var v NisServiceResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
NisDelete Method for NisDelete
Deletes the NIS domain configuration of an SVM. NIS can be removed as a source from ns-switch if NIS is not used for lookups. ### Related ONTAP commands * &#x60;vserver services name-service nis-domain delete&#x60; ### Learn more * [&#x60;DOC /name-services/nis&#x60;](#docs-name-services-name-services_nis) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
*/
func (a *NameServicesApiService) NisDelete(ctx _context.Context, svmUuid string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/name-services/nis/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", _neturl.QueryEscape(parameterToString(svmUuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// NisGetOpts Optional parameters for the method 'NisGet'
type NisGetOpts struct {
    Fields optional.Interface
}

/*
NisGet Method for NisGet
Retrieves NIS domain and server configurations of an SVM. Both NIS domain and servers are displayed by default. The bound_servers field indicates the successfully bound NIS servers. ### Related ONTAP commands * &#x60;vserver services name-service nis-domain show&#x60; * &#x60;vserver services name-service nis-domain show-bound&#x60; ### Learn more * [&#x60;DOC /name-services/nis&#x60;](#docs-name-services-name-services_nis) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param optional nil or *NisGetOpts - Optional Parameters:
 * @param "Fields" (optional.Interface of []string) -  Specify the fields to return.
@return NisService
*/
func (a *NameServicesApiService) NisGet(ctx _context.Context, svmUuid string, localVarOptionals *NisGetOpts) (NisService, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NisService
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/name-services/nis/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", _neturl.QueryEscape(parameterToString(svmUuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v NisService
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// NisModifyOpts Optional parameters for the method 'NisModify'
type NisModifyOpts struct {
    Info optional.Interface
}

/*
NisModify Method for NisModify
Updates NIS domain and server configuration of an SVM.&lt;br/&gt; ### Important notes   - Both NIS domain and servers can be modified.   - Domains and servers cannot be empty.   - Both FQDNs and IP addresses are supported for the servers field.   - If the domain is modified, NIS servers must also be specified.   - IPv6 must be enabled if IPv6 family addresses are specified for the servers field. ### Related ONTAP commands * &#x60;vserver services name-service nis-domain modify&#x60; ### Learn more * [&#x60;DOC /name-services/nis&#x60;](#docs-name-services-name-services_nis) 
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param svmUuid UUID of the SVM to which this object belongs.
 * @param optional nil or *NisModifyOpts - Optional Parameters:
 * @param "Info" (optional.Interface of NisService) -  Info specification
*/
func (a *NameServicesApiService) NisModify(ctx _context.Context, svmUuid string, localVarOptionals *NisModifyOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/name-services/nis/{svm.uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"svm.uuid"+"}", _neturl.QueryEscape(parameterToString(svmUuid, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/hal+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/hal+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Info.IsSet() {
		localVarOptionalInfo, localVarOptionalInfook := localVarOptionals.Info.Value().(NisService)
		if !localVarOptionalInfook {
			return nil, reportError("info should be NisService")
		}
		localVarPostBody = &localVarOptionalInfo
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
